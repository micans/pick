#!/usr/bin/perl

use warnings;
use strict;

#  This reads and outputs the same format, where alignments can be formatted with a specified block width.
#  Alignments are recognised as lines starting with '++ '. The output contains the same prefix; the
#  prefix does not contribute to the specified block width. Example:

my $example = <<EOT;
readGBW1x-1
GBW2rc
++ 100       110       120       130       
++ CCCCCTGAACGCTTATCGCGTGAGCGATTTGCTAAGTTCG
++ ....................|||x|xx||||-|||-||-|
++ CTGAGGCTCCTCGCTTATCGTGACCAGTTTG-TAA-TT-G
++ ............................... ... .. .
.
++ 140         150       160       170     
++ TTTGAA--CGATACGGGCGAGTCTACTAAGATTC--TGCC
++ -|||x|~~||||------||||-|-|||||-|||~~||||
++ -TTGCAGGCGAT------GAGT-T-CTAAG-TTCATTGCC
++  ...........      .... . ..... .........
.
++     180       190       2
++ CTTGCGAGCTCTATCAGAACATATG
++ |||||....................
++ CTTGCGAGCTCGTGAACATATGACC
++ .........................
.
EOT

#  The full format is
#
#  - any line not starting with '++ ' or being a single '.' is copied verbatim.
#  - blocks of lines starting with '++ ' are taken as alignments
#  - lines consisting of a single '.' are considered to be the separator for already-wrapped alignments.
#  - these blocks (if present) are concatenated
#  - the result is wrapped with the specified wrapping width.
#  - the output blocks again start with '++ ' and wrapped blocks are separated by a line consisting of a single '.' .

my $lw = 160;

if (@ARGV && $ARGV[0] =~ /^\d+$/) {
  $lw = shift @ARGV;
}

sub aln_append {
  my $s1 = scalar @::aln;
  my $s2 = scalar @::aln_unit;
  if ($s1 && $s1 != $s2) {
    die "Alignment has subunits of different counts (current $s1 new $s2 at $.)";
  }
  my @lengths = sort { $b <=> $a } map { length($_) } @::aln_unit;
  for (my $i=0; $i < @::aln_unit; $i++) {
    $::aln[$i] .= $::aln_unit[$i] . ' ' x ($lengths[0] - length($::aln_unit[$i]));
  }
  @::aln_unit = ();
}

sub aln_flush {
  my $o = 0;
  while ($o < length($::aln[0])) {
    print join "\n", map { '++ ' . substr($_, $o, $lw) } @::aln;
    print "\n.\n";
    $o += $lw;
  }
  @::aln = ();
}

@::aln = ();
@::aln_unit = ();


while (<>) {

  chomp;
  my $l = $_;

  if ($l =~ /^\+\+ /) {
    push @::aln_unit, substr($l, 3);
  }
  elsif ($l eq '.' && @::aln_unit) {
    aln_append();
  }
  else {
    aln_append() if @::aln_unit;
    aln_flush()  if @::aln;
    print "$l\n";
  }
}

aln_append() if @::aln_unit;
aln_flush()  if @::aln;

