#!/bin/bash

set -euo pipefail

simpleQ=false
list=false
help=false
use_ref=
use_sam=-
use_bounds=
beyond_bounds=
use_zoom=
extra_header=1
dictlist=
N_wrap=0

while getopts :r:s:d:b:e:w:z:x:QLh opt
do
    case "$opt" in
    r)
      use_ref=$OPTARG
      ;;
    s)
      use_sam=$OPTARG
      ;;
    d)
      IFS=: read fname tag default <<< "$OPTARG"
      if [[ -z $tag ]]; then
         echo "-d: expect fname:tag argument"
         false
      elif [[ ! -f $fname ]]; then
         echo "-d: $fname not a regular file"
         false
      fi
      if [[ ! -z $default ]]; then
         dictlist="$dictlist --fdict-$tag/$default=$fname"
      else
         dictlist="$dictlist --fdict-$tag=$fname"
      fi
      ;;
    b)
      use_bounds=$OPTARG
      ;;
    e)
      beyond_bounds=$OPTARG
      ;;
    x)
      extra_header=$OPTARG
      ;;
    Q)
      simpleQ=true
      ;;
    L)
      list=true
      ;;
    z)
      use_zoom=$OPTARG
      ;;
    w)
      N_wrap=$OPTARG
      ;;
    h)
      cat <<EOU
Pretty-print alignments; allows focus on alignment boundaries (-b or -e) or specific intervals (-z).
Wraps pick command line (use -L to view)

Base usage: -r <REFERENCE> -s <SAM-FILE>

Input is SAM. For bam files use
  samtools view [-h] <bamfile> | showalign -r <REF> [options]

To output wrapped alignments use -w <WIDTH>

-r <fname>    reference file (fasta).
-s <fname>    SAM input (- for STDIN, which is default).
-e N          show N bases context beyond alignment bound.
-b x,y        ensure alignment includes reference coordinates [x-y].
-z u,v        zoom / narrow alignment to reference coordinates [x-y] (removes all other alignment information).
-w N          pass alignment to wrapalign with width N.

-d fname:tag:defval
              make the dictionary in fname available to pick with name tag and default value defval.
              this will be passed as --fdict-tag/defval=fname to pick, to be used as ^tag,map in -x argument.
              set defval to __EXIT__ to cause an error if key is not found.
              defval can be omitted, causing unmappable keys to map to themselves.
              repeated use of -d is possible with the same or different tags.

-x <pick-list>
              pick code to replace header before alignment. Default header is just the read name.
              -x 1 is the default setting (1 denotes column one of SAM format - the read name).
              example: -x '1^edit=,aln_nedit,cat' to have read name with number of edits.
              issue pick -l sam for possibilities.
              issue showalign [options] -L to see the constructed pick command line.

-L            show rather than execute the command constructed by showalign.
-Q            use simplified quality scheme.

              .....,,,,,aaaaaAAAAAbbbbbBBBBBcccccCCCCCdddddDDDDDeeeeeEEEEEfffffFFFFFgggggGGGGGhhhhhHHHHHiiii
                     3  | 1  | 3  | 1  | 3  | 1  | 3  | 1  | 3  | 1  | 3  | 1  | 3  | 1  | 3  | 1  | 3  | 1 |
                     -- | -- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |---|
                     10 | 10 |100 |100 |1e3 |1e3 |1e4 |1e4 |1e5 |1e5 |1e6 |1e6 |1e7 |1e7 |1e8 |1e8 |1e9 |1e9|
EOU
      exit
      ;;
    :)
      error="Flag $OPTARG needs argument"
      false
      ;;
    ?)
      error="Flag $OPTARG unknown"
      false
      ;;
   esac
done

shift $(($OPTIND-1))

if (( $# > 0 )); then
  echo "Trailing arguments $@ found" 
  false
fi


nmiss=0
[[ -n $use_ref ]] || { echo "Need reference (-r)" && ((++nmiss)); }

if ((nmiss > 0)); then
  echo "Required argument(s) missing (-h for help)"
  false
fi

if [[ $use_sam == '-' ]]; then
   >&2 echo "Reading from STDIN"
fi

moreargs=
mode_wrap=cat

if (( N_wrap > 0 )); then
  mode_wrap="wrapalign $N_wrap"
fi

if $simpleQ; then
  moreargs="$moreargs --sam-qlt-sim"
fi

if [[ -n $use_bounds ]]; then
  moreargs="$moreargs --sam-aln-xy=$use_bounds"
elif [[ -n $use_zoom ]]; then
  moreargs="$moreargs --sam-narrow-xy=$use_zoom"
fi

if [[ -n $beyond_bounds ]]; then
  moreargs="$moreargs --sam-aln-context=$beyond_bounds"
fi

if $list; then
cat <<EOC
   cat $use_sam | pick --sam/$use_ref $dictlist --sam-aln-prefix='++ ' $moreargs ::"$extra_header",aln_allq^^%0A,joinall | $mode_wrap
EOC
else
   cat $use_sam | pick --sam/$use_ref $dictlist --sam-aln-prefix='++ ' $moreargs ::"$extra_header",aln_allq^^%0A,joinall | $mode_wrap
fi

