#!/usr/bin/perl

# Pick version
my $v_v_v = "648830e05efe4e1a2ddcbfd112dcedb56aac2bd4::24-115";

  #                     Copyright (c) 2022-2024  Stijn van Dongen
  #
  #      Permission is hereby granted, free of charge, to any person obtaining a copy
  #      of this software and associated documentation files (the "Software"), to deal
  #      in the Software without restriction, including without limitation the rights
  #      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  #      copies of the Software, and to permit persons to whom the Software is
  #      furnished to do so, subject to the following conditions:
  #
  #      The above copyright notice and this permission notice shall be included in all
  #      copies or substantial portions of the Software.
  #
  #      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  #      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  #      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  #      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  #      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  #      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  #      SOFTWARE.

use strict;
use warnings;
use Digest::MD5 qw(md5_hex);
use Scalar::Util qw(looks_like_number);
use List::Util qw(min max);
use IO::File;
use POSIX;

       ##                                                                               ##
      ##      Pick columns and select rows from tabular input, add derived columns       ##
     ##                 Pick and select either by column name or index                    ##
    ##                 Add new columns, update existing columns in-place                   ##
    ##    Select with numerical and string comparison operators and regular expressions    ##
     ##               Select on either existing columns or derived columns                ##
      ##           Compute derived columns with string and arithmetic operations         ##
       ##                        Add or change column names                             ##
        ##             Select column names using regular expressions                   ##
        ##                                                                             ##
       ##                        Requires tab separated input                           ##
      ##                 See -H (EOH below) and -l (brief help)                          ##

@::spec = @ARGV; @ARGV = ();

sub helphelp {
   my $status = shift;
   print STDERR "Use -l (list) for concise help, -H for long help, -h suppresses header line output\n";
   print STDERR "Pick only works as a pipe, so invoke e.g. as: pick foo bar < data.txt\n";
   exit $status;
}

helphelp(0) unless @::spec;

@::output_nm  = ();         # names - (header|1..N) + compute handles
@::output_os  = ();         # names translated to offsets in @F (field array)
@::compute = ();            # derived column specifications
@::select  = ();            # row select specifications
%::handle_map = ();         # map column names to offsets
%::plain_handle = ();       # handles without any compute following.

my $PAT_PURGE      = '';    # ::/my style is somewhat intractable. :: tend to be thing accessed in subroutines.
my $PAT_PASS       = '';    # PURGE is removed before processing, PASS is passed through before processing.
my $INSERT_OFFSET  = undef; # with -A, where to put extra columns (by default at the end).
my $OFFSET_OMEGA   = -1;    # with -O<N>, accept overflow ragged columns from position <N> onwards.
my $I_AM_SAM       = 0;     # Set with --sam or --sam-h; used for caching of some values.
my $sam_refdictname   = "";    # experimental/fragile

my $B_print_header = 1;     # B_oolean. Also accessed in subroutines.
my $B_select_and   = 1;     # Require all selections to match (use -o for any)
my $B_printall     = 0;     # Select all columns
my $B_inplace      = 0;     # Allow derived column to redefine existing column name
my $B_excise       = 0;     # print all except the plain column handles listed, cannot combine with $B_printall
my $B_add_row_column = 0;   # See -H, EOH
my $B_headless     = 0;     # No header (-k option)
my $B_ko           = 0;     # With -k, make output columns unique and ordered as in output.
my $B_sprouthead   = 0;     # Create header e.g. from derived names
my $B_weirdmode    = 0;     # Header exists, but users wants to use numbers (turns of selections for header)
my $B_force        = 0;     # Force output if identical output names exist
my $F_ignore       = 0;     # Flags: 0 oblivious, 1 pass, 2 purge, 4 read sam sequence lengths SN:(\S+)\s+LN:(\d+)
my $B_debug        = 0;     # Mostly documents the stages of compute and selection definitions
my $L_verbose      = 0;     # Not terrifically interesting
my $B_add_names    = 0;     # If other names are given, whether to output them as column names
my $F_list         = 0;     # output index or name list of selected columns (1: index, 2: name)
my $B_posthoc_names = 0;    # Other names are given solely for output
my $B_regex        = 1;     # Whether to interpret names as a regular expression if one of the characters in $REGEXP_CHARS is found
my $B_protect      = 0;     # Some protection against divide-by-zero; modifiable with PICK_*_INF environment variables.
my $B_protect_discard = 0;  # Discard rows that needed protection.
my $B_count        = 0;     # Only output count of kept rows.
my $N_expect       = -1;    # If set, exit with error if number of non-header rows that is output is different.
my $B_pstore       = 0;     # If set, load ::pstore_cache with previous line final computed fields
my $B_groupfirst   = 0;     # Whether to cache the first row of a group for all subsequent group elements.

my $fh_other       = undef;
my $name_demux     = undef;
my $index_demux    = -1;

$::EPSILON         = 0.0001;     # obvs the best default epsilon - 10,000 is a myriad.
$::OOM             = 2;          # order of magnitude. Maybe sqrt(2) makes more sense.

my $REGEXP_CHARS   = '[({\\\*?^$';
my $DUMMY_NAME     = 'PICKAAAAA';

my $PSTORE_DEFAULT = "00000000";
my $PSTORE_LIST    = '';         # empty string yields empty list when split
my $PSTORE_PIVOT_COLUMN  = undef;
my $PSTORE_PIVOT_HANDLE  = undef;
my $PSTORE_PIVOT_VALUE   = undef;
%::pstore_init  = ();
%::pstore_cache = ();

my $Nprotect      = 0;
my $Nprotect_discard = 0;

my $Nsam_refmiss = 0;
my $Nsam_qrymiss = 0;
my $Nsam_qryunmapped = 0;
my $Nsam_cigarerr = 0;
my $Nsam_lenmiss = 0;
my $Nsam_lenclash = 0;

sub stacky { die "$_[0] stack error\n" unless @::STACK >= $_[1]; }

my %PNAN =                  # Protect against division by zero etc. Defaults that can be overridden.
(  PICK_LOG10_INF => -10000
,  PICK_LOG2_INF  => -10000
,  PICK_LOG_INF   => -10000
,  PICK_TAN_INF   => 'inf'
,  PICK_DIV_INF   => 'inf'
,  PICK_NAN       => 'NaN'
)  ;
for (keys %PNAN) { $PNAN{$_} = $ENV{$_} if defined($ENV{$_}); }


{ my %aatocodon =
  ( '*' => [qw ( TAA TAG TGA ) ]
  , A => [qw ( GCT GCC GCA GCG ) ]
  , C => [qw ( TGT TGC ) ]
  , D => [qw ( GAT GAC ) ]
  , E => [qw ( GAA GAG ) ]
  , F => [qw ( TTT TTC ) ]
  , G => [qw ( GGT GGC GGA GGG ) ]
  , H => [qw ( CAT CAC ) ]
  , I => [qw ( ATT ATC ATA ) ]
  , K => [qw ( AAA AAG ) ]
  , L => [qw ( TTA TTG CTT CTC CTA CTG ) ]
  , M => [qw ( ATG ) ]
  , N => [qw ( AAT AAC ) ]
  , P => [qw ( CCT CCC CCA CCG ) ]
  , Q => [qw ( CAA CAG ) ]
  , R => [qw ( CGT CGC CGA CGG AGA AGG ) ]
  , S => [qw ( TCT TCC TCA TCG AGT AGC ) ]
  , T => [qw ( ACT ACC ACA ACG ) ]
  , V => [qw ( GTT GTC GTA GTG ) ]
  , W => [qw ( TGG ) ]
  , Y => [qw ( TAT TAC ) ]
  );
  my %codontoaa = (); for my $aa (keys %aatocodon) { $codontoaa{$_} = $aa for @{$aatocodon{$aa} } }
  sub dna_tl {
    my $codons = uc(shift);
    my $frame  = shift;
    return "" if length($codons) <= length($frame);
    $codons = substr($codons, $frame) if $frame;
    my $ret = "";
    while ($codons =~ /(...)/g) {
      my $aa = $codontoaa{$1};
      $ret .= defined($aa) ? $aa : '?';
    }
    $ret .= '{' . substr($codons, length($ret)*3) . '}' if 3*length($ret) != length($codons);
       # fixme, above should be user-definable. Not sure what's useful here.
    return $ret;
  }
}

sub strpair {
   my ($x, $y) = @_;
   my $ret = "";
   for (my $i=0; $i<length($x) && $i<length($y); $i++) {
      $ret .= substr($x, $i, 1) eq substr($y, $i, 1) ? '|' : 'x';
   }
   return $ret;
}

sub hmeanall {
   my $ret = 0.0;
   if ($B_protect && grep { $_ == 0 } @::STACK) { $Nprotect++; }
   else {
      my $x = 0; $x += 1/abs($_) for @::STACK;
      if ($x || !$B_protect) { $ret = @::STACK / $x; } else { $Nprotect++ }
   }
   return $ret;
}

sub rc {
   my $s = shift;
   $s =~ tr/acgtuACGTU/tgcaaTGCAA/;
   return reverse($s);
}
                            # Nearly all of the below push 1 item on the stack after consuming X.
                            # Only X is specified; X = 0 indicate exceptional cases.
                            # Potentially neatify this by adding Y (number of pushed items).
my %cp_opdefinitions =
   ( add       => [ 2, sub { $::STACK[-2] += $::STACK[-1] }, "x y\tx+y\tAdd x and y, sum, addition\tarithmetic" ],
     addall    => [ 0, sub { my $x = 0; $x += $_ for @::STACK; @::STACK = ($x) }, "*\tsum(Stack)\tSum of all entries in stack\tarithmetic/devour" ],
     mulall    => [ 0, sub { my $x = 1; $x *= $_ for @::STACK; @::STACK = ($x) }, "*\tproduct(Stack)\tProduct of all entries in stack, multiplication\tarithmetic/devour" ],
     maxall    => [ 0, sub { my $x = -POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ > $x }; @::STACK = ($x) }, "*\tmax(Stack)\tMax over all entries in stack\tarithmetic/devour" ],
     minall    => [ 0, sub { my $x =  POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ < $x }; @::STACK = ($x) }, "*\tmin(Stack)\tMin over all entries in stack\tarithmetic/devour" ],
     catall    => [ 0, sub { my $x = join "", @::STACK; @::STACK = ($x) }, "*\tStack-joined\tStringified stack\tstring/devour" ],
     meanall   => [ 0, sub { my $x = 0; $x += $_ for @::STACK; @::STACK = @::STACK ? ($x/@::STACK) : (0.0) }, "*\tmean(Stack)\tMean of all entries in stack\tarithmetic/devour" ],
     hmeanall  => [ 0, sub { @::STACK = hmeanall }, "*\thmean(Stack)\tHarmonic mean of all entries in stack\tarithmetic/devour" ],
     gmeanall  => [ 0, sub { my $x = 1; $x *= abs($_) for @::STACK; @::STACK = @::STACK ? ($x**(1/@::STACK)) : (1.0) }, "*\tgmean(Stack)\tGeometric mean of all entries in stack, multiplication\tarithmetic/devour" ],
     rand      => [ 1, sub { $::STACK[-1] = rand($::STACK[-1]) }, "x\trand(x)\tRandom real in range [0, x)\tarithmetic" ],
     joinall   => [ 1, sub { my $j = pop(@::STACK); my $x = join $j, @::STACK; @::STACK = ($x) }, "* s\tStack-joined-by-s\tStringified stack with s as separator\tstring/devour" ],
     mul       => [ 2, sub { $::STACK[-2] *= $::STACK[-1] }, "x y\tx*y\tMultiply x and y, multiplication, product\tarithmetic"  ],
     div       => [ 2, sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? $x / $y : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y\tx/y\tDivision, fraction, (cf -P and PICK_DIV_INF)\tarithmetic" ],
     idiv      => [ 2, sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? ($x-($x % $y))/$y : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y\tx // y\tInteger division, divide (cf -P and PICK_DIV_INF)\tarithmetic" ],
     cat       => [ 2, sub { $::STACK[-2] .= $::STACK[-1] }, "x y\txy\tConcatenation of x and y\tstring" ],
     sub       => [ 2, sub { $::STACK[-2] -= $::STACK[-1] }, "x y\tx-y\tSubtract y from x, subtraction\tarithmetic" ],

     pop       => [ 0, sub { stacky('pop', 1); pop @::STACK }, "x\t-\tRemove top entry x from stack\tstack" ],
     dup       => [ 0, sub { stacky('dup', 1); push @::STACK, $::STACK[-1] }, "x\tx x\tDuplicate top entry x\tstack" ],
     xch       => [ 0, sub { stacky('xch', 2); ($::STACK[-2], $::STACK[-1]) = ($::STACK[-1], $::STACK[-2]) }, "x y\ty x\tExchange x and y\tstack" ],
     rowno     => [ 0, sub { push @::STACK, $::Nrows -1+$B_headless }, "-\tx\tPush current table (start one) row number x onto stack\tinput" ],
     r0wno     => [ 0, sub { push @::STACK, $::Nrows -2+$B_headless }, "-\tx\tPush current table (start zero) row number x onto stack\tinput" ],
     lineno    => [ 0, sub { push @::STACK, $.      }, "-\tx\tPush file line number x onto stack\tinput" ],
     groupno   => [ 0, sub { push @::STACK, $::Ngroup }, "-\tx\tPush group number x onto stack\tinput" ],
     groupi    => [ 0, sub { push @::STACK, $::Groupi }, "-\tx\tPush within-group offset x onto stack\tinput" ],

     save      => [ 2, sub { $::LINECACHE{__REG__}{$::STACK[-1]} = $::STACK[-2] }, "x n\tx\tstore x in register with name n\tstate/stack" ],
     fetch     => [ 1, sub { $::STACK[-1] = $::LINECACHE{__REG__}{$::STACK[-1]} }, "n\treg(n)\tretrieve value in register with name n\tstate/stack" ],
     pload     => [ 1, sub { $::STACK[-1] = $::pstore_cache{$::STACK[-1]}; }, "c\tprevrow[c]\tField of column c in the previous row\tstate/stack" ],
                                                                     # see /pload_validate/

     mod       => [ 2, sub { $::STACK[-2] %= $::STACK[-1] }, "x y\tx mod y\tx modulo y, remainder\tarithmetic" ],
     pow       => [ 2, sub { $::STACK[-2] **= $::STACK[-1] }, "x y\tx**y\tx raised to power y\tarithmetic" ],
     ipow      => [ 2, sub { my $y = $::STACK[-2]; $::STACK[-2] *= $y while --$::STACK[-1] > 0; }, "x y\tx**y\tx raised to power y ensuring integer artithmetic\tarithmetic" ],
     and       => [ 2, sub { $::STACK[-2] &= int($::STACK[-1]) }, "x y\tx and y\tBitwise and between x and y\tbitop" ],
     or        => [ 2, sub { $::STACK[-2] |= int($::STACK[-1]) }, "x y\tx or y\tBitwise or between x and y\tbitop"  ],
     xor       => [ 2, sub { $::STACK[-2] ^= int($::STACK[-1]) }, "x y\tx xor y\tBitwise exclusive or between x and y\tbitop"  ],
     lsh       => [ 2, sub { $::STACK[-2] <<= int($::STACK[-1]) }, "x y\tx << y\tShift x left by y\tbitop"  ],
     rsh       => [ 2, sub { $::STACK[-2] >>= int($::STACK[-1]) }, "x y\tx >> y\tShift x right by y\tbitop"  ],
     max       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] > $::STACK[-2] }, "x y\tmax(x,y)\tMaximum of x and y\tarithmetic" ],
     min       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] < $::STACK[-2] }, "x y\tmin(x,y)\tMinimum of x and y\tarithmetic" ],
     dd        => [ 2, sub { $::STACK[-2] = sprintf("%.*f", $::STACK[-1], $::STACK[-2]) }, "x N\tx'\tFloating point x printed with N decimal digits\tmath/format/precision" ],
     sn        => [ 2, sub { $::STACK[-2] = sprintf("%.*e", $::STACK[-1], $::STACK[-2]) }, "x N\tx'\tFloating point x in scientific notation with N decimal digits\tmath/format/precision" ],
     zp        => [ 2, sub { my $l = $::STACK[-1] - length($::STACK[-2]); $l = 0 if $l < 0; $::STACK[-2] = '0' x $l . $::STACK[-2] }, "x N\tx'\tx left zero-padded to width of N\toutput/string/format" ],
     ppl       => [ 2, sub { $::STACK[-2] = sprintf("%-*s", $::STACK[-1], $::STACK[-2]); }, "x N\tx'\tx blank-padded to width of N\toutput/string/format" ],
     ppr       => [ 2, sub { $::STACK[-2] = sprintf("%*s", $::STACK[-1], $::STACK[-2]); }, "x N\tx'\tx blank-padded to width of N\toutput/string/format" ],

     fasta     => [ 2, sub { $::STACK[-2] = ">$::STACK[-2]\n$::STACK[-1]"; }, "i s\tfasta format\tID and sequence in FASTA format\tformat/bio" ],
     fastq     => [ 2, sub { $::STACK[-2] = "\@$::STACK[-2]\n$::STACK[-1]\n+\n" . 'Z' x length($::STACK[-1]); }, "i s\tfastq format\tID and sequence in FASTQ format\tformat/bio" ],

     cgsum     => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'sum') }, "c s\tSum of s in c\tSum of lengths of s items in cigar string c\tstring/sam" ],
     cgmax     => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'max') }, "c s\tMax of s in c\tMax of lengths of s items in cigar string c\tstring/sam" ],
     cgcount   => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'count') }, "c s\tCount of s in c\tCount of s items in cigar string c\tstring/sam" ],
     cgrefcov  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MDN=X', 'sum') }, "c\trefcov\tCount of reference bases covered by cigar string c (MDN=X events)\tstring/sam" ],
     cgqrycov  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MI=X', 'sum') }, "c\tqrycov\tCount of query bases covered by cigar string c (MI=X events)\tstring/sam"  ],
     cgqrylen  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MISH=X', 'sum') }, "c\tqrylen\tLength of query (MIS=X events) in cigar string c\tstring/sam" ],
     cgqryend  => [ 1, sub { my $e = acigar($::STACK[-1], 'MISH=X', 'sum'); $e -= $1 if $::STACK[-1] =~ /(\d+)[SH]$/; $::STACK[-1] = $e }, "c\tqryend\tLast base considered aligned in query for cigar string c\tstring/sam" ],
     cgqrystart=> [ 1, sub { my $s = 1; $s += $1 if $::STACK[-1] =~ /^(\d+)[SH]/; $::STACK[-1] = $s }, "c\tqrystart\tFirst base considered aligned in query for cigar string c\tstring/sam" ],

     get       => [ 2, sub { my $item =  $::STACK[-2] =~ qr/$::STACK[-1]/
                                         ? (defined($1) ? $1 : $&) : ""; $::STACK[-2] = $item; }, "x p\tp-match-of-x\tIf x matches pattern p take outer () group or entire match, empty string otherwise (cf uie)\tstring/regex" ],
     uie       => [ 2, sub { $::STACK[-2] = $::STACK[-1] unless length($::STACK[-2])}, "x y\tx-or-y\tUse x if not empty, otherwise use y\tstring/branch/test" ],
     ed        => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/  }, "x p s\tx =~ s/p/s/\tSubstitute pattern p by s in x\tstring/regex" ],
     edg       => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/g }, "x p s\tx =~ s/p/s/g\tGlobally substitute pattern p by s in x\tstring/regex" ],
     del       => [ 2, sub { $::STACK[-2] =~ s/$::STACK[-1]// }, "x p\tx =~ s/p//\tDelete pattern p in x\tstring/regex" ],
     delg      => [ 2, sub { $::STACK[-2] =~ s/$::STACK[-1]//g }, "x p\tx =~ s/p//\tGlobally delete pattern p in x\tstring/regex" ],
     npat      => [ 2, sub { $::STACK[-2] = () = ($::STACK[-2] =~ /$::STACK[-1]/g) }, "x p\tnc\tCount occurrences of pattern p in x\tstring/regex" ],
     map       => [ 2, sub {  my ($x, $d) = @::STACK[-2,-1]; my $dict = $::dict{$d}; my $m = defined($dict) ? $dict->{$x} : undef; $::STACK[-2] = defined($m) ? $m : dict_not_found($d, $::STACK[-2]); },
                           "x D\tmap-of-x\tUse map of x in dictionary D (if found; cf --(c|f|fastq-|fastq-)dict-D=\tstring/dictionary"
                  ],
     tmap      => [ 3, sub {  my ($x, $d, $k) = @::STACK[-3,-2, -1]; my $dict = $::dict{$d}{$k}; my $m = defined($dict) ? $dict->{$x} : undef; $::STACK[-3] = defined($m) ? $m : dict_not_found($d, $::STACK[-3]); },
                           "x D c\tmap-of-x\tUse map of x in dictionary D for column c (if found; cf --table-dict-D=\tstring/dictionary"
                  ],
     substr    => [ 3, sub { $::STACK[-3] =  substr($::STACK[-3], $::STACK[-2], $::STACK[-1]) }, "x i k\tx[i:i+k-1]\tSubstring of x starting at i (zero-based) of length k\tstring" ],
     pct       => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y+0 ? sprintf("%.*f", $n, $x * 100 / $y) : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y N\tpct(x/y)\tPercentage of x relative to y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],
     pml       => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y+0 ? sprintf("%.*f", $n, $x * 1000 / $y) : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y N\tpct(x/y)\tPromille of x relative to y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],
     frac      => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y+0 ? sprintf("%.*f", $n, $x / $y) :  ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y N\tx/y\tDivision, fraction x/y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],

     test      => [ 3, sub { $::STACK[-3] = do_test(@::STACK[-3,-2,-1]); }, "x y T\tB\ttest T applied to x y\tbranch/test" ],
     ifelse    => [ 3, sub { $::STACK[-3] = do_ifelse(@::STACK[-3,-2,-1]); }, "B x y\tx or y\tIf B put x else put y\tbranch/test" ],

     todna     => [ 1, sub { $::STACK[-1] =~ tr|uU|tT|; $::STACK[-1] =~ tr|bdefh-mo-su-z|n|; $::STACK[-1] =~ tr|BDEFH-MO-SU-Z|N|; $::STACK[-1] =~ tr|acgntACGNT|N|c; }, "x\tx'\tPreserve case, translate uU to tT, nN for non-DNA\tformat" ],
     tobin     => [ 1, sub { $::STACK[-1] = sprintf("%b", $::STACK[-1]) }, "x\tx'\tBinary representation of x\tformat" ],
     tohex     => [ 1, sub { $::STACK[-1] = sprintf("%x", $::STACK[-1]) }, "x\tx'\tHex representation of x\tformat"  ],
     tooct     => [ 1, sub { $::STACK[-1] = sprintf("%o", $::STACK[-1]) }, "x\tx'\tOctal representation of x\tformat"  ],
     binto     => [ 1, sub { $::STACK[-1] = oct("0b$::STACK[-1]") }, "x\tx'\tRead binary representation x\tinput/format" ],
     hexto     => [ 1, sub { $::STACK[-1] = hex($::STACK[-1]) }, "x\tx'\tRead hex representation x\tinput/format" ],
     octto     => [ 1, sub { $::STACK[-1] = oct($::STACK[-1]) }, "x\tx'\tRead octal representation x\tinput/format" ],
     dnatl     => [ 2, sub { $::STACK[-2] = dna_tl($::STACK[-2], $::STACK[-1]) }, "x f\tx'\tDNA sequence x translated in frame f\tinput/format/bio" ],
     dnagc     => [ 2, sub { my $gc = sprintf("%.*f", $::STACK[-1], 100 * ($::STACK[-2] =~ tr|GCgc|GCgc|) / length($::STACK[-2])); $::STACK[-2] = $gc; }, "x N \tgc(x)\tPercentage GC content of x with N decimal digits\tbio" ],
    _strpair   => [ 2, sub { $::STACK[-2] = strpair($::STACK[-2], $::STACK[-1]); }, "x y\tpair(x,y)\tPairwise character identity\tstring/EXPERIMENTAL" ],
     urldc     => [ 1, sub { $::STACK[-1] = urldecode($::STACK[-1]) }, "x\turldc(x)\tUrl decoding of x\tstring/format/input/output" ],
     urlec     => [ 1, sub { $::STACK[-1] = urlencode($::STACK[-1]) }, "x\turlec(x)\tUrl encoding of x\tstring/format/input/output" ],
     incr      => [ 1, sub { $::STACK[-1]++ }, "x\tx++\tx incremented by one\tarithmetic" ],
     decr      => [ 1, sub { $::STACK[-1]-- }, "x\tx--\tx decremented by one\tarithmetic" ],
     uc        => [ 1, sub { $::STACK[-1] = uc($::STACK[-1]) }, "x\tuc(x)\tUpper case of x\tstring" ],
     lc        => [ 1, sub { $::STACK[-1] = lc($::STACK[-1]) }, "x\tlc(x)\tLower case of x\tstring" ],
     rev       => [ 1, sub { $::STACK[-1] = reverse($::STACK[-1]) }, "x\trev(x)\tString reverse of x\tstring" ],
     rot13     => [ 1, sub { $::STACK[-1] =~ tr/a-zA-Z/n-za-mN-ZA-M/ }, "x\trot13(x)\tRot13 encoding of x\tstring"  ],
     md5       => [ 1, sub { $::STACK[-1] = md5_hex($::STACK[-1]) }, "x\tmd5(x)\tMD5 sum of x\tstring/format/input/output"     ],
     len       => [ 1, sub { $::STACK[-1] = length($::STACK[-1]) }, "x\tlen(x)\tLength of string x\tstring" ],
     rc        => [ 1, sub { $::STACK[-1] =~ tr/acgtuACGTU/tgcaaTGCAA/; $::STACK[-1] = reverse($::STACK[-1]) }, "x\trc(x)\tReverse complement\tstring" ],
     abs       => [ 1, sub { $::STACK[-1] = abs($::STACK[-1]) }, "x\tabs(x)\tAbsolute value of x\tmath" ],
     sqrt      => [ 1, sub { $::STACK[-1] = sqrt($::STACK[-1]) }, "x\tsqrt(x)\tSquare root of x\tmath" ],
     sq        => [ 1, sub { $::STACK[-1] = $::STACK[-1]**2 }, "x\tx^2\tSquare of x\tmath" ],
     exp       => [ 1, sub { $::STACK[-1] = exp($::STACK[-1]) }, "x\te**x\tExponential function applied to x\tmath" ],
     cos       => [ 1, sub { $::STACK[-1] = cos($::STACK[-1]) }, "x\tcos(x)\tCosine of x\tmath" ],
     sin       => [ 1, sub { $::STACK[-1] = sin($::STACK[-1]) }, "x\tsin(x)\tSine of x\tmath" ],
     tan       => [ 1, sub { my $c = cos($::STACK[-1]); $::STACK[-1] = !$B_protect || $c ? sin($::STACK[-1])/$c : ($Nprotect++, $PNAN{PICK_TAN_INF}) }, "x\ttan(x)\tTangens of x\tmath" ],
     log       => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1]) : ($Nprotect++, $PNAN{PICK_LOG_INF}) }, "x\tlog(x)\tNatural logarithm of x\tmath" ],
     log10     => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1]+0 ? log($::STACK[-1])/log(10) : ($Nprotect++, $PNAN{PICK_LOG10_INF}) }, "x\tlog10(x)\tLogarithm of x in base 10\tmath" ],
     log2      => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1]+0 ? log($::STACK[-1])/log(2)  : ($Nprotect++, $PNAN{PICK_LOG2_INF}) },  "x\tlog2(x)\tLogarithm of x in base 2\tmath" ],
     exp10     => [ 1, sub { $::STACK[-1] = 10**$::STACK[-1] }, "x\t10^x\t10 to the power of x\tmath" ],
     sign      => [ 1, sub { $::STACK[-1] = $::STACK[-1] > 0 ? 1 : $::STACK[-1] < 0 ? -1 : 0 }, "x\tsign(x)\tThe sign of x (-1, 0 or 1)\tmath" ],
     neg       => [ 1, sub { $::STACK[-1] *= -1 }, "x\t-x\tThe sign-reversed value of x\tmath" ],
     ceil      => [ 1, sub { $::STACK[-1] = ceil($::STACK[-1]) }, "x\tceil(x)\tThe ceil of x\tmath" ],
     floor     => [ 1, sub { $::STACK[-1] = floor($::STACK[-1]) }, "x\tfloor(x)\tThe floor of x\tmath" ],
     round     => [ 1, sub { $::STACK[-1] = sprintf("%.0f", $::STACK[-1]) }, "x\tround(x)\tThe integer nearest to x\tmath" ],
     int       => [ 1, sub { $::STACK[-1] = int($::STACK[-1]) }, "x\tint(x)\tx truncated towards zero (do not use for rounding)\tmath" ],
     F0        => [ 0, sub { push @::STACK, $::Flink->[0] }, "-\tF[0]\tFirst input column\tdemo" ],

   );


sub sam_reflen {
  my $x = $::dict{seqlen}{$::Flink->[2]};
  if (!defined($x)) {
    $x = $::dictnotfound{seqlen};
    print STDERR "-- [$.] No length for $::Flink->[2]\n" if $L_verbose >= 2;
    $Nsam_lenmiss++;
  }
  return $x;
}


my %cp_samdefs = (
     refcov    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MDN=X', 'sum') }, "-\trefcov\tSpan of reference covered by alignment\tsam" ],
     refcovsplice    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MD=X', 'sum') }, "-\trefcov\tAmount of reference covered by alignment\tsam" ],
     refstart  => [ 0, sub { push @::STACK, $::Flink->[3] }, "-\trefstart\tField 4 from sam format\tsam" ],
     refend    => [ 0, sub { push @::STACK, $::Flink->[3] + acigar($::Flink->[5], 'MDN=X', 'sum') - 1 }, "-\trefend\tLast base in reference covered by alignment\tsam" ],
     reflen    => [ 0, sub { push @::STACK, &sam_reflen }, "-\treflen\tLength of reference sequence (requires samtools view -h)\tsam" ],

     alnmatch  => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'M=X', 'sum') }, "-\talnmatch\tAmount of reference/query matched by alignment (ignoring indels and mismatches)\tsam" ],
     alnedit   => [ 0, sub { my $nm = $::Flink->[11] =~ /\bNM:i:(\d+)/ ? $1 : 0; push @::STACK, $nm }, "-\talnedit\tEdit distance excluding clipping\tsam" ],
     alnmatchx => [ 0, sub { my $nm = $::Flink->[11] =~ /\bNM:i:(\d+)/ ? $1 : 0; push @::STACK, $nm - acigar($::Flink->[5], 'DI', 'sum') }, "-\talnmatchx\tNumber of base mismatches\tsam" ],
     alnposx   => [ 1, sub { $::STACK[-1] = &getalnposx($::STACK[-1]) }, "idsmn\talnposx\tMismatch positions; indel sequences reported up to length idsmn\tsam" ],
     _sam_rbt  => [ 0, sub { stacky('_sam_rbt', 2); &ref_bounded_tally($::STACK[-2], $::STACK[-1]); $#::STACK -= 2; }, "x y\t-\tPut read tallies in _rbt_[MIDNS] registers (region-bound-tally)\tEXPERIMENTAL/sam" ],

     aln_ref   => [ 0, sub { push @::STACK, &get_aln_strings(1) }, "-\taln_ref\talignment string for reference\tsam" ],
     aln_aln   => [ 0, sub { push @::STACK, &get_aln_strings(2) }, "-\taln_aln\talignment string between reference and query\tsam" ],
     aln_qry   => [ 0, sub { push @::STACK, &get_aln_strings(3) }, "-\taln_qry\talignment string for query\tsam" ],

     qrycov    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MI=X', 'sum') }, "-\tqrycov\tSpan of query covered by alignment\tsam" ],
     qrystart  => [ 0, sub { my $s = 1; $s += $1 if $::Flink->[5] =~ /^(\d+)[SH]/; push @::STACK, $s }, "-\tqrystart\tStart of alignment in query\tsam" ],
     qryend    => [ 0, sub { my $e = acigar($::Flink->[5], 'MISH=X', 'sum'); $e -= $1 if $::Flink->[5] =~ /(\d+)[SH]$/; push @::STACK, $e }, "-\tqryend\tLast base in query covered by alignment\tsam" ],
     qrylen    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MISH=X', 'sum') }, "-\tqrylen\tLength of query sequence\tsam" ],

     qry_trail5p  => [ 0, sub { push @::STACK, &get_qry_part(0); }, "-\tqry_trail5p\t5' unaligned query sequence in reference orientation\tsam" ],
     qry_matched  => [ 0, sub { push @::STACK, &get_qry_part(1); }, "-\tqry_matched\tmatched query sequence in reference orientation\tsam" ],
     qry_trail3p  => [ 0, sub { push @::STACK, &get_qry_part(2); }, "-\tqry_trail3p\t3' unaligned query sequence in reference orientation\tsam" ],
     qry_seq      => [ 0, sub { push @::STACK, &get_qry_part(-1);}, "-\tqry_seq\tquery sequence in reference orientation\tsam" ],

     refclipl  => [ 0, sub { push @::STACK, $::Flink->[3] -1 }, "-\trefclipl\tNumber of 5p trailing reference bases\tsam" ],
     refclipr  => [ 0, sub { push @::STACK, &sam_reflen - $::Flink->[3] + 1 - acigar($::Flink->[5], 'MDN=X', 'sum')}, "-\trefclipr\tNumber of 3p trailing reference bases\tsam" ],

     qryclipl  => [ 0, sub { my $n = 0; $n = $1 if $::Flink->[5] =~ /^(\d+)[SH]/; push @::STACK, $n }, "-\tqryclipl\tNumber of 5p trailing query bases\tsam" ],
     qryclipr  => [ 0, sub { my $n = 0; $n = $1 if $::Flink->[5] =~ /(\d+)[SH]$/; push @::STACK, $n }, "-\tqryclipr\tNumber of 3p trailing query bases\tsam" ]

            # TODO: deduplicate qrystart/clipl and qryend/clipr code. e.g. use acigar/linecache, keys L R?
   );

my %cp_sam_setup_seqs = map { ($_, 1) } qw(alnposx aln_ref aln_aln aln_qry qry_seq qry_trail3p qry_trail5p qry_matched _sam_rbt);

            # sub { } :
            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
            # For /ep/ and /om/ third argument is $::EPSILON/$::OOM or specified suffix.
            # 40 41 etc just to keep sort order when outputting list of select ops,
            # as '/' is overloaded in a slightly confusing way (negation and num op delimiter),
            # as is '~' (matching and string op delimiter). This keeps them grouped together.
            #
my %sel_opdefinitions = (
  '~'          => [ 40, sub { $_[0] =~ /$_[1]/ } ],
  '/~'         => [ 41, sub { $_[0] !~ /$_[1]/ } ],
  '='          => [ 42, sub { $_[0]  eq $_[1]  } ],
  '/='         => [ 43, sub { $_[0]  ne $_[1]  } ],

  '/eq/'       => [ 44, sub { $_[0] == $_[1] } ],
  '/ne/'       => [ 45, sub { $_[0] != $_[1] } ],
  '/lt/'       => [ 46, sub { $_[0] <  $_[1] } ],
  '/le/'       => [ 47, sub { $_[0] <= $_[1] } ],
  '/ge/'       => [ 48, sub { $_[0] >= $_[1] } ],
  '/gt/'       => [ 49, sub { $_[0] >  $_[1] } ],

  '/ep/'       => [ 50, sub { interval_plus(@_)} ],      # epsilon
  '/om/'       => [ 51, sub { interval_mul(@_) } ],      # order of magnitude

  '~eq~'       => [ 52, sub { $_[0] eq $_[1] } ],
  '~ne~'       => [ 53, sub { $_[0] ne $_[1] } ],
  '~lt~'       => [ 54, sub { $_[0] lt $_[1] } ],
  '~le~'       => [ 55, sub { $_[0] le $_[1] } ],
  '~ge~'       => [ 56, sub { $_[0] ge $_[1] } ],
  '~gt~'       => [ 57, sub { $_[0] gt $_[1] } ],

     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/'      => [ 58, sub { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) } ],
  '/any/'      => [ 59, sub { abs(int($_[0])) & abs(int($_[1])) } ],
  '/none/'     => [ 60, sub { ! (abs(int($_[0])) & abs(int($_[1]))) } ]

);


# Noteme: see /test_validate/ -- compile-time check for the opdefinition lookup below.
# TODO:
#    _set_ep _set_om operators to allow setting of band.
#        then recognise '\/(ep|om)\/', pass band straight to interval_mul interval_plus
#    compile time: conceivably could already ploink the code reference in place.

sub do_test {
   return $sel_opdefinitions{$_[2]}[1]->($_[0], $_[1]) ? 1 : 0;
}

sub do_ifelse {
  if (looks_like_number($_[0])) {
    return $_[0] != 0.0 ? $_[1] : $_[2];
  }
  else {
    return length($_[0]) ? $_[1] : $_[2];
  }
}


my $envsettings = join "\n", map { sprintf("  %-20s %8s", $_, $PNAN{$_}) } keys %PNAN;
my $opsections  = join ' ', sort keys %{{ map { ($_, 1) } map { split '/', (split "\t", $_->[2])[3] } values %cp_opdefinitions }};

my $regexpointers = <<EOP;
Useful perl regular expression features:
   Use \\K (keep) to anchor a pattern but retain it with ed, edg, del, delg
   :HANDLE^'patx\\Kpaty',delg will retain patx and only delete paty.
   Use patx(?=paty) to anchor patx to paty without including paty in the matched part.
   :HANDLE^'patx(?=paty)',get will just fetch patx.
   (?%3A...) groups a pattern without creating a backreference (%3A url-encodes ':')
   Use (?i)pat to make a pattern case insensitive.

Regular expression examples:
   - pick -i '.*'::__^'(%5E\\s+|\\s+\$)',delg        # remove trailing/leading whitespace in all cells
EOP


my $help_options=q{Options:
  -h do not print header
  -o OR multiple select criteria (default is AND)
  -x take complement of selected input column(s) (works with -i)
  -i in-place: <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -/<pat>  skip lines matching <pat>; use e.g. -/^# for commented lines, -/^@ for sam files
  -//<pat> pass through lines matching <pat>
     <pat> allows perl regular expressions, e.g. ^ $ . [] * ? (|) work.
  -v verbose

  -A print all input columns (selecting by colspec applies, -T accepted)
  -A<N> <N> integer; insert new columns at position <N>. Negative <N> is relative to rightmost column.
  -O<N> <N> integer; allow ragged input (e.g. SAM use -O12), merge all columns at/after position <N>
  -E<N> <N> integer; expect <N> rows returned, exit with error if this is not the case.
  -T do not select, print tally column of count of matched row select criteria (name T)
  -P protect against 'nan' and 'inf' results (see -H for environment variables PICK_*_INF)
  -Z as above, discard rows that need protecting

  -k headerless input, use 1 2 .. for input column names
     x-y for range from x to y
     a+x-y*k for range from a + k*x to a+y*k with incrementes of k
  -K headerless input, as above, use derived names to output column names
  -U with -k and -K keep output columns unique and in original order

  -R add _ column variable if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically
  -f force processing (allows both identical input and output column names)
  -F fixed names; do not interpret names as regular expressions.
     Default behaviour is to assume a regular expression if a name contains one of ^ $ [ \{ ( \ * ?
  -W (weird mode) header exists but use 1 2 .. for column names (selection not applied to header)
    1. consider using a=longcolumnname b=longercolumname; pick $a $b @$b/gt/0 @$a/lt/0 < data.txt
    2. consider using --inames=CSV (see below; this will change names in the output)

  -z  ARG+ print url-encoding of ARG+  (no argument prints a few especially useful cases)
  -zz ARG+ print url-decoding of ARG+
  -l or -l <string> list operators (matching section string if specified)
     to specify multiple sections use a comma-separated string.
     sections: } . $opsections . q{

  -H Longer pick description

  --inames=CSV       comma-separated values to use as column names instead of actual column names.
  --add-inames=CSV   The list must cover all columns in the input. Names that are used
                     in selection, compute and filter expressions must be picked from this list.
                     Output names are from the list. If using -k --inames=CSV provides temporary
                     handles; use --add-inames=CSV to add them to the output.

  --onames=CSV       Override output column names to be taken from comma-separated values.

  --fdict-NAME=fname fname should be two-column tab-separated file storing key and value per line.
                     This stores a dictionary called NAME that can be used to map values
                     with ...^NAME,map. Small dictionaries can be encoded on the command line with
  --cdict-NAME=<csv> where <csv> is a comma separated string of key:value pairs -- after splitting
                     on commas and colons all keys and values are url-decoded. Example:

       echo -e "a\t3\nb\t4" | pick -Aik --cdict-foo=a:Alpha,b:Beta 1::1^foo,map

  --table-dict-NAME=fname  Read table; Use ...^NAME^columnname,tmap for lookup.
  --fasta-dict-NAME=fname  Read fasta file; Sequences can be looked up with map.
  --fastq-dict-NAME=fname  Read fastq file; Sequences can be looked up with map.

  With all dictionary loading the part

     NAME=fname         can be augmented to
     NAME/<string>=fname

  If a key is not found with map or tmap then <string> will be used as the default value.

  --other=fname      write discarded rows to fname
  --demux=colname    use the value in colname as file name to write the row to.

  --version          version

  --pstore
  --pstore/<LIST>/<DEFAULT>
  --pstore/<LIST>/
  --pstore//<DEFAULT>
                     Cache/store previous row. Available to load with ^colname,pload. If <LIST>
                     (comma-separated, colon-separated key-value pairs) is specified it is used to
                     populate the named fields of the predecessor of the first row.  If <DEFAULT>
                     is specified it is used for all fields not named. Example (Fibonacci):

       yes | head | pick -k --pstore/x:1,y:0 x::^y,pload y::x^x,pload,add

                     Can be used to detect group boundaries in sorted data.

  --idx-list         Output list of selected indexes       ⦊ can be combined, pick will exit after.
  --name-list        Output list of selected column names  ⦊

  Short options combine, e.g. -ok/^@ for headerless input, comments indicated by ^@, OR selection.
  -AT is useful for inspecting/checking select criteria
  use -Ai <name>::<COMPUTE> to change column <name> to <COMPUTE>,
  use -Aik <num>::<COMPUTE> to change column <num> to <COMPUTE>.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (column name, index, or derived compute name)
  (2) @<HANDLE><op><VAL>       select criterion compare handle to constant value with <op>
  (3) @<HANDLE><op>:<HANDLE2>  select criterion compare handle to other handle with <op>
  (4) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output

  COMPUTE: <part>+ where <part> is one of ^<value> :<handle> ,<operator>
  Later computes have access to HANDLEs that were computed before.

  HANDLE, VAL and handles and values in COMPUTE are all URL-decoded.
  URL-encoding is generally necessary for characters in [%:^/,~]. Use pick -z <string>
  to find the url-encoding of <string> .};

my @opsf = sort { $sel_opdefinitions{$a}[0] <=> $sel_opdefinitions{$b}[0] } keys %sel_opdefinitions;
my $nameslist = "";

%::dict = ();
%::dictnotfound = ();

sub read_dict {
   my ($name, $fname, $mode) = @_;
   open(D, "gunzip -cf $fname|") || die "cannot open $fname for dictionary reading";
   my $n_novalue = 0;
   while(<D>) {
      chomp; my @F = split "\t";
      my $value = 1;
      if (@F >= 2 && $mode eq 'f') { $value = $F[1]; } else { $n_novalue++; }
      $::dict{$name}{$F[0]} = $value;
   } close(D);
   my $n = keys %{$::dict{$name}};
print STDERR "-- dictionary $name has $n keys after reading $fname\n" if $L_verbose >= 1;
print STDERR "-- dictionary $name has $n_novalue keys set to value 1\n" if $L_verbose >= 1 && $n_novalue;
}

sub read_tbdict {
   my ($name, $fname) = @_;
   open(D, "gunzip -cf $fname|") || die "cannot open $fname for dictionary reading";
   my $header=<D>; chomp $header; my @header = split "\t", $header; my %h = ();
   for (my $i=0; $i<@header; $i++) { $h{$i} = $header[$i] }
   while(<D>) {
      chomp; my @items = split "\t", $_, -1;                      # recognise empty fields (-1 split argument)
      die "Table read error" unless scalar @items == scalar @header;
      for (my $i=1; $i<@items; $i++) {
         $::dict{$name}{$h{$i}}{$items[0]} = $items[$i];
      }
   } close(D);
   my $n = keys %{$::dict{$name}};
   my $k = @header - 1;
print STDERR "-- table dictionary $name has $n keys for $k columns after reading $fname\n" if $L_verbose >= 1;
}

sub read_fadict {
   my ($name, $fname, $NF) = @_;
   open(D, "gunzip -cf $fname|") || die "cannot open $fname for dictionary reading";
   my ($id, $seq) = (undef, "");
   while(<D>) {
      if (/^>(\S+)/) { $::dict{$name}{$id} = $seq if defined($id); ($id, $seq) = ($1, ""); }
      else           { chomp; $seq .= $_; }
   } close(D);
   $::dict{$name}{$id} = $seq if defined($id);
   $::dict{$name}{'*'} = "";      # noteme: (1) SAM format unmapped reads have ref '*' (2) pick uses '' in other fail scenarios, but the entirety needs design/documenting.
   my $n = keys %{$::dict{$name}};
   $::dictnotfound{$name} = $NF;
print STDERR "-- sequence dictionary $name has $n keys after reading $fname\n" if $L_verbose >= 1;
   if (length($sam_refdictname)) {
     print STDERR "WARNING --- multiple fasta dictionaries, I'm using $sam_refdictname for SAM reference lookups ---\n";
   }
   else {
      $sam_refdictname = $name;                    # experimental/fragile
      print STDERR "-- Sequences for SAM reference lookup loaded from $fname in dictionary $sam_refdictname\n" if $L_verbose >= 0;
   }
}

sub read_fqdict {
   my ($name, $fname) = @_;
   open(D, "gunzip -cf $fname|") || die "cannot open $fname for dictionary reading";
   my $id = undef;
   while(<D>) {
      if ($. % 4 == 1)       { die "Fastq read error on line %." unless /^@(\S+)/; $id = $1; }
      elsif ($. % 4 == 2)    { chomp; $::dict{$name}{$id} = $_; }
   } close(D);
   my $n = keys %{$::dict{$name}};
print STDERR "-- sequence dictionary $name has $n keys after reading $fname\n" if $L_verbose >= 1;
}

{  my %fh_demux = ();
   sub demux_do_row {
      my ($name, $output, $do_print) = @_;
      my $val = $fh_demux{$name};
      if (!defined($val)) {
         my $fh = new IO::File;
         my $openstring = $name =~ /\.gz(ip)?$/ ? "|gzip >$name" : ">$name";
         $fh->open("$openstring") || die "Failed to open $name";
            # fixme todo; if this fails because of too many open file handles then
            # close the least used file handles or not recently used and retry.
         $val = [$fh, 0, 0];
         $fh_demux{$name} = $val;
         if ($B_print_header) {
            print $fh (join "\t", @::OUTPUT_HEADER) . "\n";
         }
      }
      if ($do_print) {
         print {$val->[0]} $output;
         $val->[1]++;
      }
      else {
         $val->[2]++;
      }
   }
   sub demux_tally {
      print STDERR "File\tWritten\tFiltered\n";
      for (sort { $a cmp $b } keys %fh_demux) {
         print STDERR "$_\t$fh_demux{$_}[1]\t$fh_demux{$_}[2]\n";
         $fh_demux{$_}[0]->close() || print STDERR "-- issue closing file handle for $_\n";
      }
   }
}

sub parse_range {
  my $spec = shift;
  @::colindexes = ();
  if ($spec =~ /^(\d+)$/) {
    @::colindexes = ($1);
    return 1;
  }
  elsif ($spec =~ /^((\d+)\+)?(\d+)-(\d+)?(\*(\d+))?$/) {
    my ($offset, $start, $end, $multiply) = ($2, $3, $4, $6);
    $offset   = 0 unless defined($offset);
    $multiply = 1 unless defined($multiply);
    $end      = $::N unless defined($end);
    @::colindexes = grep { $_ >= 1 && $_ <= $::N } map { $offset + $_ * $multiply } $start..$end;
    if (@::colindexes < $end - $start + 1) {
print STDERR "-- range expansion produced some indexes out of range (now dropped)\n";
    }
    return 1;   # even if the spec resulted in empty selection.
  }
  return 0;
}

sub parse_dict {
   my ($name, $string) = @_;
   for my $pair (split ",", $string) {
      my ($k, $v) = map { urldecode($_) } split ':', $pair, -1;        # @urldecode --cdict-NAME=
      if (!defined($v)) {
         print STDERR "-- Setting value for $k to 1\n" if $L_verbose >= 2;
         $v = 1;
      }
      $::dict{$name}{$k} = $v;
   }
   my $n = keys %{$::dict{$name}};
print STDERR "-- dictionary $name has $n keys after parsing string\n" if $L_verbose >= 1;
}

sub dict_not_found {
   my ($d, $val) = @_;
   my $NF = $::dictnotfound{$d};
   return $val unless defined($NF);
   die "Lookup for $val in dictionary $d failed" if $NF eq '__EXIT__';
   return $NF;
}

while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;

  if ($options =~ /^\-(z+)$/) {
    local $, = ' ';
    print map { length($1) % 2 == 1 ? urlencode($_) : urldecode($_) } @::spec;
    if (@::spec) { print "\n"; }
    else { print STDERR <<EOH;
-- I url-encode (-z) or decode (-zz) any arguments. Useful cases:
  ^   %5E     ;   %3B     (  %28     <TAB>      %09
  :   %3A     !   %21     )  %29     <NEWLINE>  %0A
  ,   %2C     /   %2F     <  %3C     <CR>       %0D     @   %40
  %   %25     \\   %5C     >  %3E     <SPACE>    %20     =   %3D
For shell meta-characters it is easiest to just quote the argument to pick.
EOH
    }
    exit 0;
  }
  elsif ($options eq '-l') {
    my $filter = @::spec ? $::spec[0] : '.';
    $filter =~ s/,/|/g;
    print "\nSelect comparison operators:\n  @opsf\n\n";
    exit 0 if $filter eq 'selection';
    printf "%-12s%-12s%-20s%s\n", 'Operator', 'Consumed', 'Produced', 'Description';
    print  '-' x 80 . "\n";
    for my $op (sort keys %cp_opdefinitions) {
      my $opdef = $cp_opdefinitions{$op};
      my @help = split "\t", $opdef->[2];
      die "Error in description @help\n" unless @help == 4;
      next unless $help[3] =~ $filter || $filter =~ /$help[3]/;
      printf "%-12s%-12s%-20s%s [%s]\n", $op, @help;
    }
    if ($filter eq 'regex') {
      print "\n$regexpointers";
    }
    if ($filter eq '.') { print "\nUse -l <query> to limit output to sections matching <query>, e.g pick -l string\nSections: $opsections\n" }
    else { print "\nAll operators in section(s) matching <$filter>\nSections: $opsections\n" }
    exit 0;
  }
  elsif ($options eq '-H') {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
  See further below for <op> list.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a select criterion comparing a handle to a constant value.
Form (3) creates a select criterion comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op><VAL>
@<COLNAME><op>:<COLNAME>  select rows based on <VAL> or value in column <COLNAME>.

<op> is one of the following:
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/<what>
  /ep/<what>/epsilon  Column value lies in [ <what> - epsilon, <what> + epsilon ] (default $::EPSILON)
  /om/<what>
  /om/<what>/oom      |Column value| lies in [ |<what>| / oom, |<what>| * oom ] (default $::OOM)
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> and <handle> will be url-decoded. In particular, if you
  need one of [%^:,/~] in <string> it is best to url-encode it with 25, 5E, 3A,
  2C, 2F, 7E respectively; use pick -z <string> to find its URL-encoded form.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).

  If the very first part starts with anything other than [,:^] it is inferred
  to be a handle (leading : not needed).  <COMPUTE> is a stack, so
  zut::foo:bar,add^str,cat creates a new column called zut by adding columns
  foo and bar and then concatenating 'str'. The default operation is
  concatenation; if no operators are left the remainder of the stack is
  concatenated. Thus the above is equivalent to zut::foo:bar,add^str. To just
  prefix a column: zut::^foo:zut To concatenate two columns: zut::foo:bar .
  Use -l to see the description of operators.

Environment variables with default settings:
$envsettings

$regexpointers
EOH
  exit 0;
  }

  elsif ($options =~ s/^--//) {
     if ($options =~ /^(k|f|fastq-|fasta-|table-)dict-(\w+)(\/(.*?))?=(.+)$/) {
       read_dict($2, $5, $1) if $1 eq 'f' || $1 eq 'k';
       read_fadict($2, $5, length($3) ? $4 : '__EXIT__') if $1 eq 'fasta-';
       read_fqdict($2, $5) if $1 eq 'fastq-';
       read_tbdict($2, $5) if $1 eq 'table-';
       $::dictnotfound{$2} = $4 if length($3);        # for read_fadict this happens twice. tidy up sometime.
     }
     elsif ($options =~ /^cdict-(\w+)(\/(.*?))?=(.+)$/) {
       parse_dict($1, $4);
       $::dictnotfound{$1} = $3 if length($2);
     }
     elsif ($options =~ /^(add-)?inames=(.+)$/) {
       $nameslist=$2;
       $B_add_names = $1 ? 1 : 0;
     }
     elsif ($options =~ /^(idx|name)-list$/) {
       $F_list |= $1 eq 'idx' ? 1 : 2;
     }
     elsif ($options =~ /^pstore(\/(.*?))?(\/(.*?))?$/) {
       $B_pstore = 1;
       $PSTORE_LIST = $2 if defined($1);
       $PSTORE_DEFAULT = $4 if defined($3);
     }
     elsif ($options =~ /^group(-(first-ref|all))?=(\S+)$/) {
       $B_pstore = 1;
       $PSTORE_PIVOT_HANDLE = $3;
       if (defined($1)) {
          if ($2 eq 'first-ref') { $B_groupfirst = 1; }
          else             { die "--group-all not available currently"; }
       }
     }
     elsif ($options eq 'version') {
       print "pick version: $v_v_v\n";
       exit 0;
     }
     elsif ($options =~ /^onames=(.+)$/) {
       $nameslist=$1;
       $B_posthoc_names = 1;
     }
     elsif ($options =~ /^inf=(\S+)/) {
       $PNAN{PICK_DIV_INF} = $1;
     }
     elsif ($options =~ /^demux=(\S+)/) {
       $name_demux = $1;
     }
     elsif ($options =~ /^other=(\S+)/) {
       my $fn = $1;
       $fh_other = new IO::File;
       my $openstring = ($fn =~ /\.gz(ip)?$/) ? "|gzip >$fn" : ">$fn";
       $fh_other->open("$openstring") || die "Cannot open $fn";
     }
     elsif ($options eq 'remind-me' || $options eq 'rmm')  {
       if (!@::spec) {
         print "Available reminders: sam\n"; exit 0;
       }
       if ($::spec[0] eq 'sam') {
       print <<EOH;
   1     2     3     4     5     6     7     8     9    10    11
 QNAME FLAG  RNAME  POS  MAPQ  CIGAR  RNEXT PNEXT TLEN SEQ   QUAL
EOH
       exit 0;
       }
     }
                           # see /sam_activate/ for compile-time activation sam_setup_aln_sequences
     elsif ($options =~ /^sam(-h)?(\/(\S+))?$/) {
        if (defined($1)) { $F_ignore |= 5; $PAT_PASS  = '^@'; }
        else             { $F_ignore |= 6; $PAT_PURGE = '^@'; }
        if (defined($2)) {
          my $fname = $3;
          read_fadict('SAMFA', $fname, '__EXIT__');
        }
        $B_headless = 1;
        $OFFSET_OMEGA = 12;
        $::dictnotfound{seqlen} = 0;
        $::dict{seqlen} = {};                # noteme; if --fdict-seqlen=FILE --sam then fdict is thrown away.
        $I_AM_SAM |= 5;                      # 1: i-am-sam. 4: check sequence lengths between sam header and fasta.
        for (keys %cp_samdefs) { $cp_opdefinitions{$_} = $cp_samdefs{$_}; }
     }
     else {
       die "Unrecognised long option --$options";
     }
     next;
  }

  if ($options =~ s/\/\/(.*)$//)    { $F_ignore |= 1; $PAT_PASS  = urldecode($1); }       # @urldecode -//PAT
  if ($options =~ s/\/([^\/].*)$//) { $F_ignore |= 2; $PAT_PURGE = urldecode($1); }       # @urldecode -/PAT

  if ($options =~ s/O(\d+)//) {
     $OFFSET_OMEGA = $1 + 0;
     die "-O<N> N must be positive\n" unless $OFFSET_OMEGA > 0;
  }

  if ($options =~ s/E(\d+)//) {
     $N_expect = $1 + 0;
     die "-E<N> N must be nonnegative\n" unless $N_expect >= 0;
  }

  if ($options =~ s/A(-?\d+)?//) {
     $B_printall     = 1;
     if (defined($1)) {
        $INSERT_OFFSET = $1 + 0;
     }
  }

  $B_print_header = 0 if $options =~ s/h//;
  $B_regex        = 0 if $options =~ s/F//;
  $B_protect      = 1 if $options =~ s/P//;
  ($B_protect, $B_protect_discard) = (1,1) if $options =~ s/Z//;
  $B_select_and   = 0 if $options =~ s/o//;
  $L_verbose += length($1)  if $options =~ s/(v+)//;
  $L_verbose -= length($1)  if $options =~ s/(q+)//;
  $B_ko           = 1 if $options =~ s/U//;
  $B_excise       = 1 if $options =~ s/x//;
  $B_add_row_column =1 if $options =~ s/R//;
  $B_headless     = 1 if $options =~ s/k//;
  ($B_headless, $B_sprouthead)= (1, 1) if $options =~ s/K//;
  ($B_headless, $B_weirdmode) = (1, 1) if $options =~ s/W//;
  $B_debug        = 1 if $options =~ s/d//;
  $B_force        = 1 if $options =~ s/f//;
  $B_inplace      = 1 if $options =~ s/i//;
  ($B_count, $B_print_header) = (1, 0) if $options =~ s/c//;

  if ($options ne '-') {
    print STDERR "Option string not fully parsed: $options remains\n";
    exit 1;
  }
}

die "-O<N> requires -k\n" if $OFFSET_OMEGA > 0 && !$B_headless;

$B_print_header = 0 if $B_headless;
$B_print_header = 1 if $B_add_names || $B_posthoc_names || $B_sprouthead;

@::nameslist = $nameslist ? split ',', $nameslist : ();

helphelp(1) unless @::spec || $B_printall || $B_excise || $B_force || $B_count || $F_list;

sub interval_plus {
  my ($x, $y, $val) = @_;
  my $epsilon = $val ? $val : $::EPSILON;
  return $x <= $y + $epsilon && $x >= $y - $epsilon;
}

sub interval_mul {
  my ($x, $y, $val) = @_;
  my $oom = $val ? $val : $::OOM;
  return abs($x) <= abs($y) * $oom && abs($x) >= abs($y) / $oom;
}


my $TYPE_SCALAR = 1;
my $TYPE_HANDLE = 2;
my $TYPE_OPATOR = 3;    # (1) rule of six obvs, (2) it makes sense in Dutch.

my %chartypetonum = ( '^', $TYPE_SCALAR, ':', $TYPE_HANDLE, ',', $TYPE_OPATOR );

sub parse_compute {
  my ($handle, $spec) = @_;
  my @oplist = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[,^:]/;
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]*)/g) {
    my ($type, $what) = ($chartypetonum{$1}, $2);
    $what = urldecode($what) if $type == $TYPE_SCALAR || $type == $TYPE_HANDLE;     # @urldecode ^const :handle
    push @oplist, [$type, $what];
    $p = pos($spec);
    if ($type == $TYPE_OPATOR) {
      my $opdef = $cp_opdefinitions{$what};
      die "[$what] is not an operator I know" unless defined($opdef);
                                             # /pload_validate/
      if ($what eq 'pload') {
         die "Operator 'pload' requires option --pstore (or --group)" unless $B_pstore;
         die "Operator 'pload' requires operand" unless @oplist > 1;
         die "Operator 'pload' requires operand that is a column name scalar, e.g. ^2 or ^colname"
            unless $oplist[-2][0] == $TYPE_SCALAR;
         $::pstore_init{$oplist[-2][1]} = $PSTORE_DEFAULT;
      }
                                             # /sam_activate/
      elsif (defined($cp_sam_setup_seqs{$what})) {
         $I_AM_SAM |= 2;
      }
      elsif ($what eq 'test') {              # /test_validate/
         die "Operator 'test' requires three operands" unless @oplist > 3;
         die "Operator 'test' requires third operand to be a known test (you supplied $oplist[-2][1])"
            unless $oplist[-2][0] == $TYPE_SCALAR && defined($sel_opdefinitions{$oplist[-2][1]});
      }
                           # N stack required, code.
      push @{$oplist[-1]}, ($opdef->[0], $opdef->[1]);
print STDERR "-- $handle >> type=$type op=$what N=$opdef->[0], code=$what:$opdef->[1]\n" if $B_debug;
    }
    else {
print STDERR "-- $type $what >>\n" if $B_debug;
    }
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oplist;
}

sub urlencode {
   my $val = shift;
   $val =~ s/([^A-Za-z0-9_])/ uc sprintf "%%%0x", ord $1 /eg;
   return $val;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


sub acigar {

   my ($cigar, $subset, $mode) = @_;
   my $key = "cigar::$cigar";
   my @subset = split "", $subset;

   if (!defined($::LINECACHE{$key})) {
      my $c = $::LINECACHE{$key} =
        { sum   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , max   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , count => { map { ($_, 0)  } split "", 'MINDSHP=X' } };
      my $p = 0; my $n = 0;
      while ($cigar =~ m/(\d+)([MINDSHP=X])/ig) {
        my ($num, $it) = ($1, $2);
        $n += length($&);
        $c->{sum}{$it} += $num;
        $c->{count}{$it}++;
        $c->{max}{$it} = $num if $num > $c->{max}{$it};
        $p = pos($cigar);
      }
print STDERR "-- Unmatched part in cigar string $cigar at $p (line $.)\n" unless $p == length($cigar) && $n == length($cigar);
   }
   my $cache = $::LINECACHE{$key};
   if ($mode eq 'max')      { my $max = 0; for my $x (@subset) { $max = $cache->{max}{$x} if $cache->{max}{$x} > $max }; return $max }
   elsif ($mode eq 'sum')   { my $sum = 0; $sum += $cache->{sum}{$_} for @subset; return $sum }
   elsif ($mode eq 'count') { my $count = 0; $count += $cache->{count}{$_} for @subset; return $count }
   else                     { return 'NA' }
}

   ## Returns an arrary of matches; each match is an array [name1, name2].
   ## name1 is the existing name (found in header), name2 is the new name, normally the same.
   ## New names can be made by the prefix/suffix convention as well as using regex parentheses ().
   ##
sub expand_list_range_and_regex {
   my ($spec, $has_compute) = @_;
   my @matches = ();
   my ($suffix, $prefix, $duplicate) = ("", "", 0);
   if ($has_compute) {             # in this case accept p/spec/s syntax for column renaming and p/spec//s for duplicating
      $duplicate = $spec =~ /\/\// ? 1 : 0;
      my @parts = split /\/+/, $spec, -1;
      if (@parts > 3) { die "Handle has more than three /-separated parts"; }
      elsif (@parts == 3) { ($prefix, $spec, $suffix) = @parts; }
      elsif (@parts == 2) {   # to specify just prefix, one needs p/spec/
        ($spec, $suffix) = @parts;
        if ($suffix =~ /[:$REGEXP_CHARS]/) {       # ':' is there as we split on that.
print STDERR "Suffix [$suffix] contains regex/list characters, did you mean '$spec/$suffix/'?\n";
        }
      }
   }

   for my $item ($spec eq '' ? ("") : split ':', $spec, -1) {
print STDERR "-- (output) considering $item\n" if $L_verbose >= 2;
      if ($B_headless && parse_range($item)) {
         push @matches, map { { namein => $_, nameout => $_ } } @::colindexes;        #  global for the win.
      }
      elsif ($item =~ /[$REGEXP_CHARS]/ && $B_regex) {
         my $nfound = 0;
         for my $name (@::HEADER[0..($::N-1)]) {
            if ($name =~ qr/$item/) {
               push @matches, { namein => $name, nameout => defined($1) ? $1 : $name };
               $nfound++;
            }
         }
print STDERR "-- (output) $item was considered as regex and yielded no matches\n" unless $nfound;
      }
      else {
         push @matches, { namein => $item, nameout => $item };
      }
   }
   my $n_matches = @matches; local $" = ' ';
   for (@matches) {
      $_->{nameout} = "$prefix$_->{nameout}$suffix";
   }
   my @matchnames = map { $_->{namein} } @matches;
print STDERR "-- (output) item $spec ($n_matches results: @matchnames)\n" if $L_verbose >= 2 || (!$n_matches && $spec);

   return ($duplicate, \@matches);
}

sub compile_time {

  if ($::HEADER[0] eq '')   { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_'; }

  $::N = @::HEADER;
  my %inheader = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name}) && !$B_force;
    $::handle_map{$name} = $i;
print STDERR "-- map header name $name to offset $i\n" if $B_debug;
  }

  for my $spec (@::spec) {
    if ($spec =~ /^@/) {
      my ($handle, $op, $val, $arg) = (undef, undef, undef, undef);
                    #  = ~ /= /~
      if ($spec =~ /^@(.*?)(\/?[=~])(.*?)$/) {
        ($handle, $op, $val) = (urldecode($1), $2, urldecode($3));      # @urldecode @handle/../arg|handle/arg
      }
                    #  H handle
                    #  a1a2a3, b, c, d different forms for op
                    #  V value or :handle
                    #    ( H )([ a1](      a2    )[ a3])( V)(  arg )
      elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~])(.*?)(\/.*?)?$/) {
        ($handle, $op, $val, $arg) = (urldecode($1), $2, urldecode($3), $4);      # @urldecode @handle/../arg|handle/arg
      }
      else {
         print STDERR "-- Selection invalid [$_]. I need @<name><op><:name|value>, see pick -l selection for <op>\n";
         exit 1;
      }
      die "Unrecognised operator [$op]\n" unless defined($sel_opdefinitions{$op});
      if (defined($arg)) {
        die "Extra argument currently only allowed for /ep/ and /om/" unless $op =~ /^\/(ep|om)\/$/;
        $arg =~ s|^\/||;
        $arg=urldecode($arg);
      }
      else{
         $arg = 0;
      }
print STDERR "-- adding select criterion handle=[$handle] op=[$op] val=[$val] arg=[$arg]\n" if $B_debug;
      my $indirection = $val =~ s/^:// ? 1 : 0;
      push @::select, [$op, $indirection, $val, $handle, $arg];
               # NOTE. $arg for now only used by /ep/ and /om/ selection, ignored by the others.
    }
    elsif ($spec =~ /^(.*?)(:[:=])(.*)/) {
      my ($handle, $type, $compute) = (urldecode($1), $2, $3);    # @urldecode handle::
      die "Compute cannot be empty\n" unless length($compute);
      $handle = $DUMMY_NAME++ if $handle eq '';
      my ($duplicate, $matches) = expand_list_range_and_regex($handle, 1);
      $compute = ":$compute" unless $compute =~ /^[,:^]/;
      for my $m (@$matches) {
        my $compute_m = $compute; $compute_m =~ s/:__\b/:$m->{namein}/g;
        my $parsed_compute = parse_compute($handle, $compute_m);
        push @::compute, [$m->{nameout}, $parsed_compute];
        push @::output_nm, $m->{namein} if $duplicate;            # fixme consider // duplicate combined with := assignment
        push @::output_nm, $m->{nameout} if $type eq '::';        # ':=' is assignment without output.
      }
    }
    elsif ($B_headless && parse_range($spec)) {
      push @::output_nm, @::colindexes;
    }
    else {
      $spec = urldecode($spec);                                               # @urldecode selection/regex-selection
      my ($unused_variable, $matches) = expand_list_range_and_regex($spec, 0);
      for my $m (@$matches) { push @::output_nm, $m->{namein}; }
    }
  }

  @::output_nm = sort { $a <=> $b } keys %{{ map { ($_, 1) } @::output_nm }} if $B_ko;

  $::plain_handle{$_} = 1 for @::output_nm;           # handles without compute
                                                      # but ::spec case pushes onto @::output_nm -- fixme/docme

local $" = ',';
print STDERR "-- output column names as specified: [@::output_nm]\n" if $B_debug;
  if ($B_excise || $B_printall) {
    my @new_names = grep { !defined($inheader{$_}) } @::output_nm;
    if ($B_excise) {
       @::output_nm = grep { !defined($::plain_handle{$_}) } @::HEADER
    }
    else {
       @::output_nm = @::HEADER;
    }
    if (defined($INSERT_OFFSET)) {
      $INSERT_OFFSET = @::output_nm if $INSERT_OFFSET > @::output_nm;
      $INSERT_OFFSET = -1 * @::output_nm if $INSERT_OFFSET < -1 * @::output_nm;
      splice @::output_nm, $INSERT_OFFSET, 0, @new_names;
    }
    else {
       push @::output_nm, @new_names;
    }
  }
print STDERR "-- output column names after -i/-A treatment: @::output_nm\n" if $B_debug && ($B_excise || $B_printall);

  { my %names = (); my $i = 1;
    for (@::output_nm) { $names{$_} = $i++ unless defined($names{$_}) }
    if (keys %names < @::output_nm) {
       my $job = $B_force ? 'leaving as specified' : 'will make unique';
print STDERR "-- Identical output column names exist ($job)\n";
       @::output_nm = sort { $names{$a} <=> $names{$b} } keys %names unless $B_force;
    }
  }

  #
  ##  Add derived column names to @::HEADER
  ##  Expand regex specifications if found.
  ##  In derived column specs replace names by offsets into field array.
  #

  my %pload_references = ();

  for (my $i=0; $i<@::compute; $i++) {
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name already defined (use -i for in-place change)\n" if defined($::handle_map{$name}) && !$B_inplace;
    my @expanded_compute = ();
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         my ($unused_variable, $matches) = expand_list_range_and_regex($what, 0);
         for my $m (@$matches) { push @expanded_compute, [$TYPE_HANDLE, $m->{namein}]; }
      }
      else {
         push @expanded_compute, $comp;
      }
    }
    my $prev_what = undef; # ugly/fixme; temporary to enforce pload compile-time check for column name presence.

    for my $comp (@expanded_compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         die "Handle [$what] in compute $name does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};     # fixme overwrite inelegant
                              # inplace NOTE. when using foo::foo^1,add, this maps the lookup for the second foo to the offset
                              # for the current foo, and the second foo no longer exists. The first foo does not have an
                              # associated offset yet;
      }
      if ($type == $TYPE_OPATOR && $what eq 'pload') {
         $pload_references{$prev_what}++;
      }
      $prev_what = $what;
    }
    $::compute[$i] = [$name, \@expanded_compute];

    my $j = $::N + $i;
    $::HEADER[$j] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $j;
                              # inplace NOTE continued. Future lookups for foo will refer to this definition; This includes output.
                              # This process is consistently applied if multiple foo:: are specified.
print STDERR "-- map compute name [$name] to offset $j\n" if $B_debug;
  }

  my @pload_notfound = grep { !defined($::handle_map{$_}) } keys %pload_references;
  die "'pload' argument(s) @pload_notfound not among the column names I know" if @pload_notfound;

  if (defined($PSTORE_PIVOT_HANDLE)) {
     $PSTORE_PIVOT_COLUMN = $::handle_map{$PSTORE_PIVOT_HANDLE};
     die "--group argument $PSTORE_PIVOT_HANDLE not among the column names I know" unless defined($PSTORE_PIVOT_COLUMN);
  }

  if (defined($name_demux)) {
     $index_demux = $::handle_map{$name_demux};
     die "Demux column $name_demux not found" unless defined($index_demux);
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle [$name] in output does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "-- output columns @::output_os --\n" if $B_debug;

  #
  ##  In select list replace names by offsets into field array.
  #

  for my $sel (@::select) {

    my ($op, $indirection, $val, $name, $arg) = @$sel;

    die "Handle [$name] in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});

    my $opdef = $sel_opdefinitions{$op};
    die "The impossible happened ($op)\n" unless defined($opdef);
    $sel->[0] = $opdef->[1];             # fixme overwrite inelegant

    $sel->[3] = $::handle_map{$name};    # fixme overwrite inelegant
    if ($indirection) {
       die "Handle [$val] in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$val});
       $sel->[2] = $::handle_map{$val};  # fixme overwrite inelegant
    }
    { my ($code, $indirection, $val, $name, $arg) = @$sel;
print STDERR "-- select code=$code ind=$indirection val=$val name=$name arg=$arg --\n" if $B_debug; }

  }

  for (@::HEADER) {
    $_ = '' if $_ eq '_';
  }

  if ($B_pstore) {
     for my $pair (split ",", $PSTORE_LIST) {                  # Note empty string yields empty list with split.
        my ($k, $v) = map { urldecode($_) } split ':', $pair, -1;
        die "Name $k is not a known column handle with --pstore" unless defined($::handle_map{$k});
        die "Column $k was not supplied with a value" unless defined($v);
        $::pstore_init{$k} = $v;
     }
     for (keys %::pstore_init) { $::pstore_init{$_} = $PSTORE_DEFAULT unless defined($::pstore_init{$_}); }
     %::pstore_cache = %::pstore_init;
  }
}


sub do_compute {

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    @::STACK = ();

    for my $comp (@$compute) {

      my ($type, $what, @other) = @$comp;

         if ($type == $TYPE_HANDLE) { push @::STACK, $::Flink->[$what]; }
      elsif ($type == $TYPE_SCALAR) { push @::STACK, $what; }
      elsif ($type != $TYPE_OPATOR) { die "Really unfortunate!\n"; }

      else {
         my ($n_wanted, $code) = @other;
         die "Stack underflow ($spic->[0] item [$what])\n" unless @::STACK >= $n_wanted;
         &{$code};
         $n_wanted--;
         $#::STACK -= $n_wanted if $n_wanted > 0;    # subs put computed element in the right place.
      }
    }
    push @$::Flink, (join "", @::STACK);
  }
  die "Cp error\n" unless @::HEADER == @$::Flink;
}


sub do_cache {

  my $skip = 0;

  if (defined($PSTORE_PIVOT_COLUMN)) {
    if (!defined($PSTORE_PIVOT_VALUE) || $PSTORE_PIVOT_VALUE ne $::Flink->[$PSTORE_PIVOT_COLUMN]) {
      $PSTORE_PIVOT_VALUE = $::Flink->[$PSTORE_PIVOT_COLUMN];
      $::Ngroup++;
      $::Groupi = 2;
      $skip = 1;
    }
    else {
      $::Groupi++;
      return 0 if $B_groupfirst;     # cache is still valid, not a new group
    }
  }
  for (keys %::pstore_cache) { $::pstore_cache{$_} = $::Flink->[$::handle_map{$_}]; }
  return $skip;
}


 $::Nrows = 0;    # includes header.
$::Ngroup = 0;    # skipped because first in group: --group
my $Nskip = 0;    # skipped based on pattern; e.g. pick -/^#
my $Npthr = 0;    # skipped and passed through
my $Ndisc = 0;    # skipped because @ criteria not met
my $Nkeep = 0;

$::Groupi = 2;    # index within group.


{ my @sam_cache = ("no-readname", "no-refname", -1, '');       # Read name, refname, strand, read sequence
                                   # ^ fixme: more maintainable to stick this in LINECACHE.
  my @sam_cache_prev = ();         # arrays rather than hash, a bit faster.
  my $sam_ref_sequence = '';

  sub sam_setup_reflendict {
    if (length($sam_refdictname)) {
      print STDERR "-- Comparing fasta sequence lengths with header information if present\n";
      my $nheader = keys %{$::dict{seqlen}};
      my $nfasta  = (keys %{$::dict{$sam_refdictname}}) - 1;        # '*' has been added by pick, compensate for this.
      my $nshared = 0;
      for my $r (sort keys %{$::dict{$sam_refdictname}}) {
        my $lfasta = length($::dict{$sam_refdictname}{$r});
        if (!defined($::dict{seqlen}{$r})) {
           print STDERR "-- [$.] setting sequence length for $r to $lfasta\n" if $L_verbose >= 2;
           $::dict{seqlen}{$r} = $lfasta;
        }
        else {
          $nshared++;
          if ((my $lsamh = $::dict{seqlen}{$r}) != $lfasta) {
            print STDERR "-- [$.] WARNING header/fasta length disagreement $lsamh/$lfasta -- picking header/$lsamh\n";
            $Nsam_lenclash++;
          }
        }
      }
      print STDERR "-- Header/Fasta/Shared/Conflict $nheader/$nfasta/$nshared/$Nsam_lenclash\n";
    }
    $I_AM_SAM ^= 4;     # noteme / dangersign. This unsets the bit; we are only called if the bit is set.
  }

                        # fixme do not attempt to lookup '*' reference (unmapped query),
                        # improve structure.
  sub sam_setup_aln_sequences {
    @sam_cache_prev = @sam_cache[0..3];              # no danger of using 4..6, but still.
    @sam_cache = ($::Flink->[0], $::Flink->[2], $::Flink->[1] & 16 ? 1 : 0, $::Flink->[9]);
                                                     # checkme strandcheck: not sure if this strand flipping works.
    if ($sam_cache[3] eq '*') {
      if ($sam_cache[0] eq $sam_cache_prev[0]) {     # same read name.
        $sam_cache[3] = $sam_cache[2] != $sam_cache_prev[2] ? rc($sam_cache_prev[3]) : $sam_cache_prev[3];
      }
      else {
        $sam_cache[3] = '';
      }
    }
    {  $sam_ref_sequence = $sam_refdictname ? ($::dict{$sam_refdictname}{$sam_cache[1]} || dict_not_found($sam_refdictname, $sam_cache[1])) : '';
       my $pair = "$sam_cache[0] $sam_cache[1]";
       if (!$sam_ref_sequence) {
         print STDERR "-- [$.] No reference sequence for $pair\n" if $L_verbose >= 2;
         $Nsam_refmiss++;
       }
       if (!$sam_cache[3]) {
         print STDERR "-- [$.] No query sequence for $pair\n" if $L_verbose >= 2;
         $Nsam_qrymiss++;
       }
       elsif ($::Flink->[5] eq '*') {  # and/or [2] eq '*' and/or [1] & 4 ..
         $Nsam_qryunmapped++;
         $sam_ref_sequence = '';       # .. fixme check whether this catches all cases, or how to arrange it so that
                                       # a single check catches all cases and the implementation logic is clear.
       }
       elsif ((my $l1 = length($sam_cache[3])) != (my $l2 = acigar($::Flink->[5], 'MIS=X', 'sum'))) {
         print STDERR "-- [$.] Cigar string mismatch $l1 / $l2 for $pair\n" if $L_verbose >= 2;
         $sam_ref_sequence = '';    # this will abort analysis in align_get_mismatch
         $Nsam_cigarerr++;
       }
    }
  }

  sub align_get_matchregion {
    my ($sref, $sqry, $posref) = @_;
    my $aln= "";
    my $ls = length($sref);
    my $lt = length($sqry);
    return "" unless $ls == $lt;

    my $pos = $ls;
  
    while ($pos--) {
      my $sbase = chop $sref; my $tbase = chop $sqry;
      my $p = $posref + $pos + 1;
      $aln .= ($sbase eq $tbase) ? '|' : 'x';
    }
    return reverse($aln);
  }

  sub align_get_mismatch {
    my ($sref, $sqry, $posref) = @_;
    my @mm = ();
    my $ls = length($sref);
    my $lt = length($sqry);
    return -1 unless $ls == $lt;

    my $pos = $ls;
    while ($pos--) {
      my $sbase = chop $sref; my $tbase = chop $sqry;
      my $p = $posref + $pos + 1;
      push @mm, "x=$p,c=$sbase$tbase" if $sbase ne $tbase;
    }
    return reverse(@mm);
  }


  sub get_aln_strings {

    my $part = shift;
    die "get_aln_strings need 1, 2, or 3" unless $part == 1 || $part == 2 || $part == 3;

    if (defined($::LINECACHE{SAM_ALN})) {
      return $::LINECACHE{SAM_ALN}[$part-1];
    }

    my $qry = $sam_cache[3];
    my $ref = $sam_ref_sequence;
    my $pair = "$::Flink->[0] $::Flink->[2]";

    return "" unless length($qry) && length($ref);

    $qry =~ tr/acgtu/ACGTT/;
    $ref =~ tr/acgtu/ACGTT/;

    my ($aln_ref, $aln_aln, $aln_qry) = ("", "", "");
    my ($pqry, $sqry) = (0, 0);             # position query, start query, end query

    my $pref = $::Flink->[3]-1;

    my ($rlen, $qlen) = (length($ref), length($qry));

    while ($::Flink->[5] =~ m/(\d+)([MIDNSHP=X])/ig) {
      my ($num, $it) = ($1, $2);

      my $rright = $pref + $num;
      my $qright = $pqry + $num;

      if ($it eq 'M') {
        if ($rright > $rlen || $qright > $qlen) {
          print STDERR "[$.] cigar bound exceeded (ref $rright/$rlen qry $qright/$qlen pair $pair)\n";
          last;
        }
        my ($subref, $subqry) = (substr($ref, $pref, $num), substr($qry, $pqry, $num));
        $aln_aln .= align_get_matchregion($subref, $subqry, $pref);
        $aln_ref .= $subref;
        $aln_qry .= $subqry;
        $pref += $num; $pqry += $num;
      }
      elsif ($it eq 'I') {
        $aln_ref .= '-' x $num;
        $aln_aln .= '-' x $num;
        $aln_qry .= substr($qry, $pqry, $num);
        $pqry += $num;
      }
      elsif ($it eq 'D' || $it eq 'N')  {
        $aln_qry .= '-' x $num;
        $aln_aln .= ($it eq 'D' ? '-' : '=') x $num;
        $aln_ref .= substr($ref, $pref, $num);
        $pref += $num;
      }
      elsif ($it eq 'S') {
        # fixme noteme: under some circumstances include this case and extend strings?
        $pqry += $num;
      }
      elsif ($it =~ /[X=P]/)            { print STDERR "[$.] Unexpected cigar state $it for pair $pair\n"; last; }
    }
    $::LINECACHE{SAM_ALN} = [ $aln_ref, $aln_aln, $aln_qry ];
    return $::LINECACHE{SAM_ALN}[$part-1];
  }

  sub get_qry_part {
    my $part = shift;
    my $qry = $sam_cache[3];                     # this is/shouldbe in reference orientation; see strandcheck
    return $qry if $part == -1;
    return $sam_cache[4+$part] if defined($sam_cache[4+$part]);
    my $qrylen = length($qry);
    if (!$qrylen) {
       @sam_cache[4..6] = ('', '', '');
       return '';
    }
    my $NL = 0; $NL = $1 if $::Flink->[5] =~ /^(\d+)S/;
    my $NR = 0; $NR = $1 if $::Flink->[5] =~ /(\d+)S$/;
    @sam_cache[4..6] =
    ( substr($qry, 0,             $NL                 )
    , substr($qry, $NL,           $qrylen - $NL - $NR )
    , substr($qry, $qrylen - $NR, $NR                 )
    ) ;
    return $sam_cache[4+$part];
  }

    # Given inclusive bounds in the reference, compute MDI in the bound region
    # Conceivably this could be done by recomputing the CIGAR string and alignment offsets,
    # but we cannot reuse code easily since a lot is cached and assumes those to be immutable.
    #
    # fixme/todo: reasoned semantics for where insertions and soft clips are placed/counted.
    #
  sub ref_bounded_tally {
    
    my ($ref_x, $ref_y) = map { $_ - 1; } @_;     # go to zero-based coordinates BUT ref_y is still inclusive.
    my $qry = $sam_cache[3];
    my $ref = $sam_ref_sequence;
    my $pair = "$::Flink->[0] $::Flink->[2]";

    return "" unless length($qry) && length($ref);

    $qry =~ tr/acgtu/ACGTT/;     # fixme: ensure this is done at the cache level, remove here and in siblings.
    $ref =~ tr/acgtu/ACGTT/;

    my ($pqry, $sqry) = (0, 0);             # position query, start query
    my $pref = $::Flink->[3]-1;
    my ($qry_x_pos, $qry_y_pos) = (-1, -1); # the positions in query that match ($ref_x, $ref_y)

    my ($rlen, $qlen) = (length($ref), length($qry));
    my ($M, $D, $E, $I, $S) = (0, 0, 0, 0, 0);

    while ($::Flink->[5] =~ m/(\d+)([MIDNSHP=X])/ig) {
      my ($num, $it) = ($1, $2);

      my $rright = $pref + $num;
      my $qright = $pqry + $num;

      my $project_x = $pref;
      my $project_y = $it eq 'M' || $it eq 'D' || $it eq 'N' ? $pref + $num - 1 : $project_x;
      my $num_in_bounds = 0;
      if ($project_x <= $ref_y && $project_y >= $ref_x) {   # overlap exists.
         $num_in_bounds = ($ref_y - $ref_x + 1) + ($project_y - $project_x + 1) - (max($ref_y, $project_y) - min($ref_x, $project_x) + 1);
         # Above: intersection = sum of the the two intervals minus their union.
         $num_in_bounds = $num if $it eq 'I';
      }

      if ($it eq 'M') {
        if ($num_in_bounds > 0) {
          if ($qry_x_pos < 0) {
            $qry_x_pos  = $pqry;
            $qry_x_pos += $ref_x - $pref if $ref_x > $pref;
          }
          $qry_y_pos  = $pqry + $num - 1;                                           # update each time ...
          $qry_y_pos -= ($pref + $num - 1 - $ref_y) if $ref_y < $pref + $num -1;    # don't know a priori which one is the last.
        }
        if ($rright > $rlen || $qright > $qlen) {
          print STDERR "[$.] cigar bound exceeded (ref $rright/$rlen qry $qright/$qlen pair $pair)\n";
          last;
        }
        $pref += $num; $pqry += $num;
        $M += $num_in_bounds;
      }
      elsif ($it eq 'I')                { $pqry += $num; $I += $num_in_bounds; }
      elsif ($it eq 'D')                { $pref += $num; $D += $num_in_bounds; }
      elsif ($it eq 'N')                { $pref += $num; $E += $num_in_bounds; }
      elsif ($it eq 'S')                { $pqry += $num; $S += $num_in_bounds; }
      elsif ($it =~ /[X=P]/)            { print STDERR "[$.] Unexpected cigar state $it for pair $pair\n"; last; }
    }
    if ($qry_x_pos < 0 || $qry_y_pos < 0) {
      print STDERR "[$.] _sam_rbt one or both of x ($qry_x_pos) and y ($qry_y_pos) not pegged to read ($pair)\n";
      $qry_x_pos = 0 if $qry_x_pos < 0;
      $qry_y_pos = $qlen - 1;               # inclusive.
    }
    $::LINECACHE{__REG__}{_rbt_M} = $M;
    $::LINECACHE{__REG__}{_rbt_D} = $D;
    $::LINECACHE{__REG__}{_rbt_E} = $E;
    $::LINECACHE{__REG__}{_rbt_I} = $I;
    $::LINECACHE{__REG__}{_rbt_S} = $S;
    $::LINECACHE{__REG__}{_rbt_qry_x} = $qry_x_pos;
    $::LINECACHE{__REG__}{_rbt_qry_y} = $qry_y_pos;
    $::LINECACHE{__REG__}{_rbt_qry_xylen} = $qry_y_pos - $qry_x_pos + 1;
  }

  sub getalnposx {

    my $indel_report_limit = shift;
    my $qry = $sam_cache[3];
    my $ref = $sam_ref_sequence;
    my $pair = "$::Flink->[0] $::Flink->[2]";

    return "" unless length($qry) && length($ref);

    $qry =~ tr/acgtu/ACGTT/;
    $ref =~ tr/acgtu/ACGTT/;

    my ($pqry, $sqry) = (0, 0);             # position query, start query, end query

    my $pref = $::Flink->[3]-1;

    my ($rlen, $qlen) = (length($ref), length($qry));
    my @mismatch = ();

    while ($::Flink->[5] =~ m/(\d+)([MIDNSHP=X])/ig) {
      my ($num, $it) = ($1, $2);

      my $rright = $pref + $num;
      my $qright = $pqry + $num;

      if ($it eq 'M') {
        if ($rright > $rlen || $qright > $qlen) {
          print STDERR "[$.] cigar bound exceeded (ref $rright/$rlen qry $qright/$qlen pair $pair)\n";
          last;
        }
        push @mismatch, align_get_mismatch(substr($ref, $pref, $num), substr($qry, $pqry, $num), $pref);
        $pref += $num; $pqry += $num;
      }
      elsif ($it eq 'I')                { push @mismatch, "i=$pref,n=$num";
                                          $mismatch[-1] .= ',s=' . substr($qry, $pqry, $num) if !$indel_report_limit || $num <= $indel_report_limit;
                                          $pqry += $num;
                                        }
      elsif ($it eq 'D' || $it eq 'N')  { push @mismatch, ($it eq 'D' ? 'd' : 'e') . "=$pref,n=$num";
                                          $mismatch[-1] .= ',s=' . substr($ref, $pref, $num) if !$indel_report_limit || $num <= $indel_report_limit;
                                          $pref += $num;
                                        }
      elsif ($it eq 'S')                { $pqry += $num; }
      elsif ($it =~ /[X=P]/)            { print STDERR "[$.] Unexpected cigar state $it for pair $pair\n"; last; }
    }
    return join ':', @mismatch;
  }
}


while (<>) {

  %::LINECACHE = ();
  my $Nprotect_previous = $Nprotect;

  if ($F_ignore) {
    my $hit1 = ($F_ignore & 1) && /$PAT_PASS/  ? 1 : 0;
    my $hit2 = ($F_ignore & 2) && /$PAT_PURGE/ ? 1 : 0;
    if ($hit1 || $hit2) {
       if ($hit1) { print "$_"; $Npthr++; }
       $Nskip++;
       if (($F_ignore & 4) && /SN:(\S+)\s+LN:(\d+)/) {         # get sequence lengths from SAM header.
         $::dict{seqlen}{$1} = $2;
       }
       next;
    }
  }

  chomp;
  my @F = length($_) ? split "\t", $_, $OFFSET_OMEGA : ("");
  $::Flink = \@F;

  if ($OFFSET_OMEGA > 0 && @F < $OFFSET_OMEGA) {
    push @F, ( ("") x ($OFFSET_OMEGA - @F)) ;
  }
  if (!$::Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    if (@::nameslist && !$B_posthoc_names) {
      local $" = ' ';
      die "New names [@::nameslist] and data names [@::HEADER] differ in cardinality" if scalar @::nameslist != scalar @::HEADER;
      @::HEADER = @::nameslist;
    }
    compile_time();
    if ($B_posthoc_names) {
      die "New names [@::nameslist] and output offsets [@::output_os] differ in cardinality" if scalar @::nameslist != scalar @::output_os;
      @::OUTPUT_HEADER = @::nameslist;
    }
    else {
      @::OUTPUT_HEADER = map { $::HEADER[$_] } @::output_os;
    }
    if ($F_list) {
      local $, = "\t";
      if ($F_list & 1) { print map { $_ + 1        } @::output_os; print "\n"; }
      if ($F_list & 2) { print map { $::HEADER[$_] } @::output_os; print "\n"; }
print STDERR "-- List contains items from newly computed columns\n" if @::compute;
      exit 0;
    }
    if ($B_print_header) {
      local $, = "\t";
      if ($index_demux < 0) { print @::OUTPUT_HEADER; print "\n" }
      if ($fh_other) {
         print $fh_other @::OUTPUT_HEADER; print $fh_other "\n";
      }
    }
    $::Nrows++;
    next unless $B_headless;
  }
  else {
    my $F = @F;
    die "Header/$::N column/$F count difference at line $. (consider -R or -O<N>)" unless $F == $::N;
    $::Nrows++;
  }

  sam_setup_reflendict    if $I_AM_SAM & 4;        # Done only once.
  sam_setup_aln_sequences if $I_AM_SAM & 2;        # Done for each line; /sam_activate/

  do_compute if @::compute;         # this pushes compute onto @F if present.

  if ($B_pstore) {
     if (do_cache) {
       next;
     }
  }

  my $nmatch = 0;

  my $output = (join "\t", map { $F[$_] } @::output_os) . "\n";

  if ($B_weirdmode && $::Nrows == 1) {
    $Nkeep++;
  }
  elsif ($B_protect_discard && $Nprotect_previous != $Nprotect) {
    $Ndisc++;
    $Nprotect_discard++;
    print $fh_other $output if $fh_other;
    demux_do_row($F[$index_demux], $output, 0) if $index_demux >= 0;
    next;
  }
  else {
     for my $sel (@::select) {
       my ($op, $indirection, $val, $colid, $arg) = @$sel;
       $val = $F[$val] if $indirection;
       $nmatch++ if $op->($F[$colid], $val, $arg);       # $arg currently only used for /ep/ and /om/
     }
     if (@::select && (($nmatch != @::select && $B_select_and) || ($nmatch == 0 && !$B_select_and))) {
       $Ndisc++;
       print $fh_other $output if $fh_other;
       demux_do_row($F[$index_demux], $output, 0) if $index_demux >= 0;
       next;
     }
     else {
       $Nkeep++;
     }
  }

  next if $B_count;      # $Nkeep is the only thing that interests us.

  if ($index_demux >= 0) { demux_do_row($F[$index_demux], $output, 1); }
  else                   { print $output; }
}

print "$Nkeep\n" if $B_count;

if ($I_AM_SAM) { print STDERR "-- $Nskip header lines in input (passed through $Npthr)\n" if $F_ignore && $L_verbose >= 1; }
else           { print STDERR "-- $Nskip skipped lines in input (passed through $Npthr)\n" if $F_ignore && $L_verbose >= 1; }
print STDERR "-- $Nkeep/$Ndisc rows have been kept/discarded\n" if @::select && $L_verbose >= 1;
print STDERR "-- $::Ngroup groups of rows were processed\n" if defined($PSTORE_PIVOT_COLUMN) && $L_verbose >= 1;
print STDERR "-- $Nprotect items needed not-a-number protection ($Nprotect_discard rows discarded)\n" if $Nprotect;

print STDERR "-- $Nsam_refmiss times a reference sequence was not found\n" if $Nsam_refmiss;
print STDERR "-- $Nsam_qrymiss times a query sequence was not available\n" if $Nsam_qrymiss;
print STDERR "-- $Nsam_qryunmapped times a query sequence was unmapped\n" if $Nsam_qryunmapped;
print STDERR "-- $Nsam_lenmiss times a reference sequence length lookup failed\n" if $Nsam_lenmiss;
print STDERR "-- $Nsam_lenclash times a reference sequence difference between SAM header and fasta file $sam_refdictname\n" if $Nsam_lenclash;
print STDERR "-- $Nsam_cigarerr times a cigar string did not match the query sequence\n" if $Nsam_cigarerr;

my $B_header = 1 - $B_headless;
print STDERR "== Line tally check failed: ($::Nrows != $B_header+$Nkeep+$Ndisc+$::Ngroup)\n" if $::Nrows != $B_header+$Nkeep+$Ndisc+$::Ngroup;

if ($N_expect >= 0 && $N_expect != $Nkeep) {
   print STDERR "== Expected number $N_expect but pick found $Nkeep\n";
   exit 1;
}

demux_tally() if $index_demux >= 0;

