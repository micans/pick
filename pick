#!/usr/bin/perl

# Pick version
my $v_v_v = "25-049a";

  #                     Copyright (c) 2022-2025  Stijn van Dongen
  #
  #      Permission is hereby granted, free of charge, to any person obtaining a copy
  #      of this software and associated documentation files (the "Software"), to deal
  #      in the Software without restriction, including without limitation the rights
  #      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  #      copies of the Software, and to permit persons to whom the Software is
  #      furnished to do so, subject to the following conditions:
  #
  #      The above copyright notice and this permission notice shall be included in all
  #      copies or substantial portions of the Software.
  #
  #      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  #      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  #      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  #      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  #      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  #      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  #      SOFTWARE.

use strict;
use warnings;
use Digest::MD5 qw(md5_hex);
use Scalar::Util qw(looks_like_number);
use List::Util qw(min max);
use IO::File;
use Data::Dumper;
use POSIX;
# use B::Deparse ();      # seems slow to load. I use it incidentally to pretty-print all code refs.


=for commanding tables

  __    __                                                                                   __    __
 ( ,'  /  \                                                                                 /  \  ', )
  \ __/_@__\_______________________________________________________________________________/__@_\__ /
   )_(  @@  )/                                                                           \(  @@  )_(
   |  \@@   /    Pick columns and select rows from tabular input, add derived columns     \   @@/  |
   |  @@   o               Pick and select either by column name or index                  o   @@  |
   | @@ \ /               Add new columns, update existing columns in-place                 \ / @@ |
   ( @@  )   Select with numerical and string comparison operators and regular expressions   (  @@ )
   |  @@/                Select on either existing columns or derived columns                 \@@  |
   |   /@             Compute derived columns with string and arithmetic operations           @\   |
   |__/  @                             Add or change column names                            @  \__|
   )_(   @@                Select column names using regular expressions                    @@   )_(
   |  \  @@           And-more-stuff-that-doesn't-fit-here. Read the README.md.             @@  /  |
   |   \@@                                                                                   @@/   |
   |   @@  )                        Requires tab separated input                           (  @@   |
   )__@@ \/_)__________        See -H (EOH below) and -l (brief help)           __________(_\/ @@__(
  /_ \ @  )                                                                                 (  @ / _\
 (__, \__/                                                                                   \__/ ,__)

=cut


@::spec = @ARGV; @ARGV = ();


sub helphelp {
   my $status = shift;
   print STDERR "Version $v_v_v. Use -l (list) for concise help, -H for long help, -h suppresses header line output\n";
   print STDERR "Pick only works as a pipe, so invoke e.g. as: pick foo bar < data.txt\n";
   exit $status;
}

sub tmp_debug { local $" = "] ["; print STDERR "[@_]\n"; }

helphelp(0) unless @::spec;

my $PAT_PURGE      = '';    # ::/my style is somewhat intractable. :: tend to be thing accessed in subroutines.
my $PAT_PASS       = '';    # PURGE is removed before processing, PASS is passed through before processing.
my $INSERT_OFFSET  = undef; # with -A, where to put extra columns (by default at the end).
my $OFFSET_OMEGA   = -1;    # with -O<N>, accept overflow ragged columns from position <N> onwards.
my $sam_refdictname   = "";    # The first dictionary specified. Either with --sam/fname or --fasta-dict=fname
my $progress1      = 0;
my $progress2      = 0;

my $B_print_header = 1;     # B_oolean. Also accessed in subroutines.
my $B_select_and   = 1;     # Require all selections to match (use -o for any)
my $B_preselect_and  = 1;   # Require all preselections to match (use -o for any)
my $B_printall     = 0;     # Select all columns
my $B_inplace      = 0;     # Allow derived column to redefine existing column name
my $B_excise       = 0;     # print all except the plain column handles listed, cannot combine with $B_printall
my $B_add_row_column = 0;   # See -H, EOH
my $B_headless     = 0;     # No header (-k option)
my $B_ko           = 0;     # With -k, make output columns unique and ordered as in output.
my $B_sprouthead   = 0;     # Create header e.g. from derived names
my $B_weirdmode    = 0;     # Header exists, but users wants to use numbers (turns of selections for header)
my $B_force        = 0;     # Force output if identical output names exist
my $F_ignore       = 0;     # Flags: 0 oblivious, 1 pass, 2 purge, 4 read sam sequence lengths SN:(\S+)\s+LN:(\d+)
my $B_debug        = 0;     # Mostly documents the stages of compute and selection definitions
my $L_verbose      = 0;     # Not terrifically interesting
my $B_add_names    = 0;     # If other names are given, whether to output them as column names
my $F_list         = 0;     # output index or name list of selected columns (1: index, 2: name)
my $B_posthoc_names = 0;    # Other names are given solely for output
my $B_regex        = 1;     # Whether to interpret names as a regular expression if one of the characters in $REGEXP_CHARS is found
my $B_protect      = 0;     # Some protection against divide-by-zero; modifiable with PICK_*_INF environment variables.
my $B_protect_discard = 0;  # Discard rows that needed protection.
my $B_count        = 0;     # Only output count of kept rows.
my $N_expect       = -1;    # If set, exit with error if number of non-header rows that is output is different.
my $B_pstore       = 0;     # If set, load ::pstore_cache with previous line final computed fields
my $B_groupfirst   = 0;     # Whether to cache the first row of a group for all subsequent group elements.
my $B_assert_other = 0;     # Output failed rows to file rather than exit.
my $B_whitesquash  = 0;
my $N_demux_buffer = 0;

$::EPSILON         = 0.0001;     # obvs the best default epsilon - 10,000 is a myriad.
$::OOM             = 2;          # order of magnitude. Maybe sqrt(2) makes more sense.

my $fh_other       = undef;
my $name_demux     = undef;
my $index_demux    = -1;

my $I_AM_SAM       = 0;     # Set with --sam or --sam-h; used for caching of some values. Bit flag variable.

my $BIT_HAVE_SAM   =    1 <<  0;     # dealing with sam input
my $BIT_SAM_QSEQ   =    1 <<  1;     # an operator is used that requires the query sequence
my $BIT_SAM_RSEQ   =    1 <<  2;     # an operator is used that requires the reference sequence
my $BIT_SAM_CHECKLEN =  1 <<  3;     # check sequence lengths between header and supplied fasta
my $BIT_SAM_CONTEXT =   1 <<  4;     # show wider context around alignment
my $BIT_SAM_NONF   =    1 <<  5;     # do not convert exterior insertion to softclip
my $BIT_SAM_RBT    =    1 <<  6;     # compute region bound tally
my $BIT_SAM_RBT_CLXY =    1 <<  7;     # x and y specified on command line
my $BIT_SAM_QPARTS =    1 <<  8;     # compute parts for query.
my $BIT_SAM_RPARTS =    1 <<  9;     # compute parts for reference.
my $BIT_SAM_ALN    =    1 << 10;     # compute alignment.
my $BIT_SAM_ALN_MRK  =  1 << 11;     # print markers for trailing parts in alignment
my $BIT_SAM_QLT_SIM  =  1 << 12;     # simplify quality scores

my $DEP_SAM_RPARTS =    $BIT_SAM_RPARTS | $BIT_SAM_RSEQ;                # collect bits that SAM_RPARTS depends on.
my $DEP_SAM_QPARTS =    $BIT_SAM_QPARTS | $BIT_SAM_QSEQ;

my $DEP_SAM_ALN    =    $BIT_SAM_ALN | $BIT_SAM_RSEQ | $BIT_SAM_QSEQ ;
my $DEP_SAM_RBT    =    $BIT_SAM_RBT | $DEP_SAM_ALN;
my $DEP_SAM_RBT_CLXY =  $BIT_SAM_RBT_CLXY | $DEP_SAM_RBT;


my $REGEXP_CHARS   = '[({\\\*?^$';
my $DUMMY_NAME     = 'PICKAAAAA';

my $PSTORE_DEFAULT = "00000000";
my $PSTORE_LIST    = '';         # empty string yields empty list when split
my $PSTORE_PIVOT_COLUMN  = undef;
my $PSTORE_PIVOT_HANDLE  = undef;
my $PSTORE_PIVOT_VALUE   = undef;

%::pstore_init  = ();
%::pstore_cache = ();

my $Nprotect      = 0;
my $Nprotect_discard = 0;

my $Nsam_refmiss = 0;
my $Nsam_qrymiss = 0;
my $Nsam_qryunmapped = 0;
my $Nsam_cigarerr = 0;
my $Nsam_lenmiss = 0;
my $Nsam_lenclash = 0;
my $Nsam_rbtmiss  = 0;
my $Nsam_rbterr  = 0;

my $errtok = ' !';
my $arttok = ' *';

$::sam_max_context = 10000;
$::sam_context_x = 0;
$::sam_context_y = 0;
$::sam_aln_prefix  = "";
$::sam_rbt_x = 0;
$::sam_rbt_y = 0;

sub errm {
  local $" = '][';
  my $vlevel = shift;
  print STDERR "$errtok [error line $.] [@_]\n" if $L_verbose >= $vlevel;
}

sub alert {
  local $" = '][';
  my $vlevel = shift;
  print STDERR "$arttok [alert line $.] [@_]\n" if $L_verbose >= $vlevel;
}

sub pipecroak {
  $_[1] && die("$_[0] : Cannot close : $_[1]\n");
  $_[2] && die("$_[0] : died from signal : $_[2]\n");
  $_[3] && die("$_[0] : exited with error : $_[3]\n");
}

# sub stacky { die "$_[0] stack error\n" unless @::STACK >= $_[1]; }

$Data::Dumper::Terse = 1;
$Data::Dumper::Purity = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Indent = 1;

my %PNAN =                  # Protect against division by zero etc. Defaults that can be overridden.
(  PICK_LOG10_INF => -10000
,  PICK_LOG2_INF  => -10000
,  PICK_LOG_INF   => -10000
,  PICK_TAN_INF   => 'Inf'
,  PICK_DIV_INF   => 'Inf'
,  PICK_DNAGC_NAN => 'NA'
,  PICK_NAN       => 'NaN'
)  ;
for (keys %PNAN) { $PNAN{$_} = $ENV{$_} if defined($ENV{$_}); }


{ my %aatocodon =
  ( '*' => [qw ( TAA TAG TGA ) ]
  , A => [qw ( GCT GCC GCA GCG ) ]
  , C => [qw ( TGT TGC ) ]
  , D => [qw ( GAT GAC ) ]
  , E => [qw ( GAA GAG ) ]
  , F => [qw ( TTT TTC ) ]
  , G => [qw ( GGT GGC GGA GGG ) ]
  , H => [qw ( CAT CAC ) ]
  , I => [qw ( ATT ATC ATA ) ]
  , K => [qw ( AAA AAG ) ]
  , L => [qw ( TTA TTG CTT CTC CTA CTG ) ]
  , M => [qw ( ATG ) ]
  , N => [qw ( AAT AAC ) ]
  , P => [qw ( CCT CCC CCA CCG ) ]
  , Q => [qw ( CAA CAG ) ]
  , R => [qw ( CGT CGC CGA CGG AGA AGG ) ]
  , S => [qw ( TCT TCC TCA TCG AGT AGC ) ]
  , T => [qw ( ACT ACC ACA ACG ) ]
  , V => [qw ( GTT GTC GTA GTG ) ]
  , W => [qw ( TGG ) ]
  , Y => [qw ( TAT TAC ) ]
  );
  my %codontoaa = (); for my $aa (keys %aatocodon) { $codontoaa{$_} = $aa for @{$aatocodon{$aa} } }
  sub dna_tl {
    my $codons = uc(shift);
    my $frame  = shift;
    return "" if length($codons) <= length($frame);
    $codons = substr($codons, $frame) if $frame;
    my $ret = "";
    while ($codons =~ /(...)/g) {
      my $aa = $codontoaa{$1};
      $ret .= defined($aa) ? $aa : '?';
    }
    $ret .= '{' . substr($codons, length($ret)*3) . '}' if 3*length($ret) != length($codons);
       # fixme, above should be user-definable. Not sure what's useful here.
    return $ret;
  }
}

sub strpair {
   my ($x, $y) = @_;
   my $ret = "";
   for (my $i=0; $i<length($x) && $i<length($y); $i++) {
      $ret .= substr($x, $i, 1) eq substr($y, $i, 1) ? '|' : 'x';
   }
   return $ret;
}

sub hmeanall {
   my $ret = 0.0;
   return $ret unless @::STACK;
   if ($B_protect && grep { $_ == 0 } @::STACK) { $Nprotect++; }
   else {
      my $x = 0; $x += 1/abs($_) for @::STACK;
      if ($x || !$B_protect) { $ret = @::STACK / $x; } else { $Nprotect++ }
   }
   return $ret;
}

sub rc {
   my $s = shift;
   $s =~ tr/acgtuACGTU/tgcaaTGCAA/;
   return reverse($s);
}

sub boxit {
   my $n = shift;
   return $_[0] if $n < $_[0];
   return $_[1] if $n > $_[1];
   return $n;
}

# fixme/TODO:
# Implement count check at compile time similar to get_printall_format.

sub fmtall {
   my $fmt = shift;
   my $fmt2 = $fmt;
   my $n = 0;
   $fmt =~ s/\\#/\x02/g;
   $fmt =~ s/#/\x01/g;
   while ($fmt =~ s/\x01/$::STACK[0]/) {
      shift @::STACK;
      last unless @::STACK;
   }
   $fmt =~ s/\x02/#/g;
   if ($n = ($fmt =~ s/\x01//g)) { errm(0, "Format string $fmt2 not exhausted"); }
   elsif (@::STACK)              { errm(0, "Format string $fmt2 did not consume stack"); }
   return $fmt;
}

#  '##' to get '%%' to get '%' won't work; below will count it as two separate format specifiers.
#  However % can be gotten as %25%25.

sub get_printall_format {
   my $fmt = shift;
   $fmt =~ s/\\#/\x02/g;
   my $N = ($fmt =~ tr|#|%|);
   $fmt =~ tr|\x02|#|;
   return ($N, $fmt);
}

# fixme/TODO:
# unite/import this annotation in cp_opdefinitions

my %stack_devour = map { ($_, 1) } qw( addall mulall maxall minall catall meanall hmeanall gmeanall joinall fmtall sprintf) ;
             # _Require Consume Push
my %stack_manip_RCP
   = ( pop => { require => 1, consume => 1, push => 0 }
     , dup => { require => 1, consume => 0, push => 1 }
     , xch => { require => 2, consume => 0, push => 0 }
   , debug => { require => 1, consume => 1, push => 0 }
 , sam_rbt => { require => 2, consume => 2, push => 0 }
     );

                            # Nearly all of the below push 1 item on the stack after consuming X.
                            # Only X is specified; X = 0 indicate exceptional cases.
                            # Potentially neatify this by adding Y (number of pushed items).
my %cp_opdefinitions =
   ( addall    => [ 0, 'n:n*', sub { my $x = 0; $x += $_ for @::STACK; @::STACK = ($x) }, "*\tsum(Stack)\tSum of all entries in stack\tarithmetic/devour" ],
     mulall    => [ 0, 'n:n*', sub { my $x = 1; $x *= $_ for @::STACK; @::STACK = ($x) }, "*\tproduct(Stack)\tProduct of all entries in stack, multiplication\tarithmetic/devour" ],
     maxall    => [ 0, 'n:n*', sub { my $x = -POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ > $x }; @::STACK = ($x) }, "*\tmax(Stack)\tMax over all entries in stack\tarithmetic/devour" ],
     minall    => [ 0, 'n:n*', sub { my $x =  POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ < $x }; @::STACK = ($x) }, "*\tmin(Stack)\tMin over all entries in stack\tarithmetic/devour" ],
     catall    => [ 0, 's:s*', sub { my $x = join "", @::STACK; @::STACK = ($x) }, "*\tStack-joined\tStringified stack\tstring/format/devour" ],
     meanall   => [ 0, 'n:n*', sub { my $x = 0; $x += $_ for @::STACK; @::STACK = @::STACK ? ($x/@::STACK) : (0.0) }, "*\tmean(Stack)\tMean of all entries in stack\tarithmetic/devour" ],
     hmeanall  => [ 0, 'n:n*', sub { @::STACK = hmeanall }, "*\thmean(Stack)\tHarmonic mean of all entries in stack\tarithmetic/devour" ],
     gmeanall  => [ 0, 'n:n*', sub { my $x = 1; $x *= abs($_) for @::STACK; @::STACK = @::STACK ? ($x**(1/@::STACK)) : (1.0) }, "*\tgmean(Stack)\tGeometric mean of all entries in stack, multiplication\tarithmetic/devour" ],
     joinall   => [ 1, 's:s*,s', sub { my $j = pop(@::STACK); my $x = join $j, @::STACK; @::STACK = ($x) }, "* s\tStack-joined-by-s\tStringified stack with s as separator\tstring/devour" ],
     fmtall    => [ 1, 's:s,s*', sub { my $fmt = shift(@::STACK); @::STACK = fmtall($fmt) }, "f *\tMap-*-into-f\tIn f replace # instances by stack\tstring/format/devour" ],
     sprintf   => [ 1, 's:s,s*', sub { my $fmt = shift(@::STACK); @::STACK = sprintf($fmt, @::STACK) }, "f *\tSprintf-*-into-f\tSprintf stack\tstring/format/devour" ],

     add       => [ 2, 'n:n,n', sub { $::STACK[-2] += $::STACK[-1] }, "x y\tx+y\tAdd x and y, sum, addition\tarithmetic" ],
     rand      => [ 1, 'n:n',   sub { $::STACK[-1] = rand($::STACK[-1]) }, "x\trand(x)\tRandom real in range [0, x)\tarithmetic" ],
     join      => [ 3, 's:s,s,s', sub { $::STACK[-3] = "$::STACK[-3]$::STACK[-1]$::STACK[-2]" }, "x y j xjy\tJoined-by-j\tJoin two elements with string separator\tstring/devour" ],
     mul       => [ 2, 'n:n,n', sub { $::STACK[-2] *= $::STACK[-1] }, "x y\tx*y\tMultiply x and y, multiplication, product\tarithmetic"  ],
     div       => [ 2, 'n:n,n', sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? $x / $y : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y\tx/y\tDivision, fraction, (cf -P and PICK_DIV_INF)\tarithmetic" ],
     idiv      => [ 2, 'i:i,i', sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? ($x-($x % $y))/$y : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y\tx // y\tInteger division, divide (cf -P and PICK_DIV_INF)\tarithmetic" ],
     cat       => [ 2, 's:s,s', sub { $::STACK[-2] .= $::STACK[-1] }, "x y\txy\tConcatenation of x and y\tstring/format" ],
     sub       => [ 2, 'n:n,n', sub { $::STACK[-2] -= $::STACK[-1] }, "x y\tx-y\tSubtract y from x, subtraction\tarithmetic" ],

     pop       => [ 0, ':T',    sub { pop @::STACK }, "x\t-\tRemove top entry x from stack\tstack" ],
     dup       => [ 0, 'T,T:T', sub { push @::STACK, $::STACK[-1] }, "x\tx x\tDuplicate top entry x\tstack" ],
     xch       => [ 0, 'T,T:T,T', sub { ($::STACK[-2], $::STACK[-1]) = ($::STACK[-1], $::STACK[-2]) }, "x y\ty x\tExchange x and y\tstack" ],
     rowno     => [ 0, 'u:',    sub { push @::STACK, $::Nrows -1+$B_headless }, "-\tx\tPush current table (start one) row number x onto stack\tinput" ],
     r0wno     => [ 0, 'u:',    sub { push @::STACK, $::Nrows -2+$B_headless }, "-\tx\tPush current table (start zero) row number x onto stack\tinput" ],
     lineno    => [ 0, 'u:',    sub { push @::STACK, $.      }, "-\tx\tPush file line number x onto stack\tinput" ],
     groupno   => [ 0, 'u:',    sub { push @::STACK, $::Ngroup }, "-\tx\tPush group number x onto stack\tinput" ],
     groupi    => [ 0, 'u:',    sub { push @::STACK, $::Groupi }, "-\tx\tPush within-group offset x onto stack\tinput" ],

     save      => [ 2, 'T:T,s',  sub { $::LC{save}{$::STACK[-1]} = $::STACK[-2] }, "x n\tx\tstore x in register with name n\tstate/stack" ],

     debug     => [ 0, ':s',    sub { my $query = pop @::STACK; if ($query eq 'cache') { print Data::Dumper->Dump([\%::LC]); } else { die "Unknown debugging mode $query"; } }, "mode\t-\t[cache] dump internal state\tstate/stack" ],

     fetch     => [ 1, 's:s', sub { my $v = $::LC{save}{$::STACK[-1]}; unless (defined($v)) { errm(0, "no value for $::STACK[-1]"); $v = "NA"; } $::STACK[-1] = $v; }, "n\treg(n)\tretrieve value in register with name n\tstate/stack" ],
     pload     => [ 1, 'H:s', sub { $::STACK[-1] = $::pstore_cache{$::STACK[-1]}; }, "c\tprevrow[c]\tField of column c in the previous row\tstate/stack" ],
                                                                     # see /pload_validate/

     mod       => [ 2, 'i:i,i', sub { $::STACK[-2] %= $::STACK[-1] }, "x y\tx mod y\tx modulo y, remainder\tarithmetic" ],
     pow       => [ 2, 'f:f,f', sub { $::STACK[-2] **= $::STACK[-1] }, "x y\tx**y\tx raised to power y\tarithmetic" ],
     ipow      => [ 2, 'i:i,u', sub { my $y = $::STACK[-2]; $::STACK[-2] *= $y while --$::STACK[-1] > 0; }, "x y\tx**y\tx raised to power y ensuring integer artithmetic\tarithmetic" ],
     bitand    => [ 2, 'u:u,u', sub { $::STACK[-2] &= abs(int($::STACK[-1])) }, "x y\tx and y\tBitwise and between x and y\tbitop" ],
     bitor     => [ 2, 'u:u,u', sub { $::STACK[-2] |= abs(int($::STACK[-1])) }, "x y\tx or y\tBitwise or between x and y\tbitop"  ],
     bitoff    => [ 2, 'u:u,u', sub { $::STACK[-2] |= abs(int($::STACK[-1])); $::STACK[-2] ^= int($::STACK[-1]); }, "x y\tx rm y\tRemove y bits from x\tbitop"  ],
     bitxor    => [ 2, 'u:u,u', sub { $::STACK[-2] ^= abs(int($::STACK[-1])) }, "x y\tx xor y\tBitwise exclusive or between x and y\tbitop"  ],
     bitlsh    => [ 2, 'u:u,u', sub { $::STACK[-2] <<= abs(int($::STACK[-1])) }, "x y\tx << y\tShift x left by y\tbitop"  ],
     bitrsh    => [ 2, 'u:u,u', sub { $::STACK[-2] >>= abs(int($::STACK[-1])) }, "x y\tx >> y\tShift x right by y\tbitop"  ],
     max       => [ 2, 'n:n,n', sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] > $::STACK[-2] }, "x y\tmax(x,y)\tMaximum of x and y\tarithmetic" ],
     min       => [ 2, 'n:n,n', sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] < $::STACK[-2] }, "x y\tmin(x,y)\tMinimum of x and y\tarithmetic" ],
     dd        => [ 2, 'f:n,u', sub { $::STACK[-2] = sprintf("%.*f", $::STACK[-1], $::STACK[-2]) }, "x N\tx'\tFloating point x printed with N decimal digits\tmath/format/precision" ],
     sn        => [ 2, 'f:n,u', sub { $::STACK[-2] = sprintf("%.*e", $::STACK[-1], $::STACK[-2]) }, "x N\tx'\tFloating point x in scientific notation with N decimal digits\tmath/format/precision" ],
     zp        => [ 2, 's:s,u', sub { my $l = $::STACK[-1] - length($::STACK[-2]); $l = 0 if $l < 0; $::STACK[-2] = '0' x $l . $::STACK[-2] }, "x N\tx'\tx left zero-padded to width of N\toutput/string/format" ],
     ppl       => [ 2, 's:s,u', sub { $::STACK[-2] = sprintf("%-*s", $::STACK[-1], $::STACK[-2]); }, "x N\tx'\tx blank-padded to width of N\toutput/string/format" ],
     ppr       => [ 2, 's:s,u', sub { $::STACK[-2] = sprintf("%*s", $::STACK[-1], $::STACK[-2]); }, "x N\tx'\tx blank-padded to width of N\toutput/string/format" ],

     fasta     => [ 2, 's:s,s', sub { $::STACK[-2] = ">$::STACK[-2]\n$::STACK[-1]"; }, "i s\tfasta format\tID and sequence in FASTA format\tformat/bio" ],
     fastq     => [ 2, 's:s,s', sub { $::STACK[-2] = "\@$::STACK[-2]\n$::STACK[-1]\n+\n" . 'Z' x length($::STACK[-1]); }, "i s\tfastq format\tID and sequence in FASTQ format\tformat/bio" ],

     cgsum     => [ 2, 'u:s,s', sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'sum') }, "c s\tSum of s in c\tSum of lengths of s items in cigar string c\tstring/sam" ],
     cgmax     => [ 2, 'u:s,s', sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'max') }, "c s\tMax of s in c\tMax of lengths of s items in cigar string c\tstring/sam" ],
     cgcount   => [ 2, 'u:s,s', sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'count') }, "c s\tCount of s in c\tCount of s items in cigar string c\tstring/sam" ],

     get       => [ 2, 's:s,s', sub { my $item =  $::STACK[-2] =~ qr/$::STACK[-1]/
                                             ? (defined($1) ? $1 : $&) : ""; $::STACK[-2] = $item; }, "x p\tp-match-of-x\tIf x matches pattern p take outer () group or entire match, empty string otherwise (cf uie)\tstring/regex" ],
     uie       => [ 2, 's:s,s', sub { $::STACK[-2] = $::STACK[-1] unless length($::STACK[-2])}, "x y\tx-or-y\tUse x if not empty, otherwise use y\tstring/branch/test" ],
     ed        => [ 3, 's:s,s,s', sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/  }, "x p s\tx =~ s/p/s/\tSubstitute pattern p by s in x\tstring/regex" ],
     edg       => [ 3, 's:s,s,s', sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/g }, "x p s\tx =~ s/p/s/g\tGlobally substitute pattern p by s in x\tstring/regex" ],
     del       => [ 2, 's:s,s', sub { $::STACK[-2] =~ s/$::STACK[-1]// }, "x p\tx =~ s/p//\tDelete pattern p in x\tstring/regex" ],
     delg      => [ 2, 's:s,s', sub { $::STACK[-2] =~ s/$::STACK[-1]//g }, "x p\tx =~ s/p//\tGlobally delete pattern p in x\tstring/regex" ],
     npat      => [ 2, 'u:s,s', sub { $::STACK[-2] = () = ($::STACK[-2] =~ /$::STACK[-1]/g) }, "x p\tnp\tCount occurrences of pattern p in x\tstring/regex" ],
     nchar     => [ 2, 'u:s,s', sub { my ($x, $L, $n) = ($::STACK[-2], length($::STACK[-2]), 0); while ($L--) { $n++ if chop($x) eq $::STACK[-1] } $::STACK[-2] = $n; }, "x c\tnc\tCount char c in x\tstring" ],
     map       => [ 2, 's:s,s', sub {  my ($x, $d) = @::STACK[-2,-1]; my $dict = $::dict{$d}; die "Dictionary $d does not exist" unless defined($dict); my $m = $dict->{$x}; $::STACK[-2] = defined($m) ? $m : dict_not_found($d, $::STACK[-2]); },
                               "x D\tmap-of-x\tUse map of x in dictionary D (if found; cf --(c|f|fastq-|fastq-)dict-D=\tstring/dictionary"
                  ],
     dord      => [ 2, 'u:s,s', sub {  my ($x, $d) = @::STACK[-2,-1]; my $dict = $::dord{$d}; die "Dictionary $d (dord) does not exist" unless defined($dict); my $m = $dict->{$x}; $::STACK[-2] = defined($m) ? $m : ~0; },
                               "x D\tord-of-x\tUse order of x in dictionary D\tstring/dictionary"
                  ],
     tmap      => [ 3, 's:s,s,s', sub {  my ($x, $d, $k) = @::STACK[-3,-2, -1]; my $dict = $::dict{$d}{$k}; die "Dictionary $d does not exist" unless defined($dict); my $m = $dict->{$x}; $::STACK[-3] = defined($m) ? $m : dict_not_found($d, $::STACK[-3]); },
                               "x D c\tmap-of-x\tUse map of x in dictionary D for column c (if found); cf --table-dict-D=\tstring/dictionary"
                  ],
     qnl       => [ 2, 'f:n,s', sub { $::STACK[-2] = get_quant(@::STACK[-2,-1]) }, "x Q\tQ(x)/#Q\t0-1 normalised quantile-of-x (lower tail)\tmath" ],
     qnu       => [ 2, 'f:n,s', sub { $::STACK[-2] = get_revquant(@::STACK[-2,-1]) }, "x Q\t1-Q(x)/#Q\t0-1 normalised quantile-of-x (upper tail)\tmath" ],
     substr    => [ 3, 's:s,i,u', sub { $::STACK[-3] =  substr($::STACK[-3], $::STACK[-2], $::STACK[-1]) }, "x i k\tx[i:i+k-1]\tSubstring of x starting at i (zero-based) of length k\tstring" ],
     head      => [ 2, 's:s,u', sub { my $n = boxit($::STACK[-1], 0, length($::STACK[-2])); $::STACK[-2] =  substr($::STACK[-2], 0, $n) },                      "x k\tx[0:k-1]\tInitial part of string x, of length k [head,tail,skip,shed]\tstring" ],
     tail      => [ 2, 's:s,u', sub { my $n = boxit($::STACK[-1], 0, length($::STACK[-2])); $::STACK[-2] =  substr($::STACK[-2], length($::STACK[-2]) - $n) },  "x k\tx[#x-k:#x-1]\tTrailing part of string x, of length k [head,tail,skip,shed]\tstring" ],
     skip      => [ 2, 's:s,u', sub { my $n = boxit($::STACK[-1], 0, length($::STACK[-2])); $::STACK[-2] =  substr($::STACK[-2], $n) },                         "x k\tx[k:#x-1]\tTrailing part of string x, skipping first k [head,tail,skip,shed]\tstring" ],
     shed      => [ 2, 's:s,u', sub { my $n = boxit($::STACK[-1], 0, length($::STACK[-2])); $::STACK[-2] =  substr($::STACK[-2], 0, length($::STACK[-2])-$n) }, "x k\tx[0:#x-k-1]\tLeading part of string x, shedding last k [head,tail,skip,shed]\tstring" ],
     pct       => [ 3, 'n:n,n,u', sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y+0 ? sprintf("%.*f", $n, $x * 100 / $y) : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y N\tpct(x/y)\tPercentage of x relative to y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],
     pml       => [ 3, 'n:n,n,u', sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y+0 ? sprintf("%.*f", $n, $x * 1000 / $y) : ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y N\tpct(x/y)\tPromille of x relative to y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],
     frac      => [ 3, 'n:n,n,u', sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y+0 ? sprintf("%.*f", $n, $x / $y) :  ($Nprotect++, $PNAN{PICK_DIV_INF}) }, "x y N\tx/y\tDivision, fraction x/y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],

     test      => [ 3, 'u:T,T,s', sub { $::STACK[-3] = do_test(@::STACK[-3,-2,-1]); }, "x y T\tB\ttest T applied to x y\tbranch/test" ],
     ifelse    => [ 3, 'T:u,T,T', sub { $::STACK[-3] = do_ifelse(@::STACK[-3,-2,-1]); }, "B x y\tx or y\tIf B put x else put y\tbranch/test" ],

     todna     => [ 1, 's:s', sub { $::STACK[-1] =~ tr|uU|tT|; $::STACK[-1] =~ tr|bdefh-mo-su-z|n|; $::STACK[-1] =~ tr|BDEFH-MO-SU-Z|N|; $::STACK[-1] =~ tr|acgntACGNT|N|c; }, "x\tx'\tPreserve case, translate uU to tT, nN for non-DNA\tformat" ],
     tobin     => [ 1, 's:i', sub { $::STACK[-1] = sprintf("%b", $::STACK[-1]) }, "x\tx'\tBinary representation of x\tformat" ],
     tohex     => [ 1, 's:i', sub { $::STACK[-1] = sprintf("%x", $::STACK[-1]) }, "x\tx'\tHex representation of x\tformat"  ],
     tooct     => [ 1, 's:i', sub { $::STACK[-1] = sprintf("%o", $::STACK[-1]) }, "x\tx'\tOctal representation of x\tformat"  ],
     binto     => [ 1, 'i:s', sub { $::STACK[-1] = oct("0b$::STACK[-1]") }, "x\tx'\tRead binary representation x\tinput/format" ],
     hexto     => [ 1, 'i:s', sub { $::STACK[-1] = hex($::STACK[-1]) }, "x\tx'\tRead hex representation x\tinput/format" ],
     octto     => [ 1, 'i:s', sub { $::STACK[-1] = oct($::STACK[-1]) }, "x\tx'\tRead octal representation x\tinput/format" ],
     dnatl     => [ 2, 's:s', sub { $::STACK[-2] = dna_tl($::STACK[-2], $::STACK[-1]) }, "x f\tx'\tDNA sequence x translated in frame f\tinput/format/bio" ],
     dnagc     => [ 2, 'f:s,u', sub { my $gc = length($::STACK[-2]) ? sprintf("%.*f", $::STACK[-1], 100 * ($::STACK[-2] =~ tr|GCgc|GCgc|) / length($::STACK[-2])) : $PNAN{PICK_DNAGC_NAN}; $::STACK[-2] = $gc; }, "x N \tgc(x)\tPercentage GC content of x with N decimal digits\tbio" ],
    _strpair   => [ 2, 's:s,s', sub { $::STACK[-2] = strpair($::STACK[-2], $::STACK[-1]); }, "x y\tpair(x,y)\tPairwise character identity\tstring/EXPERIMENTAL" ],
     urldc     => [ 1, 's:s', sub { $::STACK[-1] = urldecode($::STACK[-1]) }, "x\turldc(x)\tUrl decoding of x\tstring/format/input/output" ],
     urlec     => [ 1, 's:s', sub { $::STACK[-1] = urlencode($::STACK[-1]) }, "x\turlec(x)\tUrl encoding of x\tstring/format/input/output" ],
     incr      => [ 1, 'i:i', sub { $::STACK[-1]++ }, "x\tx++\tx incremented by one\tarithmetic" ],
     decr      => [ 1, 'i:i', sub { $::STACK[-1]-- }, "x\tx--\tx decremented by one\tarithmetic" ],
     uc        => [ 1, 's:s', sub { $::STACK[-1] = uc($::STACK[-1]) }, "x\tuc(x)\tUpper case of x\tstring" ],
     lc        => [ 1, 's:s', sub { $::STACK[-1] = lc($::STACK[-1]) }, "x\tlc(x)\tLower case of x\tstring" ],
     rev       => [ 1, 's:s', sub { $::STACK[-1] = reverse($::STACK[-1]) }, "x\trev(x)\tString reverse of x\tstring" ],
     rot13     => [ 1, 's:s', sub { $::STACK[-1] =~ tr/a-zA-Z/n-za-mN-ZA-M/ }, "x\trot13(x)\tRot13 encoding of x\tstring"  ],
     md5       => [ 1, 's:s', sub { $::STACK[-1] = md5_hex($::STACK[-1]) }, "x\tmd5(x)\tMD5 sum of x\tstring/format/input/output"     ],
     len       => [ 1, 'u:s', sub { $::STACK[-1] = length($::STACK[-1]) }, "x\tlen(x)\tLength of string x\tstring" ],
     rc        => [ 1, 's:s', sub { $::STACK[-1] =~ tr/acgtuACGTU/tgcaaTGCAA/; $::STACK[-1] = reverse($::STACK[-1]) }, "x\trc(x)\tReverse complement\tstring" ],
     forward   => [ 2, 'u:s', sub { $::STACK[-2] = $::STACK[-2] ? $::STACK[-1]: rc($::STACK[-1]) }, "B seq\tforward\tseq if B else rc(seq)\tstring" ],
     strim     => [ 3, 's:s', sub { my $nx = max(0, $::STACK[-2]); my $ny = max(0, $::STACK[-1]); $::STACK[-3] = $nx + $ny < length($::STACK[-3]) ? substr($::STACK[-3], $nx, length($::STACK[-3]) - $nx - $ny) : "" }, "s nx ny\ts'\ttrim both ends of string\tstring" ],
     abs       => [ 1, 'u:i', sub { $::STACK[-1] = abs($::STACK[-1]) }, "x\tabs(x)\tAbsolute value of x\tmath" ],
     sqrt      => [ 1, 'f:f', sub { $::STACK[-1] = sqrt($::STACK[-1]) }, "x\tsqrt(x)\tSquare root of x\tmath" ],
     sq        => [ 1, 'n:n', sub { $::STACK[-1] = $::STACK[-1]**2 }, "x\tx^2\tSquare of x\tmath" ],
     exp       => [ 1, 'f:f', sub { $::STACK[-1] = exp($::STACK[-1]) }, "x\te**x\tExponential function applied to x\tmath" ],
     cos       => [ 1, 'f:f', sub { $::STACK[-1] = cos($::STACK[-1]) }, "x\tcos(x)\tCosine of x\tmath" ],
     sin       => [ 1, 'f:f', sub { $::STACK[-1] = sin($::STACK[-1]) }, "x\tsin(x)\tSine of x\tmath" ],
     tan       => [ 1, 'f:f', sub { my $c = cos($::STACK[-1]); $::STACK[-1] = !$B_protect || $c ? sin($::STACK[-1])/$c : ($Nprotect++, $PNAN{PICK_TAN_INF}) }, "x\ttan(x)\tTangens of x\tmath" ],
     log       => [ 1, 'f:f', sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1]) : ($Nprotect++, $PNAN{PICK_LOG_INF}) }, "x\tlog(x)\tNatural logarithm of x\tmath" ],
     log10     => [ 1, 'f:f', sub { $::STACK[-1] = !$B_protect || $::STACK[-1]+0 ? log($::STACK[-1])/log(10) : ($Nprotect++, $PNAN{PICK_LOG10_INF}) }, "x\tlog10(x)\tLogarithm of x in base 10\tmath" ],
     log2      => [ 1, 'f:f', sub { $::STACK[-1] = !$B_protect || $::STACK[-1]+0 ? log($::STACK[-1])/log(2)  : ($Nprotect++, $PNAN{PICK_LOG2_INF}) },  "x\tlog2(x)\tLogarithm of x in base 2\tmath" ],
     exp10     => [ 1, 'f:f', sub { $::STACK[-1] = 10**$::STACK[-1] }, "x\t10^x\t10 to the power of x\tmath" ],
     sign      => [ 1, 'i:n', sub { $::STACK[-1] = $::STACK[-1] > 0 ? 1 : $::STACK[-1] < 0 ? -1 : 0 }, "x\tsign(x)\tThe sign of x (-1, 0 or 1)\tmath" ],
     neg       => [ 1, 'n:n', sub { $::STACK[-1] *= -1 }, "x\t-x\tThe sign-reversed value of x\tmath" ],
     ceil      => [ 1, 'i:f', sub { $::STACK[-1] = ceil($::STACK[-1]) }, "x\tceil(x)\tThe ceil of x\tmath" ],
     floor     => [ 1, 'i:f', sub { $::STACK[-1] = floor($::STACK[-1]) }, "x\tfloor(x)\tThe floor of x\tmath" ],
     round     => [ 1, 'i:f', sub { $::STACK[-1] = sprintf("%.0f", $::STACK[-1]) }, "x\tround(x)\tThe integer nearest to x\tmath" ],
     int       => [ 1, 'i:f', sub { $::STACK[-1] = int($::STACK[-1]) }, "x\tint(x)\tx truncated towards zero (do not use for rounding)\tmath" ],

   );


sub sam_reflen {
  my $x = $::dict{seqlen}{$::Flink->[2]};
  if (!defined($x)) {
    $x = $::dictnotfound{seqlen};
    $Nsam_lenmiss++;
    errm(1, "no length for $::Flink->[2]") if $Nsam_lenmiss < 5;
  }
  return $x;
}


my %cp_samdefs = (

     aln_nmatch      => [ 0, 'i:', sub { push @::STACK, acigar($::LC{suv}{aln_matched_cgr}, 'M=X', 'sum') }, "-\talnmatch\tAmount of reference/query matched by alignment (ignoring indels and mismatches)\tsam" ],
     aln_nedit       => [ 0, 'i:', sub { my $nm = $::Flink->[11] =~ /\bNM:i:(\d+)/ ? $1 : 0; push @::STACK, $nm }, "-\talnedit\tEdit distance from NM:i field\tsam" ],
     aln_nedit_pia   => [ 0, 'i:', sub { my $x = $::LC{suv}{aln_aln}; my $ngood = ($x =~ tr/|=_/|=_/); push @::STACK, (length($x) - $ngood); }, "-\talnedit_pia\tEdit distance pick-computed (intron aware)\tsam" ],
     aln_nedit_piu   => [ 0, 'i:', sub { my $x = $::LC{suv}{aln_aln}; my $ngood = ($x =~ tr/|_/|_/); push @::STACK, (length($x) - $ngood); }, "-\talnedit_piu\tEdit distance pick-computed (intron unaware)\tsam" ],
     aln_nmatchx     => [ 0, 'i:', sub { my $nm = $::Flink->[11] =~ /\bNM:i:(\d+)/ ? $1 : 0; push @::STACK, $nm - acigar($::LC{suv}{aln_matched_cgr}, 'DI', 'sum') }, "-\talnmatchx\tNumber of base mismatches within aligned part\tsam" ],

     aln_posinfo     => [ 1, 's:u', sub { $::STACK[-1] = &getalnposx($::STACK[-1]) }, "n\taln_posinfo\tMismatch positions; indel sequences reported up to length n\tsam" ],
     aln_all         => [ 0, 's:', sub { push @::STACK, join "\n", map { $::sam_aln_prefix . $::LC{suv}{$_} } qw(aln_rlr aln_ref aln_aln aln_qry) }, "-\taln_all\talignment ruler+ref+aln+query\tsam" ],
     aln_allq        => [ 0, 's:', sub { push @::STACK, join "\n", map { $::sam_aln_prefix . $::LC{suv}{$_} } qw(aln_rlr aln_ref aln_aln aln_qry aln_qlt) }, "-\taln_all\talignment ruler+ref+aln+query+quality\tsam" ],
  aln_all_pack       => [ 0, 's:', sub { push @::STACK, join "\x01", map { $::sam_aln_prefix . $::LC{suv}{$_} } qw(aln_rlr aln_ref aln_aln aln_qry) }, "-\taln_all_pack\talignment ruler<%01>ref<%01>aln<%01>query\tsam" ],
     patchiness      => [ 2, 'u:s,u', sub { $::STACK[-2] = aln_patchiness($::STACK[-2], $::STACK[-1]) }, "s d\tpatchiness\tpatchiness score for alignment string\tsam" ],
     patchiness2     => [ 2, 'u:s,u', sub { $::STACK[-2] = aln_patchiness2($::STACK[-2], $::STACK[-1]) }, "s d\tpatchiness\tpatchiness score for alignment string\tsam" ],
     isforward       => [ 0, 'u:', sub { push @::STACK, $::Flink->[1] & 16 ? 0 : 1 }, "-\tisforward\tmatch is on the forward strand (1) or not (0)\tsam" ],

     sam_rbt         => [ 0, ':u,u', sub { &ref_bounded_tally($::STACK[-2], $::STACK[-1]); $#::STACK -= 2; }, "x y\t-\tcompute region-bound-tally quantities for reference positions [x-y]\tsam" ],
     rbt_alnall      => [ 0, 's:', sub { push @::STACK, join "\n", map { $::sam_aln_prefix . $::LC{suv}{$_} } qw(rbt_alnrlr rbt_alnref rbt_alnaln rbt_alnqry rbt_alnqlt) }, "-\trbt_alnall\talignment for region\tsam" ],
     sam_get         => [ 2, 's:s,s', sub { $::STACK[-2] = ($::Flink->[11] =~ /(^|\t)\Q$::STACK[-2]\E:(.*?)(\t|$)/ ? $2 : $::STACK[-1]) }, "tag def\tsam_get\tvalue for <tag>, use def if absent\tsam" ],

     suv             => [ 1, 's:s', sub { my $r = $::LC{suv}{$::STACK[-1]};  die "no SUV for $::STACK[-1]" unless defined($r); $::STACK[-1] = $r; }, "key\tvalue\tsam unified view lookup\tsam" ],

     qry_seq         => [ 0, 's:', sub { push @::STACK, &get_qry();}, "-\tqry_seq\tquery sequence in reference orientation\tsam" ],
     qry_qual        => [ 0, 's:', sub { push @::STACK, &get_qual();}, "-\tqry_qual\tquery quality string in reference orientation\tsam" ],
   );

my %cp_sam_setup_seqs = map { $_ => 0 } keys %cp_samdefs;

  $cp_sam_setup_seqs{$_} |=  $DEP_SAM_ALN    for qw( aln_posinfo all_all_pack aln_all aln_allq aln_nedit_pia aln_nedit_piu );
  $cp_sam_setup_seqs{$_} |=  $BIT_SAM_QSEQ   for qw( qry_seq );
  $cp_sam_setup_seqs{$_} |=  $DEP_SAM_RBT    for qw( rbt_alnall sam_rbt );


# The only suv you'll ever need. Sam Unified View.

my %suv_direct_lookup =
(  ref_posx         =>  [ 'Start position of alignment in ref (1-based)',   0  ]
,  ref_posy         =>  [ 'End position of alignment in ref (1-based)',     0  ]
,  ref_len          =>  [ 'Length of reference sequence',                   0  ]
,  qry_posx         =>  [ 'Start position of alignment in query (1-based)', 0  ]
,  qry_posy         =>  [ 'End position of alignment in query (1-based)',   0  ]
,  qry_len          =>  [ 'Length of query sequence',                       $DEP_SAM_QPARTS ]
,  ref_trail5p      =>  [ '5\' unaligned reference sequence',               $DEP_SAM_RPARTS ]
,  ref_matched      =>  [ 'Matched reference sequence',                     $DEP_SAM_RPARTS ]
,  aln_matched_cgr  =>  [ 'Cigar string for matched part',                  0  ]
,  ref_trail3p      =>  [ '3\' unaligned reference sequence',               $DEP_SAM_RPARTS ]
,  aln_trail5p_cgr  =>  [ 'Cigar string for 5\' trailing part',             0  ]
,  ref_trail5p_N    =>  [ 'Length of 5\' unaligned reference sequence',     0  ]
,  ref_matched_N    =>  [ 'Length of Matched reference sequence',           0  ]
,  aln_trail3p_cgr  =>  [ 'Cigar string for 3\' trailing part',             0  ]
,  ref_trail3p_N    =>  [ 'Length of 3\' unaligned reference sequence',     0  ]
,  qry_trail5p      =>  [ '5\' unaligned query sequence',                   $DEP_SAM_QPARTS ]
,  qry_matched      =>  [ 'Matched query sequence',                         $DEP_SAM_QPARTS ]
,  qry_trail3p      =>  [ '3\' unaligned query sequence',                   $DEP_SAM_QPARTS ]
,  qry_trail5p_N    =>  [ 'Length of 5\' unaligned query sequence',         0  ]
,  qry_matched_N    =>  [ 'Length of Matched query sequence',               0  ]
,  qry_trail3p_N    =>  [ 'Length of 3\' unaligned query sequence',         0  ]
,  ref_trail5p_V    =>  [ 'Length of displayed 5\' unaligned reference sequence',     0  ]
,  ref_trail3p_V    =>  [ 'Length of displayed 3\' unaligned reference sequence',     0  ]

,  aln_ref          =>  [ 'Alignment string for reference',                 $DEP_SAM_ALN ]
,  aln_aln          =>  [ 'Alignment string between reference and query',   $DEP_SAM_ALN ]
,  aln_qry          =>  [ 'Alignment string for query',                     $DEP_SAM_ALN ]
,  aln_rlr          =>  [ 'Alignment ruler for reference',                  $DEP_SAM_ALN ]
,  aln_qlt          =>  [ 'Alignment quality',                              $DEP_SAM_ALN ]

,  rbt_alnref       =>  [ 'Reference string (rbt)',                         $DEP_SAM_RBT   ]
,  rbt_alnaln       =>  [ 'Alignment string (rbt)',                         $DEP_SAM_RBT   ]
,  rbt_alnqry       =>  [ 'Query string (rbt)',                             $DEP_SAM_RBT   ]
,  rbt_alnrlr       =>  [ 'Ruler string (rbt)',                             $DEP_SAM_RBT   ]
,  rbt_alnqlt       =>  [ 'Quality string (rbt)',                           $DEP_SAM_RBT   ]
,  rbt_refx         =>  [ 'Reference start position (rbt)',                 $DEP_SAM_RBT   ]
,  rbt_refy         =>  [ 'Reference end position (rbt)',                   $DEP_SAM_RBT   ]
,  rbt_dx           =>  [ 'x adjustment if rbt_refx < ref_posx',            $DEP_SAM_RBT   ]
,  rbt_dy           =>  [ 'y adjustment if rbt_refy > ref_posy',            $DEP_SAM_RBT   ]
,  rbt_qryx         =>  [ 'Query start position (rbt)',                     $DEP_SAM_RBT   ]
,  rbt_qryy         =>  [ 'Query end position (rbt)',                       $DEP_SAM_RBT   ]
,  rbt_qry          =>  [ 'Query sequence (rbt)',                           $DEP_SAM_RBT   ]
,  rbt_qrylen       =>  [ 'Query sequence length (rbt)',                    $DEP_SAM_RBT   ]
,  rbt_nmatchx      =>  [ 'Number of aligned mismatched bases (rbt)',       $DEP_SAM_RBT   ]
,  rbt_nmatch       =>  [ 'Number of aligned bases (rbt)',                  $DEP_SAM_RBT   ]
,  rbt_ndel         =>  [ 'Number of deletions (rbt)',                      $DEP_SAM_RBT   ]
,  rbt_nins         =>  [ 'Number of insertions (rbt)',                     $DEP_SAM_RBT   ]
,  rbt_nedit        =>  [ 'Number of edits (rbt)',                          $DEP_SAM_RBT   ]
);


# The values are appreciated, the keys are deprecated.

my %appreciated = qw(
         alnmatch aln_nmatch
         alnedit  aln_nedit
         alnposx  aln_posinfo
         alnmatchx aln_nmatchx
         qryclipl qry_trail5p_N
         qrycov   qry_matched_N
         qryclipr qry_trail3p_N
         qrylen   qry_len
         qrystart qry_posx
         qryend   qry_posy

         refclipl ref_trail5p_N
         refcov   ref_matched_N
         refclipr ref_trail3p_N
         reflen   ref_len
         refstart ref_posx
         refend   ref_posy

         and      bitand
         or       bitor
         xor      bitxor
         lsh      bitlsh
         rsh      bitrsh
   );

            # sub { } :
            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
            # For /ep/ and /om/ third argument is $::EPSILON/$::OOM or specified suffix.
            # 40 41 etc just to keep sort order when outputting list of select ops,
            # as '/' is overloaded in a slightly confusing way (negation and num op delimiter),
            # as is '~' (matching and string op delimiter). This keeps them grouped together.
            #
my %sel_opdefinitions = (
  '~'          => [ 40, sub { $_[0] =~ /$_[1]/ }, 1 ],
  '/~'         => [ 41, sub { $_[0] !~ /$_[1]/ }, 1 ],
  '='          => [ 42, sub { $_[0]  eq $_[1]  }, 2 ],
  '/='         => [ 43, sub { $_[0]  ne $_[1]  }, 2 ],

  '/eq/'       => [ 44, sub { $_[0] == $_[1] },   2 ],
  '/ne/'       => [ 45, sub { $_[0] != $_[1] },   2 ],
  '/lt/'       => [ 46, sub { $_[0] <  $_[1] },   2 ],
  '/le/'       => [ 47, sub { $_[0] <= $_[1] },   2 ],
  '/ge/'       => [ 48, sub { $_[0] >= $_[1] },   2 ],
  '/gt/'       => [ 49, sub { $_[0] >  $_[1] },   2 ],

  '/ep/'       => [ 50, sub { test_interval_plus(@_)}, 2 ],      # epsilon
  '/om/'       => [ 51, sub { test_interval_mul(@_) }, 2 ],      # order of magnitude

  '~eq~'       => [ 52, sub { $_[0] eq $_[1] }, 1 ],
  '~ne~'       => [ 53, sub { $_[0] ne $_[1] }, 1 ],
  '~lt~'       => [ 54, sub { $_[0] lt $_[1] }, 1 ],
  '~le~'       => [ 55, sub { $_[0] le $_[1] }, 1 ],
  '~ge~'       => [ 56, sub { $_[0] ge $_[1] }, 1 ],
  '~gt~'       => [ 57, sub { $_[0] gt $_[1] }, 1 ],
  '~isin~'     => [ 59, sub { defined($::dict{$_[1]}{$_[0]}) ? 1 : 0 }, 1 ],
  '~isnotin~'  => [ 60, sub { defined($::dict{$_[1]}{$_[0]}) ? 0 : 1 }, 1 ],
  '~hasval~'   => [ 61, sub { test_hasval(@_) }, 1 ],
  '~hasnotval~' => [ 62, sub { ! test_hasval(@_) }, 1 ],

     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/'      => [ 63, sub { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) }, 8 ],
  '/any/'      => [ 64, sub { abs(int($_[0])) & abs(int($_[1])) },            8 ],
  '/none/'     => [ 65, sub { ! (abs(int($_[0])) & abs(int($_[1]))) },        8 ],
  '/notall/'   => [ 66, sub { $_[1] != (abs(int($_[0])) & abs(int($_[1]))) }, 8 ],

  '/epx/'      => [ 67, sub { ! test_interval_plus(@_)}, 2 ],      # epsilon exclusion
  '/omx/'      => [ 68, sub { ! test_interval_mul(@_) }, 2 ],      # order of magnitude exclusion

);

my %sel_invert =
 ( '~'      =>  '/~'           ,  '/~'          =>  '~'
 , '='      =>  '/='           ,  '/='          =>  '='
 , '/eq/'   =>  '/ne/'         ,  '/ne/'        =>  '/eq/'
 , '/lt/'   =>  '/ge/'         ,  '/ge/'        =>  '/lt/'
 , '/gt/'   =>  '/le/'         ,  '/le/'        =>  '/gt/'
 , '~eq~'   =>  '~ne~'         ,  '~ne~'        =>  '~eq~'
 , '~lt~'   =>  '~ge~'         ,  '~ge~'        =>  '~lt~'
 , '~gt~'   =>  '~le~'         ,  '~le~'        =>  '~gt~'
 , '~isin~' =>  '~isnotin~'    ,  '~isnotin~'   =>  '~isin~'
 , '~hasval~' => '~hasnotval~' ,  '~hasnotval~' =>  '~hasval~'
 , '/all/'  =>  '/notall/'     ,  '/notall/'    =>  '/all/'
 , '/any/'  =>  '/none/'       ,  '/none/'      =>  '/any/'
 , '/ep/'   =>  '/epx/'        ,  '/epx/'       =>  '/ep/'
 , '/om/'   =>  '/omx/'        ,  '/omx/'       =>  '/om/'
);

for my $k (keys %sel_invert) { die "Boot error $k" unless defined($sel_opdefinitions{$k}); }

# Noteme: see /test_validate/ -- compile-time check for the opdefinition lookup below.
# TODO:
#    _set_ep _set_om operators to allow setting of band.
#        then recognise '\/(ep|om)\/', pass band straight to test_interval_mul test_interval_plus
#    compile time: conceivably could already ploink the code reference in place.

sub do_test {
   return $sel_opdefinitions{$_[2]}[1]->($_[0], $_[1]) ? 1 : 0;
}

sub do_ifelse {
  if (looks_like_number($_[0])) {
    return $_[0] != 0.0 ? $_[1] : $_[2];
  }
  else {
    return length($_[0]) ? $_[1] : $_[2];
  }
}


my $envsettings = join "\n", map { sprintf("  %-20s %8s", $_, $PNAN{$_}) } keys %PNAN;
my $opsections  = join ' ', sort keys %{{ map { ($_, 1) } map { split '/', (split "\t", $_->[3])[3] } values %cp_opdefinitions }};

my $regexpointers = <<EOP;
Useful perl regular expression features:
   Use \\K (keep) to anchor a pattern but retain it with ed, edg, del, delg
   :HANDLE^'patx\\Kpaty',delg will retain patx and only delete paty.
   Use patx(?=paty) to anchor patx to paty without including paty in the matched part.
   :HANDLE^'patx(?=paty)',get will just fetch patx.
   (?%3A...) groups a pattern without creating a backreference (%3A url-encodes ':')
   Use (?i)pat to make a pattern case insensitive.

Regular expression examples:
   - pick -i '.*'::__^'(%5E\\s+|\\s+\$)',delg        # remove trailing/leading whitespace in all cells
EOP


my $help_options=q{Options:
  -h do not print header
  -o OR multiple select criteria (default is AND)
  -s OR multiple preselect criteria (default is AND)
  -x take complement of selected input column(s) (works with -i)
  -i in-place: <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -/<pat>  skip lines matching <pat>; use e.g. -/^# for commented lines, -/^@ for sam files
  -//<pat> pass through lines matching <pat>
     <pat> allows perl regular expressions, e.g. ^ $ . [] * ? (|) work.
  -v verbose (-vv -vvv increase verbosity)
  -e squash all white-space from computes and selections before parsing them
  -q quiet (-qq -qqq increase quietness)
  -d debug

  -f force processing (allows both identical input and output column names)
  -F fixed names; do not interpret names as regular expressions.
     Default behaviour is to assume a regular expression if a name contains one of ^ $ [ \{ ( \ * ?
  -R add _ column variable if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically

  -A print all input columns (selecting by colspec applies.
  -A<N> <N> integer; insert new columns at position <N>. Negative <N> is relative to rightmost column.
  -O<N> <N> integer; allow ragged input - merge all columns at/after position <N>
  -E<N> <N> integer; expect <N> rows returned, exit with error if this is not the case.
  / -P protect against 'nan' and 'inf' results (see -H for environment variables PICK_*_INF)
  \ -Z as above, discard rows that need protecting

  -k headerless input, use 1 2 .. for input column names
     x-y for range from x to y
     a+x-y*k for range from a + k*x to a+y*k with incrementes of k
  -K headerless input, as above, use derived names to output column names
  -U with -k and -K keep output columns unique and in original order
  -W (weird mode) header exists but use 1 2 .. for column names (selection not applied to header)
    1. consider using a=longcolumnname b=longercolumname; pick $a $b @$b/gt/0 @$a/lt/0 < data.txt
    2. consider using --inames=CSV (see below; this will change names in the output)

  -z  ARG+ print url-encoding of ARG+  (no argument prints a few especially useful cases)
  -zz ARG+ print url-decoding of ARG+
  -l or -l <string> list operators (matching section string if specified)
     to specify multiple sections use a comma-separated string.
     sections: } . $opsections . q{

  -H Longer pick description

  --inames=CSV       comma-separated values to use as column names instead of actual column names.
  --add-inames=CSV   The list must cover all columns in the input. Names that are used
                     in selection, compute and filter expressions must be picked from this list.
                     Output names are from the list. If using -k --inames=CSV provides temporary
                     handles; use --add-inames=CSV to add them to the output.

  --onames=CSV       Override output column names to be taken from comma-separated values.

  --fdict-NAME=fname fname should be two-column tab-separated file storing key and value per line.
                     This stores a dictionary called NAME that can be used to map values
                     with ...^NAME,map. Small dictionaries can be encoded on the command line with
  --cdict-NAME=<csv> where <csv> is a comma separated string of key:value pairs -- after splitting
                     on commas and colons all keys and values are url-decoded. Example:

       echo -e "a\t3\nb\t4" | pick -Aik --cdict-foo=a:Alpha,b:Beta 1::1^foo,map

  --table-dict-NAME=fname  Read table; Use ...^NAME^columnname,tmap for lookup.
  --fasta-dict-NAME=fname  Read fasta file; Sequences can be looked up with map.
  --fastq-dict-NAME=fname  Read fastq file; Sequences can be looked up with map.

  With all dictionary loading the part

     NAME=fname         can be augmented to
     NAME/<string>=fname

  If a key is not found with map or tmap then <string> will be used as the default value.

  --other=fname      write discarded rows to fname
  --demux=colname    use the value in colname as file name to write the row to.

  --version          version

  --pstore
  --pstore/<LIST>/<DEFAULT>
  --pstore/<LIST>/
  --pstore//<DEFAULT>
                     Cache/store previous row. Available to load with ^colname,pload. If <LIST>
                     (comma-separated, colon-separated key-value pairs) is specified it is used to
                     populate the named fields of the predecessor of the first row.  If <DEFAULT>
                     is specified it is used for all fields not named. Example (Fibonacci):

       yes | head | pick -k --pstore/x:1,y:0 x::^y,pload y::x^x,pload,add

                     Can be used to detect group boundaries in sorted data.

  --idx-list         Output list of selected indexes
  --name-list        Output list of selected column names
  --idx-map          Output the two lists above

  Short options combine, e.g. -ok/^@ for headerless input, comments indicated by ^@, OR selection.
  -AT is useful for inspecting/checking select criteria
  use -Ai <name>::<COMPUTE> to change column <name> to <COMPUTE>,
  use -Aik <num>::<COMPUTE> to change column <num> to <COMPUTE>.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (column name, index, or derived compute name)
  (2) @<HANDLE><op><VAL>       select criterion compare handle to constant value with <op>
  (3) @<HANDLE><op>:<HANDLE2>  select criterion compare handle to other handle with <op>
  (4) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output

  COMPUTE: <part>+ where <part> is one of ^<value> :<handle> ,<operator>
  Later computes have access to HANDLEs that were computed before.

  HANDLE, VAL and handles and values in COMPUTE are all URL-decoded.
  URL-encoding is generally necessary for characters in [%:^/,~]. Use pick -z <string>
  to find the url-encoding of <string> .};

my @opsf = sort { $sel_opdefinitions{$a}[0] <=> $sel_opdefinitions{$b}[0] } keys %sel_opdefinitions;
my $nameslist = "";

%::dict = ();
%::dord = ();
%::dictnotfound = ();

%::quant = ();

                    # noteme. If there are many ties a counted storage may be preferable.
sub read_quant {
   my ($name, $fname) = @_;
   open(my $fh, '-|', 'gunzip', '-cf', '--', $fname) or die("Cannot gunzip file $fname for quant loading: $!\n");
   $::quant{$name} = [];
   my $cur = -POSIX::DBL_MAX;
   while(<$fh>) {
      chomp;
      die "Not a number in $fname: $_" unless looks_like_number($_);
      die "Not in order in $fname: $cur $_" unless $cur <= $_;
      push @{$::quant{$name}}, $_;
      $cur = $_;
   }
   if (!close($fh)) { pipecroak("gunzip -cf < $fname (quant load)", $!, $? & 0x7F, $? >> 8) }
   my $n = @{$::quant{$name}};
   die "Need at least one quant mark (have none from $fname)" unless $n > 0;
   $n++;
print STDERR "-- quant $name has $n levels after reading $fname\n" if $L_verbose >= 0;
}

sub read_dict {
   my ($name, $fname, $mode) = @_;
   open(my $fh, '-|', 'gunzip', '-cf', '--', $fname) or die("Cannot gunzip file $fname for dict loading: $!\n");
   my $n_novalue = 0;
   $::dict{$name} = {} unless $::dict{$name};
   $::dord{$name} = {} unless $::dord{$name};
   while(<$fh>) {
      chomp; my @F = split "\t";
      my $value = 1;
      if (@F >= 2 && $mode eq 'f') { $value = $F[1]; } else { $n_novalue++; }
      $::dict{$name}{$F[0]} = $value;
      $::dord{$name}{$F[0]} = $.;
   }
   if (!close($fh)) { pipecroak("gunzip -cf < $fname (dict load)", $!, $? & 0x7F, $? >> 8) }
   my $n = keys %{$::dict{$name}};
print STDERR "-- dictionary $name has $n keys after reading $fname\n" if $L_verbose >= 1;
print STDERR "-- dictionary $name has $n_novalue keys set to value 1\n" if $L_verbose >= 1 && $n_novalue;
}

sub read_tbdict {
   my ($name, $keycol, $fname) = @_;
   open(my $fh, '-|', 'gunzip', '-cf', '--', $fname) or die("Cannot gunzip file $fname for table dict loading: $!\n");
   my $header=<$fh>; chomp $header; my @header = split "\t", $header; my %h = ();
   my $keycolindex = defined($keycol) ? -1 : 0;
   for (my $i=0; $i<@header; $i++) { $h{$i} = $header[$i]; $keycolindex = $i if $keycolindex < 0 && $keycol eq $header[$i]; }
   die "No column [$keycol] found in $fname" unless $keycolindex >= 0;
   my $n = 0;
   $::dict{$name} = {} unless !length($name) || defined($::dict{$name});
   my $root = length($name) ? $::dict{$name} : \%::dict;
   while(<$fh>) {
      chomp; my @items = split "\t", $_, -1;                      # recognise empty fields (-1 split argument)
      die "Table read error" unless scalar @items == scalar @header;
      for (my $i=0; $i<@items; $i++) {
         next if $i == $keycolindex;
         $root->{$h{$i}}{$items[$keycolindex]} = $items[$i];
      }
     $n++;
   }
   if (!close($fh)) { pipecroak("gunzip -cf < $fname (table dict load)", $!, $? & 0x7F, $? >> 8) }
   my $k = @header - 1;
print STDERR "-- Table dictionary $name has $n keys for $k columns { @header } after reading $fname\n" if $L_verbose >= 1;
print STDERR "-- Keys to be used with ^$name\[^:]KEY,tmap\n" if $L_verbose >= 1 && length($name);
print STDERR "-- Keys to be used with [^:]KEY,map\n" if $L_verbose >= 1 && !length($name);
   return \@header;
}

sub read_fadict {
   my ($name, $fname, $NF) = @_;
   open(my $fh, '-|', 'gunzip', '-cf', '--', $fname) or die("Cannot gunzip file $fname for fasta loading: $!\n");

   my ($id, $seq) = (undef, "");
   while(<$fh>) {
      if (/^>(\S+)/) { $::dict{$name}{$id} = $seq if defined($id); ($id, $seq) = ($1, ""); }
      else           { chomp; $seq .= $_; }
   }
   if (!close($fh)) { pipecroak("gunzip -cf < $fname (fasta load)", $!, $? & 0x7F, $? >> 8) }
   $::dict{$name}{$id} = $seq if defined($id);
   $::dict{$name}{'*'} = "";      # noteme: (1) SAM format unmapped reads have ref '*' (2) pick uses '' in other fail scenarios, but the entirety needs design/documenting.
   my $n = keys %{$::dict{$name}};
   $::dictnotfound{$name} = $NF;
print STDERR "-- sequence dictionary $name has $n keys after reading $fname\n" if $L_verbose >= 1;
   if (length($sam_refdictname)) {
     print STDERR "WARNING --- multiple fasta dictionaries, I'm using $sam_refdictname for SAM reference lookups ---\n";
   }
   else {
      $sam_refdictname = $name;                    # experimental/fragile
      print STDERR "-- Sequences for SAM reference lookup loaded from $fname in dictionary $sam_refdictname\n" if $L_verbose >= 0;
   }
}

                     # Find the largest L st q[L-1] <= val (in 1-indexing)
                     # Return L/N. Note that N == #quant-levels
                     # Never returns 0
                     # Returns 1 at and beyond highest quant level.
sub get_quant {
  my ($val, $name) = @_;
  my $q = $::quant{$name};
  die("Quant $name not found") unless $q;
  my $L = 0;

                                 # find highest L such that q[L-1] <= val
  if ($q->[0] <= $val) {         # q[L-1] <= val is invariant.
    $L = 1;
    my $R = @$q;
    while ($L < $R) {
      my $i = ($R+$L) >> 1;
      if ($q->[$i] <= $val) { $L = $i+1; }
      else                  { $R = $i; }
    }
  }
  return ($L+1) / (@$q+1);
}


                     # Finds the smallest i st q[i+1] >= $val
                     # Return (N+1-i) / N.
                     # Never returns 0
                     # Returns 1 at and before lowest quant level.
sub get_revquant {
  my ($val, $name) = @_;
  my $q = $::quant{$name};
  die("Quant $name not found") unless $q;
  my $R = @$q-1;
                                  # find lowest i such that q[i+1] >= val
  if ($q->[$R] >= $val) {         # q[R+1] >= val is invariant.
    $R--;
    my $L = -1;
    while ($L < $R) {
      my $i = (($R+$L+1) >> 1);
# print STDERR "$val  L=$L $q->[$L], i=$i, R=$R $q->[$R]\n";
      if ($q->[$i] >= $val) { $R = $i-1; }
      else                  { $L = $i;   }
    }
  }
  return (@$q+1-$R-1) / (@$q+1);
}



sub read_fqdict {
   my ($name, $fname) = @_;
   open(my $fh, '-|', 'gunzip', '-cf', '--', $fname) or die("Cannot gunzip file $fname for fastq loading: $!\n");
   my $id = undef;
   while(<$fh>) {
      if ($. % 4 == 1)       { die "Fastq read error on line %." unless /^@(\S+)/; $id = $1; }
      elsif ($. % 4 == 2)    { chomp; $::dict{$name}{$id} = $_; }
   } close($fh);
   if (!close($fh)) { pipecroak("gunzip -cf < $fname (fastq load)", $!, $? & 0x7F, $? >> 8) }
   my $n = keys %{$::dict{$name}};
print STDERR "-- sequence dictionary $name has $n keys after reading $fname\n" if $L_verbose >= 1;
}

{  my %fh_demux = ();
   sub demux_do_row {
      my ($name, $output, $do_print) = @_;
      my $val = $fh_demux{$name};
      if (!defined($val)) {
         my $fh = new IO::File;
         my $openstring = $name =~ /\.gz(ip)?$/ ? "|gzip >$name" : ">$name";
         $fh->open("$openstring") || die "Failed to open $name";
            # consider; if this fails because of too many open file handles then
            # close the least used file handles or not recently used and retry.
         $val = [$fh, 0, 0, 0, ""];       # (0) fh (1) N_print (2) N_noprint (3) N_buffer (4) buffer
         $fh_demux{$name} = $val;
         if ($B_print_header) {
            print $fh (join "\t", @::OUTPUT_HEADER) . "\n";
         }
      }
      if ($do_print) {
         $val->[1]++;
         if (!$N_demux_buffer) { print {$val->[0]} $output; }
         else {
            $val->[4] .= $output;
            $val->[3]++;
            if ($val->[3] >= $N_demux_buffer) {
               print {$val->[0]} $val->[4];
               ($val->[3], $val->[4]) = (0, "");
            }
         }
      }
      else {
         $val->[2]++;
      }
   }
   sub demux_tally {
      print STDERR "File\tWritten\tFiltered\tLastFlush\n";
      for (sort { $a cmp $b } keys %fh_demux) {
         print {$fh_demux{$_}[0]} $fh_demux{$_}[4] if $fh_demux{$_}[3] > 0;
         $fh_demux{$_}[0]->close() || print STDERR "-- issue closing file handle for $_\n";
         print STDERR "$_\t$fh_demux{$_}[1]\t$fh_demux{$_}[2]\t$fh_demux{$_}[3]\n";
      }
   }
}

sub parse_range {
  my $spec = shift;
  @::colindexes = ();
  if ($spec =~ /^(\d+)$/) {
    @::colindexes = ($1);
    return 1;
  }
  elsif ($spec =~ /^((\d+)\+)?(\d+)-(\d+)?(\*(\d+))?$/) {
    my ($offset, $start, $end, $multiply) = ($2, $3, $4, $6);
    $offset   = 0 unless defined($offset);
    $multiply = 1 unless defined($multiply);
    $end      = $::N unless defined($end);
    @::colindexes = grep { $_ >= 1 && $_ <= $::N } map { $offset + $_ * $multiply } $start..$end;
    if (@::colindexes < $end - $start + 1) {
print STDERR "-- range expansion produced some indexes out of range (now dropped)\n";
    }
    return 1;   # even if the spec resulted in empty selection.
  }
  return 0;
}

sub parse_dict {
   my ($name, $string) = @_;
   my $L = 1;
   for my $pair (split ",", $string) {
      my ($k, $v) = map { urldecode($_) } split ':', $pair, -1;        # @urldecode --cdict-NAME=
      if (!defined($v)) {
         print STDERR "-- Setting value for $k to 1\n" if $L_verbose >= 2;
         $v = 1;
      }
      $::dict{$name}{$k} = $v;
      $::dord{$name}{$k} = $L++;
   }
   my $n = keys %{$::dict{$name}};
print STDERR "-- dictionary $name has $n keys after parsing string\n" if $L_verbose >= 1;
}

sub dict_not_found {
   my ($d, $val) = @_;
   my $NF = $::dictnotfound{$d};
   return $val unless defined($NF);
   die "Lookup for $val in dictionary $d failed" if $NF eq '__EXIT__';
   return $NF;
}

BEGIN {
   my %map = ( s  => 'String'  , u  => 'Unsigned' , i  => 'Signed' , f  => 'Float'
             , n  => 'Numeric' , T  => 'Any type' , H  => 'Handle' , C  => 'Constant' , L  => 'Lookup'
             , '' => 'Nothing'
             );
   sub explain_io {
      my ($what, $sign) = @_;
      my ($post, $pre)  = split ':', $sign, -1;
      my @pre = (); my @post = ();
      for (split ',', $pre, -1) {
         my $qualifier = s/\*// ? 'list of ' : '';
         push @pre, "$qualifier$map{$_}";
      }
      for (split ',', $post, -1) { push @post, "$map{$_}"; }
      @pre  = ('Nothing') unless @pre;
      @post = ('Nothing') unless @post;
      local $" = ', ';
      print "== [$post|$pre] $what yields @post; takes @pre\n";
   }
}

while (@::spec && $::spec[0] =~ /^-/) {            # cline processing

  my $options = shift @::spec;

  if ($options =~ /^\-(z+)$/) {
    local $, = ' ';
    print map { length($1) % 2 == 1 ? urlencode($_) : urldecode($_) } @::spec;
    if (@::spec) { print "\n"; }
    else { print STDERR <<EOH;
-- I url-encode (-z) or decode (-zz) any arguments. Useful cases:
  ^   %5E     ;   %3B     (  %28     <TAB>      %09     |   %7C
  :   %3A     !   %21     )  %29     <NEWLINE>  %0A     ~   %7E
  ,   %2C     /   %2F     <  %3C     <CR>       %0D     @   %40
  %   %25     \\   %5C     >  %3E     <SPACE>    %20     =   %3D
For shell meta-characters it is easiest to just quote the argument to pick.
EOH
    }
    exit 0;
  }
  elsif ($options =~ /^\-(l+)$/) {
    my $elliness = length($1);
    my $filter = @::spec ? $::spec[0] : '.';
    $filter =~ s/,/|/g;
    print "\nSelect comparison operators:\n  @opsf\n\n";
    exit 0 if $filter eq 'selection';
    printf "%-14s%-12s%-20s%s\n", 'Operator', 'Consumed', 'Produced', 'Description';
    print  '-' x 80 . "\n";
    # my $deparse = B::Deparse->new;

    if ($filter eq 'sam' || $I_AM_SAM) {
      for my $op (keys %suv_direct_lookup) {
        @{cp_opdefinitions{$op}} = [ $op, 's:s', sub { }, "-\t$op\t$suv_direct_lookup{$op}[0]\tsam" ];
                     # ^ dangersign the above is just to sort all the sam operators together.
                     # This is knowing we exit at the end of this -l option block.
      }
      if (!($I_AM_SAM & $BIT_HAVE_SAM)) {
        # add sam defs for purpose of listing.
        for (keys %cp_samdefs) { $cp_opdefinitions{$_} = $cp_samdefs{$_}; }
      }
    }
    for my $op (sort keys %cp_opdefinitions) {
      my $opdef = $cp_opdefinitions{$op};
      my @help = split "\t", $opdef->[3];
      die "Error in description @help\n" unless @help == 4;
      next unless $help[3] =~ $filter || $filter =~ /$help[3]/;
      printf "%-14s%-12s%-20s%s [%s]\n", $op, @help;
      explain_io($op, $opdef->[1]) if $elliness == 2;
      # print $deparse->coderef2text($opdef->[2]), "\n\n\n" if $elliness > 1;
    }
    if ($filter eq 'regex') {
      print "\n$regexpointers";
    }
    if ($filter eq 'sam' && !($I_AM_SAM & $BIT_HAVE_SAM)) {
      print STDERR "\n-- For sam functionality you must use --sam or --sam/<fastafile> --\n";
    }
    if ($filter eq '.') { print "\nUse -l <query> to limit output to sections matching <query>, e.g pick -l string\nSections: $opsections\n" }
    else { print "\nAll operators in section(s) matching <$filter>\nSections: $opsections\n" }
    exit 0;
  }
  elsif ($options eq '-H') {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
  See further below for <op> list.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a select criterion comparing a handle to a constant value.
Form (3) creates a select criterion comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op><VAL>
@<COLNAME><op>:<COLNAME>  select rows based on <VAL> or value in column <COLNAME>.

<op> is one of the following:
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/<what>
  /ep/<what>/epsilon  Column value lies in [ <what> - epsilon, <what> + epsilon ] (default $::EPSILON)
  /om/<what>
  /om/<what>/oom      |Column value| lies in [ |<what>| / oom, |<what>| * oom ] (default $::OOM)
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> and <handle> will be url-decoded. In particular, if you
  need one of [%^:,/~] in <string> it is best to url-encode it with 25, 5E, 3A,
  2C, 2F, 7E respectively; use pick -z <string> to find its URL-encoded form.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).

  If the very first part starts with anything other than [,:^] it is inferred
  to be a handle (leading : not needed).  <COMPUTE> is a stack, so
  zut::foo:bar,add^str,cat creates a new column called zut by adding columns
  foo and bar and then concatenating 'str'. The default operation is
  concatenation; if no operators are left the remainder of the stack is
  concatenated. Thus the above is equivalent to zut::foo:bar,add^str. To just
  prefix a column: zut::^foo:zut To concatenate two columns: zut::foo:bar .
  Use -l to see the description of operators.

Environment variables with default settings:
$envsettings

$regexpointers
EOH
  exit 0;
  }

  elsif ($options =~ s/^--//) {

     last if $options eq '';

     if ($options =~ /^(k|f|fastq-|fasta-|table-)dict-(\w+)(\/(.*?))?=(.+)$/) {
       read_dict($2, $5, $1) if $1 eq 'f' || $1 eq 'k';
       read_fadict($2, $5, length($3) ? $4 : '__EXIT__') if $1 eq 'fasta-';
       read_fqdict($2, $5) if $1 eq 'fastq-';
       read_tbdict($2, undef, $5) if $1 eq 'table-';
       $::dictnotfound{$2} = $4 if length($3);        # for read_fadict this happens twice. tidy up sometime.
     }
     elsif ($options =~ /^table-dict(\/(.*?))?(\^(.*?))?=(.+)$/) {
       my $header = read_tbdict("", defined($3) ? $4 : undef, $5);
       if (defined($2)) { $::dictnotfound{$_} = $2 for @$header; }
       my $nd = keys %{$::dict{$header->[1]}};
     }
     elsif ($options =~ /^cdict-(\w+)(\/(.*?))?=(.+)$/) {
       parse_dict($1, $4);
       $::dictnotfound{$1} = $3 if length($2);
     }
     elsif ($options =~ /^quant-(\w+)=(.+)$/) {
        read_quant($1, $2);
     }
     elsif ($options =~ /^(add-)?inames=(.+)$/) {
       $nameslist=$2;
       $B_add_names = $1 ? 1 : 0;
     }
     elsif ($options =~ /^(idx|name)-list$/) {
       $F_list |= $1 eq 'idx' ? 1 : 2;
     }
     elsif ($options =~ /^idx-map$/) {
       $F_list |= 4;
     }
     elsif ($options =~ /^demux-buffer=(\d+)$/) {
       $N_demux_buffer = $1 + 0;
     }
     elsif ($options =~ /^progress(=(\d+)\/(\d+))?$/) {
       $progress1 = defined($1) ? $2 : 1000000;
       $progress2 = defined($1) ? $3 : 0;
     }
     elsif ($options =~ /^pstore(\/(.*?))?(\/(.*?))?$/) {
       $B_pstore = 1;
       $PSTORE_LIST = $2 if defined($1);
       $PSTORE_DEFAULT = $4 if defined($3);
     }
     elsif ($options =~ /^group(-(first-ref|all))?=(\S+)$/) {
       $B_pstore = 1;
       $PSTORE_PIVOT_HANDLE = $3;
       if (defined($1)) {
          if ($2 eq 'first-ref') { $B_groupfirst = 1; }
          else             { die "--group-all not available currently"; }
       }
     }
     elsif ($options eq 'version') {
       print "$v_v_v\n";
       exit 0;
     }
     elsif ($options =~ /^onames=(.+)$/) {
       $nameslist=$1;
       $B_posthoc_names = 1;
     }
     elsif ($options =~ /^inf=(\S+)/) {
       $PNAN{PICK_DIV_INF} = $1;
     }
     elsif ($options =~ /^demux=(\S+)/) {
       $name_demux = $1;
     }
     elsif ($options =~ /^(assert-)?other=(\S+)/) {
       my $fn = $2;
       $B_assert_other = 1 if defined($1);
       $fh_other = new IO::File;
       my $openstring = ($fn =~ /\.gz(ip)?$/) ? "|gzip >$fn" : ">$fn";
       $fh_other->open("$openstring") || die "Cannot open $fn";
     }
     elsif ($options eq 'remind-me' || $options eq 'rmm')  {
       if (!@::spec || $::spec[0] ne 'sam') {
         print STDERR "Available reminders: sam\n"; exit 0;
       }
       if ($::spec[0] eq 'sam') {
         print <<EOH;
Fields:
   1     2     3     4     5     6     7     8     9    10    11
 QNAME FLAG  RNAME  POS  MAPQ  CIGAR  RNEXT PNEXT TLEN SEQ   QUAL

Bits:
     1     template has multiple templates in sequencing (read is paired)
     2     each segment properly aligned according to the aligner (read mapped in proper pair)
     4     segment unmapped (read1 unmapped)
     8     next segment in the template unmapped (read2 unmapped)
    16     SEQ is reverse complemented (read1 reverse complemented)
    32     SEQ of the next segment in the template is reverse complemented (read2 reverse complemented)
    64     the first segment in the template (is read1)
   128     the last segment in the template (is read2)
   256     secondary alignment
   512     alignment fails quality checks
  1024     PCR or optical duplicate
  2048     supplementary alignment (e.g. aligner specific, could be a portion of a split read or a tied region)
EOH
         exit 0;
       }
     }
                           # see /sam_activate/ for compile-time activation sam_setup_sequences
     elsif ($options =~ /^sam(-h)?(\/(\S+))?$/) {
       if (defined($1)) { $F_ignore |= 5; $PAT_PASS  = '^@'; }
       else             { $F_ignore |= 6; $PAT_PURGE = '^@'; }
       if (defined($2)) {
         my $fname = $3;
         read_fadict('SAMFA', $fname, '__EXIT__');
       }
       $B_headless = 1;
       $OFFSET_OMEGA = 12;
       $::dictnotfound{seqlen} = 0;
       $::dict{seqlen} = {};                # noteme; if --fdict-seqlen=FILE --sam then fdict is thrown away.
       $I_AM_SAM |= $BIT_HAVE_SAM | $BIT_SAM_CHECKLEN;
       for (keys %cp_samdefs) { $cp_opdefinitions{$_} = $cp_samdefs{$_}; }
     }
     elsif ($options =~ /^sam-aln-context=(\d+)$/) {
       $I_AM_SAM |= $BIT_SAM_CONTEXT;
       $::sam_max_context = $1;
     }
     elsif ($options eq 'sam-aln-mrk') {
       $I_AM_SAM |= $BIT_SAM_ALN_MRK;
     }
     elsif ($options eq 'sam-qlt-sim') {
       $I_AM_SAM |= $BIT_SAM_QLT_SIM;
     }
     elsif ($options =~ /^sam-aln-xy=(\d+),(\d+)$/) {
       $I_AM_SAM |= $BIT_SAM_CONTEXT;
       ($::sam_context_x, $::sam_context_y) = ($1, $2);
     }
     elsif ($options =~ /^sam-aln-prefix=(.*)/) {
       $::sam_aln_prefix = $1;
     }
     elsif ($options =~ /^sam-rbt=(\d+),(\d+)$/) {
       $I_AM_SAM |= $DEP_SAM_RBT_CLXY;
       $::sam_rbt_x = $1;
       $::sam_rbt_y = $2;
     }
     elsif ($options eq 'sam-nonf') {      # no normal form.
       $I_AM_SAM |= $BIT_SAM_NONF;         #
     }
     else {
       die "Unrecognised long option --$options";
     }
     next;
  }

  if ($options =~ s/\/\/(.*)$//)    { $F_ignore |= 1; $PAT_PASS  = urldecode($1); }       # @urldecode -//PAT
  if ($options =~ s/\/([^\/].*)$//) { $F_ignore |= 2; $PAT_PURGE = urldecode($1); }       # @urldecode -/PAT

  if ($options =~ s/O(\d+)//) {
     $OFFSET_OMEGA = $1 + 0;
     die "-O<N> N must be positive\n" unless $OFFSET_OMEGA > 0;
  }

  if ($options =~ s/E(\d+)//) {
     $N_expect = $1 + 0;
     die "-E<N> N must be nonnegative\n" unless $N_expect >= 0;
  }

  if ($options =~ s/A(-?\d+)?//) {
     $B_printall     = 1;
     if (defined($1)) {
        $INSERT_OFFSET = $1 + 0;
     }
  }

  $B_print_header = 0 if $options =~ s/h//;
  $B_regex        = 0 if $options =~ s/F//;
  $B_protect      = 1 if $options =~ s/P//;
  $B_whitesquash  = 1 if $options =~ s/e//;
  ($B_protect, $B_protect_discard) = (1,1) if $options =~ s/Z//;
  $B_select_and   = 0 if $options =~ s/o//;
  $B_preselect_and   = 0 if $options =~ s/s//;
  $L_verbose += length($1)  if $options =~ s/(v+)//;
  $L_verbose -= length($1)  if $options =~ s/(q+)//;
  $B_ko           = 1 if $options =~ s/U//;
  $B_excise       = 1 if $options =~ s/x//;
  $B_add_row_column =1 if $options =~ s/R//;
  $B_headless     = 1 if $options =~ s/k//;
  ($B_headless, $B_sprouthead)= (1, 1) if $options =~ s/K//;
  ($B_headless, $B_weirdmode) = (1, 1) if $options =~ s/W//;
  $B_debug        = 1 if $options =~ s/d//;
  $B_force        = 1 if $options =~ s/f//;
  $B_inplace      = 1 if $options =~ s/i//;
  $B_count        = 1 if $options =~ s/c//;

  if ($options ne '-') {
    print STDERR "Option string not fully parsed: $options remains\n";
    exit 1;
  }
}

$B_print_header = 0 if $B_count;

@::spec = map { s/\s+//g; $_; } @::spec if $B_whitesquash;


die "-O<N> requires -k\n" if $OFFSET_OMEGA > 0 && !$B_headless;

$B_print_header = 0 if $B_headless;
$B_print_header = 1 if $B_add_names || $B_posthoc_names || $B_sprouthead;

@::nameslist = $nameslist ? split ',', $nameslist : ();

helphelp(1) unless @::spec || $B_printall || $B_excise || $B_force || $B_count || $F_list;

sub test_interval_plus {
  my ($x, $y, $val) = @_;
  my $epsilon = $val ? $val : $::EPSILON;
  return $x <= $y + $epsilon && $x >= $y - $epsilon;
}

sub test_interval_mul {
  my ($x, $y, $val) = @_;
  my $oom = $val ? $val : $::OOM;
  return abs($x) <= abs($y) * $oom && abs($x) >= abs($y) / $oom;
}

sub test_hasval {
  my ($x, $y, $val) = @_;
  my $v = $::dict{$y}{$x};
  return defined($v) && $v eq $val ? 1 : 0;
}


my $TYPE_SCALAR = 1;

my $TYPE_HANDLE = 2;

my $TYPE_OPATOR = 3;    # (1) rule of six obvs, (2) it makes sense in Dutch.

my $TYPE_LUSPUV = 4;    # Look up s(p)uv. sam (parts) unified view.
                        # These are used like operators, e.g. ',qry_len', but are translated to hash lookups.
                        # The data provided (sam/alignment-related) is precomputed before the compute loop
                        # with some effort made to compute only the needed parts. This makes part of the code more
                        # complicated, and eternal vigilance is needed to keep this orchestration correct.

my %chartypetonum = ( '^', $TYPE_SCALAR, ':', $TYPE_HANDLE, ',', $TYPE_OPATOR );

sub parse_compute {

  my ($handle, $spec) = @_;
  my @oplist = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[,^:]/;
  my $l = length($spec);
  my $sam_rbt_in_use = 0;

  while ($spec =~ /([,^:])([^,^:]*)/g) {

    my ($type, $what) = ($chartypetonum{$1}, $2);
    $what = urldecode($what) if $type == $TYPE_SCALAR || $type == $TYPE_HANDLE;     # @urldecode ^const :handle
    push @oplist, [$type, $what];
    $p = pos($spec);
    if ($type == $TYPE_OPATOR) {
      if (defined($appreciated{$what})) {
        print STDERR "$errtok Deprecated: <$what>, please use <$appreciated{$what}> instead\n";
        $what = $appreciated{$what};
        $oplist[-1][1] = $what;
      }
      my $use_sam_shortcut = ($I_AM_SAM & $BIT_HAVE_SAM) && defined($suv_direct_lookup{$what}) ? 1 : 0;
      my $sambits = 0;

      my $opdef = $use_sam_shortcut ? [ 0, 's:s', sub { }, "dummy-string" ] : $cp_opdefinitions{$what};

      $::LC{suv}{__sam_rbt__} = 1 if $what eq 'sam_rbt';

      my $offer = "know";
      $offer = "have available ( use --sam or --sam/<fastafile> )" if defined($suv_direct_lookup{$what}) || defined($cp_samdefs{$what});
      die "[$what] is not an operator I $offer" unless defined($opdef) || $use_sam_shortcut;

                                             # /sam_activate/
      if (defined($cp_sam_setup_seqs{$what})) {
        if (!$use_sam_shortcut) {
          $sambits   = $cp_sam_setup_seqs{$what};
          $I_AM_SAM |= $sambits;
        }
      }
      elsif ($use_sam_shortcut) {
         $oplist[-1][0] = $TYPE_LUSPUV;
         $sambits = $suv_direct_lookup{$what}[1];
         $I_AM_SAM |= $sambits;
      }

      if (($sambits & $BIT_SAM_RBT) && !$::LC{suv}{__sam_rbt__} && !($I_AM_SAM & $BIT_SAM_RBT_CLXY)) {
         die "Operator $what is used without prior ,sam_rbt or --sam-rbt=x,y instruction";
      }
                           # N stack required, code.
      push @{$oplist[-1]}, ($opdef->[0], $opdef->[2]);
    }
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oplist;
}


sub urlencode {
   my $val = shift;
   $val =~ s/([^A-Za-z0-9_])/ uc sprintf "%%%0x", ord $1 /eg;
   return $val;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


sub acigar {

   my ($cigar, $subset, $mode) = @_;
   my $key = "cigar::$cigar";
   my @subset = split "", $subset;

   return 0 if $cigar eq '*';

   if (!defined($::LC{cigar}{$key})) {
      my $c = $::LC{cigar}{$key} =
        { sum   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , max   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , count => { map { ($_, 0)  } split "", 'MINDSHP=X' } };
      my $p = 0; my $n = 0;
      while ($cigar =~ m/(\d+)([MINDSHP=X])/ig) {
        my ($num, $it) = ($1, $2);
        $n += length($&);
        $c->{sum}{$it} += $num;
        $c->{count}{$it}++;
        $c->{max}{$it} = $num if $num > $c->{max}{$it};
        $p = pos($cigar);
      }
      errm(-1, "unmatched part in cigar string $cigar at $p") unless $p == length($cigar) && $n == length($cigar);
   }
   my $cache = $::LC{cigar}{$key};
   if ($mode eq 'max')      { my $max = 0; for my $x (@subset) { $max = $cache->{max}{$x} if $cache->{max}{$x} > $max }; return $max }
   elsif ($mode eq 'sum')   { my $sum = 0; $sum += $cache->{sum}{$_} for @subset; return $sum }
   elsif ($mode eq 'count') { my $count = 0; $count += $cache->{count}{$_} for @subset; return $count }
   else                     { return 'NA' }
}

   ## Returns an arrary of matches; each match is an array [name1, name2].
   ## name1 is the existing name (found in header), name2 is the new name, normally the same.
   ## New names can be made by the prefix/suffix convention as well as using regex parentheses ().
   ##
sub expand_list_range_and_regex {
   my ($spec, $has_compute) = @_;
   my @matches = ();
   my ($suffix, $prefix, $duplicate) = ("", "", 0);
   if ($has_compute) {             # in this case accept p/spec/s syntax for column renaming and p/spec//s for duplicating
      $duplicate = $spec =~ /\/\// ? 1 : 0;
      my @parts = split /\/+/, $spec, -1;
      if (@parts > 3) { die "Handle has more than three /-separated parts"; }
      elsif (@parts == 3) { ($prefix, $spec, $suffix) = @parts; }
      elsif (@parts == 2) {   # to specify just prefix, one needs p/spec/
        ($spec, $suffix) = @parts;
        if ($suffix =~ /[:$REGEXP_CHARS]/) {       # ':' is there as we split on that.
print STDERR "Suffix [$suffix] contains regex/list characters, did you want '$spec/$suffix/'?\n";
        }
      }
   }

   for my $item ($spec eq '' ? ("") : split ':', $spec, -1) {
print STDERR "-- (output) considering $item\n" if $L_verbose >= 2;
      if ($B_headless && parse_range($item)) {
         push @matches, map { { namein => $_, nameout => $_ } } @::colindexes;        #  global for the win.
      }
      elsif ($item =~ /[$REGEXP_CHARS]/ && $B_regex) {
         my $nfound = 0;
         for my $name (@::HEADER[0..($::N-1)]) {
            if ($name =~ qr/$item/) {
               push @matches, { namein => $name, nameout => defined($1) ? $1 : $name };
               $nfound++;
            }
         }
         die "'$item' was considered as regex and yielded no matches" unless $nfound;
      }
      else {
         push @matches, { namein => $item, nameout => $item };
      }
   }
   my $n_matches = @matches; local $" = ' ';
   for (@matches) {
      $_->{nameout} = "$prefix$_->{nameout}$suffix";
   }
   my @matchnames = map { $_->{namein} } @matches;
print STDERR "-- (output) item $spec ($n_matches results: @matchnames)\n" if $L_verbose >= 2 || (!$n_matches && $spec);

   return ($duplicate, \@matches);
}


@::output_nm  = ();         # names - (header|1..N) + compute handles
%::output_nm_cmp_output = (); # names introduced for output using compute
@::output_os  = ();         # names translated to offsets in @F (field array)
@::compute = ();            # derived column specifications
@::select  = ();            # row select specifications
@::preselect  = ();         # row select specifications
@::assert = ();             # row assertions
%::handle_map = ();         # map column names to offsets
# @::column_use_as = [];      # track usage of columns. 1 string 2 numeric 4 signed 8 unsigned 16 float
%::plain_handle = ();       # handles without any compute following.
@::INPUT_HEADER = ();       # input header. @::HEADER exists, is intermediate and can have repeats; @::OUTPUT_HEADER is output header.


sub compile_select {

  my ($caller, $select, $presel_handle) = @_;

  for my $sel (@$select) {

    my ($op, $indirection, $val, $name, $arg) = @$sel;

       # fixme: better naming/documenting/coding-logic to follow tight linkt between @::HEADER and %::handle_map.
       # the if-else here is not entirely satisfactory - handle_map{$name} lookup is not checked for preselect; this is OK but still.
       #
    if ($caller eq 'select' || $caller eq 'assert') {
      die "Handle [$name] in $caller does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});
      if (!$indirection && defined($::handle_map{$val}) && $op !~ /is(not)?in/ && $L_verbose >= -2) {
        print STDERR "-- You used $val (a column handle) as a constant in $op test, did you want :$val? --\n"
      }
    }
    else {
      die "Handle [$name] in $caller does not reference a known entity among @::INPUT_HEADER\n" unless defined($presel_handle->{$name});
      if (!$indirection && defined($presel_handle->{$val}) && $op !~ /is(not)?in/ && $L_verbose >= -2) {
        if ($name eq $val && ($op eq '/ne/' || $op eq '/=')) {
          # print STDERR "-- Concatenating tables methinks\n";
          # I tried to be jolly, but it's just annoying. Or would some output still be useful
          # in case a column name might be a valid entry in that same column?
        }
        else {
          print STDERR "-- You used $val (a column handle) as a constant in $op test, did you want :$val? --\n"
        }
      }
    }

    my $opdef = $sel_opdefinitions{$op};
    die "The impossible happened ($op)\n" unless defined($opdef);

    $sel->[0] = $opdef->[1];             # fixme overwrite inelegant
    $sel->[3] = $presel_handle ? $presel_handle->{$name} : $::handle_map{$name};    # fixme overwrite inelegant

    if ($indirection) {
       if ($caller eq 'select') { die "Handle [$val] in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$val}); }
       else                     { die "Handle [$val] in preselect does not reference a known entity among @::INPUT_HEADER\n" unless defined($presel_handle->{$val}); }
       $sel->[2] = $presel_handle ? $presel_handle->{$val} : $::handle_map{$val};  # fixme overwrite inelegant
    }
    { my ($code, $indirection, $val, $name, $arg) = @$sel;
print STDERR "ddd select code=$code ind=$indirection val=$val name=$name arg=$arg --\n" if $B_debug; }

  }
}


sub parse_spec {

  for my $spec (@::spec) {
    if ($spec =~ s/^(\@(assert)?\@|\@)//) {
      my $type = $1;
      my ($handle, $op, $val, $arg) = (undef, undef, undef, undef);
                    #  H handle
                    #  a1a2a3, b, c, d different forms for op
                    #  V value or :handle
                    #    ( H )([ a1](      a2    )[ a3])( V)(  arg )
      if ($spec =~ /^(.*?)([\/~](?:[a-z]{2,19})[\/~])(.*?)([\/~].*?)?$/) {        # fixme. proper checking.
        ($handle, $op, $val, $arg) = (urldecode($1), $2, urldecode($3), $4);      # @urldecode @handle/../arg|handle/arg
        die "Unrecognised operator [$op]\n" unless defined($sel_opdefinitions{$op});
      }
                    #  = ~ /= /~
      elsif ($spec =~ /^(.*?)(\/?[=~])(.*?)$/) {
        ($handle, $op, $val) = (urldecode($1), $2, urldecode($3));      # @urldecode @handle/../arg|handle/arg
      }
      else {
         print STDERR "-- Selection invalid [$_]. I need @<name><op><:name|value>, see pick -l selection for <op>\n";
         exit 1;
      }
      die "Unrecognised operator [$op]\n" unless defined($sel_opdefinitions{$op});
      if (defined($arg)) {
        die "Extra argument currently only allowed for /ep/, /om/, ~hasval~" unless $op =~ /^\/(ep|om)x?\/$/ || $op =~ /~has(not)?val~/;
        if ($op eq '~hasval~' || $op eq '~hasnotval~') { $arg =~ s|^\~||; }
        else                   { $arg =~ s|^\/||; }
        $arg=urldecode($arg);
      }
      else{
         $arg = 0;
      }
      if ($op eq '~isin~' || $op eq '~isnotin~' || $op eq '~hasval~') {
         die "Dictionary [$val] not found" unless defined($::dict{$val});
      }
print STDERR "ddd adding select criterion handle=[$handle] op=[$op] val=[$val] arg=[$arg]\n" if $B_debug;
      my $indirection = 0;
      if ($val =~ s/^([\:\^])//) {
        $indirection = 1 if $1 eq ':';
      }
      if ($type eq '@')     { push    @::select, [$op, $indirection, $val, $handle, $arg]; }
      elsif ($type eq '@@') { push @::preselect, [$op, $indirection, $val, $handle, $arg]; }
      else                  { push @::assert, [$op, $indirection, $val, $handle, $arg]; }
               # NOTE. $arg optionally used /ep/ /om/ /epx/ /omx/ ~hasval~ ~hasnotval~
    }
    elsif ($spec =~ /^(.*?)(:[:=])(.*)/) {
      my ($handle, $type, $compute) = (urldecode($1), $2, $3);    # @urldecode handle::
      die "Compute cannot be empty\n" unless length($compute);
      $handle = $DUMMY_NAME++ if $handle eq '';
      my ($duplicate, $matches) = expand_list_range_and_regex($handle, 1);
      $compute = ":$compute" unless $compute =~ /^[,:^]/;
      for my $m (@$matches) {
        my $compute_m = $compute; $compute_m =~ s/:__\b/:$m->{namein}/g;
        my $parsed_compute = parse_compute($handle, $compute_m);
        push @::compute, [$m->{nameout}, $parsed_compute];
        push @::output_nm, $m->{namein} if $duplicate;            # fixme consider // duplicate combined with := assignment
        push @::output_nm, $m->{nameout} if $type eq '::';        # ':=' is assignment without output.
        $::output_nm_cmp_output{$m->{nameout}}++ if $type eq '::';
      }
    }
    elsif ($B_headless && parse_range($spec)) {
      push @::output_nm, @::colindexes;
    }
    else {
      $spec = urldecode($spec);                                               # @urldecode selection/regex-selection
      my ($unused_variable, $matches) = expand_list_range_and_regex($spec, 0);
      for my $m (@$matches) { push @::output_nm, $m->{namein}; }
    }
  }

  if ($B_assert_other) {
    die "--assert-other precludes @ selections. Use \@assert\@ only" if @::select;
    @::select = @::assert;        # Note: this is not a deep copy.
    @::assert = ();               # Weird things (beyond functionally) happen if we omit this, as entries (references) are rewritten in compile_select.
  }
}


   ## compute elements are tuples [type name Nstack coderef]

sub compile_compute {

  my %pload_references = ();

  for (my $i=0; $i<@::compute; $i++) {

    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name already defined (use -i for in-place change)\n" if defined($::handle_map{$name}) && !$B_inplace;
    my @expanded_compute = ();
    my $stack_size = 0;
    my @typestack  = ();

    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
print STDERR "ddd T=$type what=$what\n" if $B_debug;
      if ($type == $TYPE_HANDLE) {
         my ($unused_variable, $matches) = expand_list_range_and_regex($what, 0);
         for my $m (@$matches) { push @expanded_compute, [$TYPE_HANDLE, $m->{namein}]; }
         $stack_size += @$matches;
         push @typestack, (('H') x (scalar @$matches));
      }
      else {
         if ($type == $TYPE_OPATOR) {
            my $N_required    =  $cp_opdefinitions{$what}[0];
                  $N_required =  $stack_manip_RCP{$what}{require} if defined($stack_manip_RCP{$what});
            my $N_consumed    =  $N_required;
                  $N_consumed =  $stack_size if defined($stack_devour{$what});
                  $N_consumed =  $stack_manip_RCP{$what}{consume} if defined($stack_manip_RCP{$what});
            my $N_pushed      =  1;
                  $N_pushed   =  $stack_manip_RCP{$what}{push} if defined($stack_manip_RCP{$what});

            die "Stack underflow in compute [$name], operator $what" unless $stack_size >= $N_required;
            if ($what eq 'sprintf') {
               my ($N, $fmt) = get_printall_format($expanded_compute[0][1]);
$stack_size--, die "sprintf format count $N in format [$fmt] does not correspond to stack size $stack_size in compute $name" unless $N + 1 == $stack_size;
               $expanded_compute[0][1] = $fmt;
            }
            elsif ($what eq 'test') {
               my $test = $expanded_compute[-1];
               die "Operator 'test' requires third operand to be a known test (you supplied $test->[1])"
               unless $test->[0] == $TYPE_SCALAR && defined($sel_opdefinitions{$test->[1]});
            }
            elsif ($what eq 'pload') {
               die "Operator 'pload' requires option --pstore (or --group)" unless $B_pstore;
               my $test = $expanded_compute[-1];
               die "Operator 'pload' requires operand that is a column name scalar, e.g. ^2 or ^colname" unless $test->[0] == $TYPE_SCALAR;
               $::pstore_init{$test->[1]} = $PSTORE_DEFAULT;
            }
            elsif ($what eq 'sam_get') {
              my $test = $expanded_compute[-2];
              die "Operator 'sam_get' requires operand that is a column name scalar, e.g. ^NM.i or ^NM-i" unless $test->[0] == $TYPE_SCALAR;
              $test->[1] =~ s/(^..)[-.]/$1:/;            # to avoid forcing use of %3A to encode colon.
              die "Expect sam tag format XX:[AifZHB]" unless $test->[1] =~ /^..:[AifZHB]/;
            }
           $stack_size += ($N_pushed - $N_consumed);
           my ($post, $pre) = split ':', $cp_opdefinitions{$comp->[1]}[1];
if    ($what eq 'xch') { @typestack[-2,-1] = @typestack[-1,-2]; }
elsif ($what eq 'pop') { pop @typestack; }
elsif ($what eq 'dup') { push @typestack, $typestack[-1]; }
else {
  if ($pre =~ /\*/) { @typestack = (); }
  else              { $#typestack -= scalar split ',', $pre; }
  push @typestack, $post if $post;
}
print STDERR "ddd typestack @typestack\n" if $B_debug;
         }
         elsif ($type == $TYPE_SCALAR) {
           $stack_size++;
           push @typestack, 'C';
         }
         elsif ($type == $TYPE_LUSPUV) {
           $stack_size++;
           push @typestack, 'L';
         }
         push @expanded_compute, $comp;
      }
    }
print STDERR "ddd Compute named [$name] leaves stack sized $stack_size (@typestack)\n" if $B_debug;
print STDERR "=== Type annotation @typestack stack size differs from computed stack size\n" if $stack_size != @typestack;
    my $prev_what = undef;    # ugly/fixme; temporary to enforce pload compile-time check for column name presence.

    for my $comp (@expanded_compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         die "Handle [$what] in compute $name does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};     # fixme overwrite inelegant
                              # inplace NOTE. when using foo::foo^1,add, this maps the lookup for the second foo to the offset
                              # for the current foo, and the second foo no longer exists. The first foo does not have an
                              # associated offset yet ..
      }
      if ($type == $TYPE_OPATOR && $what eq 'pload') {
         $pload_references{$prev_what}++;
      }
      $prev_what = $what;
    }
    $::compute[$i] = [$name, \@expanded_compute, $stack_size];

    my $j = $::N + $i;
    $::HEADER[$j] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $j;
                              # .. inplace NOTE continued. Future lookups for foo will refer to this definition; This includes output.
                              # This process is consistently applied if multiple foo:: are specified.
print STDERR "ddd map compute name [$name] to offset $j\n" if $B_debug;
  }

  my @pload_notfound = grep { !defined($::handle_map{$_}) } keys %pload_references;
  die "'pload' argument(s) @pload_notfound not among the column names I know" if @pload_notfound;
}


sub compile_command {

  if ($::HEADER[0] eq '')   { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_'; }

  $::N = @::HEADER;
  @::INPUT_HEADER = @::HEADER;

  my $x = 0; my %in_input_header = ();
  $in_input_header{$_} = $x++ for @::INPUT_HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name}) && !$B_force;
    $::handle_map{$name} = $i;
print STDERR "ddd map header name $name to offset $i\n" if $B_debug;
  }

      # This populates
      #     @::preselect
      #     @::select
      #     @::assert
      #     @::output_nm
      #     @::compute
  &parse_spec();

  @::output_nm = sort { $a <=> $b } keys %{{ map { ($_, 1) } @::output_nm }} if $B_ko;

  $::plain_handle{$_} = 1 for @::output_nm;           # handles without compute
                                                      # but ::spec case pushes onto @::output_nm -- fixme/docme mq
                                                      # - for excision below, we grep in @::HEADER (avoding those ::spec-pushed cases)
                                                      # currently, this is the only use of plain_handle

if ($B_debug) { for (@::output_nm) { print "PH $_\t$::plain_handle{$_}\n"; } }

local $" = ','; print STDERR "ddd output column names as specified: [@::output_nm]\n" if $B_debug;

  if ($B_excise || $B_printall) {
    my @new_names = grep { !defined($in_input_header{$_}) } @::output_nm;
print STDERR "ddd new column names before -x/-A treatment: @new_names\n" if $B_debug;
    if ($B_excise) {
       @::output_nm = grep { !defined($::plain_handle{$_}) || defined($::output_nm_cmp_output{$_}) } @::INPUT_HEADER;
    }
    else {
       @::output_nm = @::HEADER;
    }
    if (defined($INSERT_OFFSET)) {
      $INSERT_OFFSET = @::output_nm if $INSERT_OFFSET > @::output_nm;
      $INSERT_OFFSET = -1 * @::output_nm if $INSERT_OFFSET < -1 * @::output_nm;
      splice @::output_nm, $INSERT_OFFSET, 0, @new_names;
    }
    else {
       push @::output_nm, @new_names;
    }
print STDERR "ddd output column names after -x/-A treatment: @::output_nm\n" if $B_debug;
  }

  { my %names = (); my $i = 1;
    for (@::output_nm) { $names{$_} = $i++ unless defined($names{$_}) }
    if (keys %names < @::output_nm) {
       my $job = $B_force ? 'leaving as specified' : 'will make unique';
print STDERR "-- Identical output column names exist ($job)\n";
       @::output_nm = sort { $names{$a} <=> $names{$b} } keys %names unless $B_force;
    }
  }

  #
  ##  Add derived column names to @::HEADER
  ##  Expand regex specifications if found.
  ##  In derived column specs replace names by offsets into field array.
  #
  #   Populate %::handle_map

  &compile_compute();

  if (defined($PSTORE_PIVOT_HANDLE)) {
     $PSTORE_PIVOT_COLUMN = $::handle_map{$PSTORE_PIVOT_HANDLE};
     die "--group argument $PSTORE_PIVOT_HANDLE not among the column names I know" unless defined($PSTORE_PIVOT_COLUMN);
  }

  if (defined($name_demux)) {
     $index_demux = $::handle_map{$name_demux};
     die "Demux column $name_demux not found" unless defined($index_demux);
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle [$name] in output does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "ddd output columns @::output_os --\n" if $B_debug;

  #
  ##  In select list replace names by offsets into field array.
  #

  &compile_select('select', \@::select, undef);

  &compile_select('preselect', \@::preselect, \%in_input_header);

  &compile_select('assert', \@::assert, undef);

  for (@::HEADER) {
    $_ = '' if $_ eq '_';
  }

  if ($B_pstore) {
     for my $pair (split ",", $PSTORE_LIST) {                  # Note empty string yields empty list with split.
        my ($k, $v) = map { urldecode($_) } split ':', $pair, -1;
        die "Name $k is not a known column handle with --pstore" unless defined($::handle_map{$k});
        die "Column $k was not supplied with a value" unless defined($v);
        $::pstore_init{$k} = $v;
     }
     for (keys %::pstore_init) { $::pstore_init{$_} = $PSTORE_DEFAULT unless defined($::pstore_init{$_}); }
     %::pstore_cache = %::pstore_init;
  }

  if ($B_posthoc_names) {
    die "New names [@::nameslist] and output offsets [@::output_os] differ in cardinality" if scalar @::nameslist != scalar @::output_os;
    @::OUTPUT_HEADER = @::nameslist;
  }
  else {
    @::OUTPUT_HEADER = map { $::HEADER[$_] } @::output_os;
  }
  if ($F_list) {
    local $, = "\t";
    if ($F_list & 4) { for (my $i=0;$i<@::output_os;$i++) { my $j = $::output_os[$i]+1; print "$j\t$::HEADER[$j-1]\n"; } }
    else {
       if ($F_list & 1) { print map { $_ + 1        } @::output_os; print "\n"; }
       if ($F_list & 2) { print map { $::HEADER[$_] } @::output_os; print "\n"; }
    }
print STDERR "-- List contains items from newly computed columns\n" if @::compute;
    exit 0;
  }
  if ($B_print_header) {
    local $, = "\t";
    if ($index_demux < 0) { print @::OUTPUT_HEADER; print "\n" }
    if ($fh_other) {
       print $fh_other @::OUTPUT_HEADER; print $fh_other "\n";
    }
  }
print STDERR "-- i_am_sam bits $I_AM_SAM\n" if $B_debug;

}


sub do_compute {

  for my $spic (@::compute) {

    my ($handle, $compute, $sz) = @$spic;
    @::STACK = ();

    for my $comp (@$compute) {

      my ($type, $what, @other) = @$comp;

         if ($type == $TYPE_HANDLE) { push @::STACK, $::Flink->[$what]; }
      elsif ($type == $TYPE_SCALAR) { push @::STACK, $what; }
      elsif ($type == $TYPE_OPATOR) {
         my ($n_wanted, $code) = @other;
         die "Stack underflow ($spic->[0] item [$what])\n" unless @::STACK >= $n_wanted;
         &{$code};
         $n_wanted--;
         $#::STACK -= $n_wanted if $n_wanted > 0;    # subs put computed element in the right place.
      }
      elsif ($type == $TYPE_LUSPUV) { push @::STACK, $::LC{suv}{$what}; }
      else { die "Really unfortunate."; }
    }
    my $size = @::STACK;
print STDERR "=== Please check compute for handle: compiled size $sz versus computed $size\n" unless $sz == $size;
    push @$::Flink, (join "", @::STACK);
  }
  die "Cp error\n" unless @::HEADER == @$::Flink;
}


sub do_cache {

  my $skip = 0;

  if (defined($PSTORE_PIVOT_COLUMN)) {
    if (!defined($PSTORE_PIVOT_VALUE) || $PSTORE_PIVOT_VALUE ne $::Flink->[$PSTORE_PIVOT_COLUMN]) {
      $PSTORE_PIVOT_VALUE = $::Flink->[$PSTORE_PIVOT_COLUMN];
      $::Ngroup++;
      $::Groupi = 2;
      $skip = 1;
    }
    else {
      $::Groupi++;
      return 0 if $B_groupfirst;     # cache is still valid, not a new group
    }
  }
  for (keys %::pstore_cache) { $::pstore_cache{$_} = $::Flink->[$::handle_map{$_}]; }
  return $skip;
}


 $::Nrows = 0;    # includes header.
$::Ngroup = 0;    # skipped because first in group: --group
my $Nskip = 0;    # skipped based on pattern; e.g. pick -/^#
my $Npthr = 0;    # skipped and passed through
my $Ndisc = 0;    # skipped because @, @@, or sam criteria not met
my $Npredisc = 0; # skipped because @@ criteria not met
my $Nsamdisc = 0; # skipped because sam setup missed sequences
my $Nkeep = 0;

$::Groupi = 2;    # index within group.

{ my @sam_qry_cache = ("no-readname", "no-refname", -1, '', '');       # Read name, refname, strand, read sequence, read quality
                                   # ^ fixme: more maintainable to stick this in LINECACHE.
  my @sam_qry_cache_prev = ();         # arrays rather than hash, a bit faster.
  my $sam_ref_sequence = '';

  sub sam_check_reflen {

    if (length($sam_refdictname)) {
      print STDERR "-- Comparing fasta sequence lengths with header information if present\n" if $L_verbose >= 0;
      my $nheader = keys %{$::dict{seqlen}};
      my $nfasta  = (keys %{$::dict{$sam_refdictname}}) - 1;        # '*' has been added by pick, compensate for this.
      my $nshared = 0;
      for my $r (sort keys %{$::dict{$sam_refdictname}}) {
        my $lfasta = length($::dict{$sam_refdictname}{$r});
        if (!defined($::dict{seqlen}{$r})) {
           print STDERR "-- [$.] setting sequence length for $r to $lfasta\n" if $L_verbose >= 2;
           $::dict{seqlen}{$r} = $lfasta;
        }
        else {
          $nshared++;
          if ((my $lsamh = $::dict{seqlen}{$r}) != $lfasta) {
            print STDERR "-- [$.] WARNING header/fasta length disagreement $lsamh/$lfasta -- picking header/$lsamh\n";
            $Nsam_lenclash++;
          }
        }
      }
      print STDERR "-- Header/Fasta/Shared/Conflict $nheader/$nfasta/$nshared/$Nsam_lenclash\n" if $L_verbose >= 0;
    }
    $I_AM_SAM ^= $BIT_SAM_CHECKLEN;   # noteme / dangersign. This unsets the bit; we are only called if the bit is set.
  }


   ## Note: ::LC{suv} adapts to all variants of alignment trailing parts representation.
   ## As default I deem it useful to normalise any exterior sequence of ISX (qry) and DX.
   ## Note that --sam-aln-context uses ISX and DX to force more context into the alignment
   ## (performed by sam_adjust_view_extend below).

  sub sam_normalform {

    if ($::Flink->[5] =~ s/^(\d+)D//) { $::Flink->[3] += $1; }
    if ($::Flink->[5] =~ s/\d+D$//)   {                    ; }

    if ($::Flink->[5] =~ s/^\d+\KI/S/) {                   ; }
    if ($::Flink->[5] =~ s/\d+\KI$/S/) {                   ; }
  }


     ## This adjustment does not affect any of the quantities computed related to
     ## trail5p, matched and trail3p (by sam_compute_suv). The view adjustment is achieved
     ## optionally changing SAM field 3 (reference position) and changing exterior parts
     ## of the CIGAR string (using X, D, I, S to affect what's output and what the alignment
     ## status is).

  sub sam_adjust_view_extend {

print STDERR "-- $::Flink->[0] cigar IN  $::Flink->[5]\n" if $B_debug;

    my $reflen   = &sam_reflen;
    my $refclipl = $::Flink->[3] - 1;      # dangersign. Do this now. We are changing $::Flink->[3] below.
    my $refclipr = $reflen - $::Flink->[3] + 1 - acigar($::Flink->[5], 'MDN=X', 'sum');   #
                                           # dangersign as above , both $::Flink->[3,5] both changed.

    my $qryclipl = $::Flink->[5] =~ /^(\d+)S/ ? $1 : 0;
    my $qryclipr = $::Flink->[5] =~ /(\d+)S$/ ? $1 : 0;

    my ($max_context_left, $max_context_right) = ($::sam_max_context, $::sam_max_context);

    if ($::sam_context_x > 0) {
      if ($::sam_context_x <= $::Flink->[3]) {
        $max_context_left = max(0, $::Flink->[3] - $::sam_context_x);
      }
    }
    if ($::sam_context_y > 0) {
      if ($::sam_context_y >= $::Flink->[3] + $reflen) {
        $max_context_right = max(0, $::sam_context_y - ($reflen - $refclipr));
      }
    }

    { my $ntrail = $max_context_left;
      my $nxshared = min($refclipl, $qryclipl, $ntrail);          # displayed together, no match ('X' symbol).

      $ntrail   -= $nxshared;
      $refclipl -= $nxshared;
      $qryclipl -= $nxshared;

      $::Flink->[3] -= $nxshared;
      $::Flink->[5] =~ s/^\d+S/$nxshared ? $nxshared . 'X' : ""/e;      # accounts for both ref and query.

      if ($refclipl > 0) {
        my $ndangle = min($refclipl, $ntrail);
        if ($ndangle > 0) {
          $::Flink->[5]  = $ndangle . 'D' . $::Flink->[5];
          $::Flink->[3] -= $ndangle;
        }
      }
      if ($qryclipl > 0) {     # bases trailing in ref are fewer than soft; add the rest as insertion.
        my $ndangle = min($ntrail, $qryclipl);
        $qryclipl  -= $ndangle;
        $::Flink->[5] = $ndangle  . 'I' . $::Flink->[5] if $ndangle  > 0;
        $::Flink->[5] = $qryclipl . 'S' . $::Flink->[5] if $qryclipl > 0;
      }
    }
    { my $ntrail = $max_context_right;
      my $nxshared = min($refclipr, $qryclipr, $ntrail);

      $refclipr -= $nxshared;
      $qryclipr -= $nxshared;
      $ntrail   -= $nxshared;

      $::Flink->[5] =~ s/\d+S$/$nxshared ? $nxshared . 'X' : ""/e;      # accounts for both ref and query.

      if ($refclipr > 0) {
        my $ndangle = min($refclipr, $ntrail);
        $::Flink->[5] .=  $ndangle . 'D' if $ndangle > 0;
      }
      if ($qryclipr > 0) {
        my $ndangle = min($qryclipr, $ntrail);
        $qryclipr -= $ndangle;
        $::Flink->[5] .=  $ndangle  . 'I' if $ndangle  > 0;
        $::Flink->[5] .=  $qryclipr . 'S' if $qryclipr > 0;
      }
    }
print STDERR "-- $::Flink->[0] cigar OUT $::Flink->[5]\n" if $B_debug;
  }

  sub cgr_sum_ref {
    my $s = 0;
    while ($_[0] =~ /(\d+)[NDM=X]/g) { $s += $1; }
    return $s;
  }

  sub cgr_sum_qry {
    my $s = 0;
    while ($_[0] =~ /(\d+)[ISM=X]/g) { $s += $1; }
    return $s;
  }

  sub cgr_nsoft {
    my $s = 0;
    while ($_[0] =~ /(\d+)S/g) { $s += $1; }
    return $s;
  }

  sub sam_compute_suv {                  # Sam Parts Unified View. Needs to be run after sam_adjust_view_extend

    my ($get_qry_parts, $get_ref_parts) = @_;
    # TODO: checks for alnedit, compare NM:i: sam field with internal calculation.

    { $::LC{suv}{ref_len} = &sam_reflen;       # note: $sam_ref_sequence is conditionally available in this (sam functionality) block.
                                          # fixme: only do this when necessary or in a different appropriately guarded place.
                                          # TODO: require soft clipping to be exterior always.

      my $t5 = $::LC{suv}{aln_trail5p_cgr} = ($::Flink->[5] =~  /^((\d+[SHDNXI])+)/  ? $1 : '' );
      my $t3 = $::LC{suv}{aln_trail3p_cgr} = ($::Flink->[5] =~   /((\d+[SHDNXI])+)$/ ? $1 : '' );
      $::LC{suv}{aln_matched_cgr} = substr($::Flink->[5], length($t5), length($::Flink->[5]) - length($t5) - length($t3));

      $::LC{suv}{qry_soft5p_N}  = cgr_nsoft($t5);
      $::LC{suv}{qry_soft3p_N}  = cgr_nsoft($t3);
      $::LC{suv}{ref_soft5p_N}  = $::Flink->[3] -1;
      $::LC{suv}{ref_soft3p_N}  = $::LC{suv}{ref_len} - $::LC{suv}{ref_soft5p_N} - cgr_sum_ref($::Flink->[5]);

      $::LC{suv}{ref_trail5p_N} = $::Flink->[3] - 1 + cgr_sum_ref($::LC{suv}{aln_trail5p_cgr});
      $::LC{suv}{ref_matched_N} = acigar($::LC{suv}{aln_matched_cgr}, 'MDN=X', 'sum');
      $::LC{suv}{ref_trail3p_N} = $::LC{suv}{ref_len} - $::LC{suv}{ref_trail5p_N} - $::LC{suv}{ref_matched_N};

      $::LC{suv}{ref_trail5p_V} = $::LC{suv}{ref_trail5p_N} - ($::Flink->[3] - 1);
      $::LC{suv}{ref_trail3p_V} = cgr_sum_ref($::LC{suv}{aln_trail3p_cgr});

                             # fixme/testme/docme. for reference, the cigar string just peters ou, so no cgr/N correspondence at 3p end.

      $::LC{suv}{ref_posx}      =  $::LC{suv}{ref_trail5p_N} + 1;
      $::LC{suv}{ref_posy}      =  $::LC{suv}{ref_posx} + $::LC{suv}{ref_matched_N} - 1;

      if ($get_ref_parts && length($sam_ref_sequence)) {
        $::LC{suv}{ref_trail5p} = substr($sam_ref_sequence, 0, $::LC{suv}{ref_trail5p_N});
        $::LC{suv}{ref_matched} = substr($sam_ref_sequence, $::LC{suv}{ref_trail5p_N}, $::LC{suv}{ref_matched_N});
        $::LC{suv}{ref_trail3p} = substr($sam_ref_sequence, $::LC{suv}{ref_trail5p_N} + $::LC{suv}{ref_matched_N});
      }
      else {
        $::LC{suv}{ref_trail5p} = '*';
        $::LC{suv}{ref_matched} = '*';
        $::LC{suv}{ref_trail3p} = '*';
      }
      # fixme/testme: where is skip/warn control if no reference sequence.
    }

    { $::LC{suv}{qry_trail5p_N} = cgr_sum_qry($::LC{suv}{aln_trail5p_cgr});
      $::LC{suv}{qry_matched_N} = acigar($::LC{suv}{aln_matched_cgr}, 'MISH=X', 'sum');
      $::LC{suv}{qry_trail3p_N} = cgr_sum_qry($::LC{suv}{aln_trail3p_cgr});

      $::LC{suv}{qry_len} = $::LC{suv}{qry_trail5p_N} + $::LC{suv}{qry_trail3p_N} + $::LC{suv}{qry_matched_N};
      my $l = length($sam_qry_cache[3]);

      if ($get_qry_parts && $l != $::LC{suv}{qry_len}) {                              # spot3 qry_len_fixme
        if ($::Flink->[5] eq '*') { $::LC{suv}{qry_len} = $l; }
        else { errm(0, "Length discrepancy sequence-length $l vs cigar-inferred $::LC{suv}{qry_len}"); }
      }

      $::LC{suv}{qry_posx}      =  $::LC{suv}{qry_trail5p_N} + 1;
      $::LC{suv}{qry_posy}      =  $::LC{suv}{qry_posx} + $::LC{suv}{qry_matched_N} - 1;

      if ($get_qry_parts && length($sam_qry_cache[3])) {
        $::LC{suv}{qry_trail5p} = substr($sam_qry_cache[3], 0, $::LC{suv}{qry_trail5p_N});
        $::LC{suv}{qry_matched} = substr($sam_qry_cache[3], $::LC{suv}{qry_trail5p_N}, $::LC{suv}{qry_matched_N});
        $::LC{suv}{qry_trail3p} = substr($sam_qry_cache[3], $::LC{suv}{qry_trail5p_N} + $::LC{suv}{qry_matched_N});
      }
      else {
        $::LC{suv}{qry_trail5p} = '*';
        $::LC{suv}{qry_matched} = '*';
        $::LC{suv}{qry_trail3p} = '*';
      }
    }
  }
                        # fixme do not attempt to lookup '*' reference (unmapped query),
                        # improve structure.
  sub sam_setup_sequences {

    my ($get_query, $get_ref) = @_;

    @sam_qry_cache_prev = @sam_qry_cache[0..4];              # no danger of using 4..6, but still.
    @sam_qry_cache = ($::Flink->[0], $::Flink->[2], $::Flink->[1] & 16 ? 1 : 0, $::Flink->[9], $::Flink->[10]);
    $sam_qry_cache[-1] =~ tr |\x21-\x7e|.....,,,,,aaaaaAAAAAbbbbbBBBBBcccccCCCCCdddddDDDDDeeeeeEEEEEfffffFFFFFgggggGGGGGhhhhhHHHHHiiii| if $I_AM_SAM & $BIT_SAM_QLT_SIM;

                    # 0     read name
                    # 1     ref name
                    # 2     reverse strand = 1
                    # 3     sequence
                    # 4     quality

    if ($sam_qry_cache[3] eq '*') {
      if ($sam_qry_cache[0] eq $sam_qry_cache_prev[0]) {     # same read name.
        $sam_qry_cache[3] = $sam_qry_cache[2] != $sam_qry_cache_prev[2] ?      rc($sam_qry_cache_prev[3]) : $sam_qry_cache_prev[3];
        $sam_qry_cache[4] = $sam_qry_cache[2] != $sam_qry_cache_prev[2] ? reverse($sam_qry_cache_prev[4]) : $sam_qry_cache_prev[4];
      }
      else {
        $sam_qry_cache[3] = '';
        $sam_qry_cache[4] = '';
      }
    }
    {  $sam_ref_sequence =  $sam_qry_cache[1] eq '*' || ! $sam_refdictname
                            ? ''
                            : ($::dict{$sam_refdictname}{$sam_qry_cache[1]} || dict_not_found($sam_refdictname, $sam_qry_cache[1]));
       my $pair = "$sam_qry_cache[0] $sam_qry_cache[1]";

       if (!$sam_ref_sequence) {
         print STDERR "-- [$.] No reference sequence for $pair\n" if $L_verbose >= 2;
         $Nsam_refmiss++;
       }
       if (!$sam_qry_cache[3]) {                                                       # spot4 qry_len_fixme
         print STDERR "-- [$.] No query sequence for $pair\n" if $L_verbose >= 2;
         $Nsam_qrymiss++;
       }
       elsif ($::Flink->[5] eq '*' || $::Flink->[2] eq '*' || ($::Flink->[1] & 4)) {
         $Nsam_qryunmapped++;
         $sam_ref_sequence = '';       # .. fixme check whether this catches all cases, or how to arrange it so that
                                       # a single check catches all cases and the implementation logic is clear.
       }
       elsif ((my $l1 = length($sam_qry_cache[3])) != (my $l2 = acigar($::Flink->[5], 'MIS=X', 'sum'))) {
         print STDERR "-- [$.] Cigar string [$::Flink->[5]] query mismatch [s=$l1 c=$l2] for $pair\n" if $L_verbose >= 1;
         $sam_ref_sequence = '';    # this will abort analysis in align_get_mismatch
         $Nsam_cigarerr++;                                                             # spot2 qry_len_fixme
       }
    }

    my ($lq, $lr) = (length($sam_qry_cache[3]), length($sam_ref_sequence));            # spot1 qry_len_fixme
    if ((!$lq && $get_query) || (!$lr && $get_ref)) {
      errm(1, "sequence missing: found query/$::Flink->[0] length $lq, ref/$::Flink->[2] length $lr");
      return 1;
    }
    return 0;
  }


    #  Alignment legend
    #
    #  M=   | indicates matching base
    #  MX   x is mismatch
    #  N    = is intronic deletion from reference.
    #  D    - is a deletion from reference.
    #  D    ` is dangling deletion from reference.
    #  I    ~ is an insertion
    #  I    _ is dangling insertion
    #  S    . unaligned dangling ref and query sequences.
    #
    # The patch penalty is measured across a sliding window; a rapid alternation
    # of short stretches of { match, mismatch, insertion, deletion } causes
    # the highest score.
    #
  BEGIN {
    my %patchy_penalty = ( '.' => 0, '|' => 0, '+' => 1, 'x' => 2, '`' => 0, '_' => 0, '-' => 1, '~' => 1, '=' => 0 );

    sub aln_patchiness2 {

      my ($string, $winsize) = @_;
      my @pos = ();
      my $score = 0;
      my $maxscore = 0;
      my $p = 0;

      $string =~ s/[()]/|/g;
      $string =~ s/ /x/g;

      while ($string =~ /((.)\2{0,})/g) {    # \2 (backreference to second parentheses pair) forces a run of the same thing

        my $type = $2;
        my $stretch = $1;
        my $len = length($stretch);
        my $fine = $patchy_penalty{$type};
        die "No type $type" unless defined($fine);

        $p += $len unless $type =~ /[\_\.\`\~\-]/;
                                             # This also excludes the case of deletion from reference [`-].
                                             # Hence the window size is not relative to reference sequence.
                                             # To be considered.

        push @pos, [$p, $fine];
        $score += $fine;

        while ($p - $pos[0][0] > $winsize) {
          my $out = shift @pos;
          $score -= $out->[1];
        }

        $maxscore = $score if $score > $maxscore;
      }
      return $maxscore;
    }

    sub aln_patchiness {

      my ($string, $winsize) = @_;
      my @pos = ();
      my $score = 0;
      my $maxscore = 0;

      $string =~ s/[()]/|/g;
      $string =~ s/ /x/g;

      while ($string =~ /((.)\2{0,})/g) {    # \2 (backreference to second parentheses pair) forces a run of the same thing

        my $pos = pos($string);

        my $type = $2;
        my $stretch = $1;
        my $len = length($stretch);
        my $fine = $patchy_penalty{$type};
        die "No type $type" unless defined($fine);

        my $p = $pos - $len;

        push @pos, [$p, $fine];
        $score += $fine;

        while ($p - $pos[0][0] > $winsize) {
          my $out = shift @pos;
          $score -= $out->[1];
        }

        $maxscore = $score if $score > $maxscore;
      }
      return $maxscore;
    }
  }

  sub align_get_matchregion {

    my ($sref, $sqry, $posref) = @_;
    my $aln= "";
    my $ls = length($sref);
    my $lt = length($sqry);
    return "" unless $ls == $lt;

    my $pos = $ls;

    while ($pos--) {
      my $sbase = chop $sref; my $tbase = chop $sqry;
      my $p = $posref + $pos + 1;
      $aln .= ($sbase eq $tbase) ? '|' : 'x';
    }
    return reverse($aln);
  }

  sub align_get_mismatch {
    my ($sref, $sqry, $posref) = @_;
    my @mm = ();
    my $ls = length($sref);
    my $lt = length($sqry);
    return -1 unless $ls == $lt;

    my $pos = $ls;
    while ($pos--) {
      my $sbase = chop $sref; my $tbase = chop $sqry;
      my $p = $posref + $pos + 1;
      push @mm, "x=$p,c=$sbase$tbase" if $sbase ne $tbase;
    }
    return reverse(@mm);
  }


  sub sam_compute_aln {

    my $qry = $sam_qry_cache[3];
    my $qlt = $sam_qry_cache[4];
    my $ref = $sam_ref_sequence;

    my $pair = "$::Flink->[0] $::Flink->[2]";

    if (!length($qry) || !length($ref)) {                                  # spot5 qry_len_fixme
      errm(0, "aln_* sequence missing", "pair $pair", "SNH");
      return 1;                                                      # this should be impossible (sam_setup_sequences is checked).
    }

    $qry =~ tr/uU/tT/;
    $ref =~ tr/uU/tT/;

    my ($aln_ref, $aln_aln, $aln_qry, $aln_qlt) = ("", "", "", "");
    my ($pqry, $sqry) = (0, 0);             # position query, start query, end query

    my $pref = $::Flink->[3]-1;        # note: the aligned part should use $::LC{suv}{ref_posx} and $::LC{suv}{aln_matched_cgr}
                                       # $::Flink->[3] and $::Flnk->[5] may have been changed to accomodate alignment context.

    my ($rlen, $qlen) = (length($ref), length($qry));

    $qlt = '!' x $qlen if length($qlt) < 2;        # fixme less casual please and nail this down. (this is cases '' and '*').

    while ($::Flink->[5] =~ m/(\d+)([MIDNSHP=X])/ig) {
      my ($num, $it) = ($1, $2);

      my $rright = $pref + $num;
      my $qright = $pqry + $num;

                  # Note I use 'X' with sam_adjust_view_extend to indicate dangling non-aligned sequence.
                  #
      if ($it eq 'M' || $it eq 'X' || $it eq '=') {
        if ($rright > $rlen || $qright > $qlen) {
          print STDERR "[$.] aln_strings cigar bound exceeded (ref $rright/$rlen qry $qright/$qlen pair $pair)\n";
          last;
        }
        my ($subref, $subqry, $subqlt) = (substr($ref, $pref, $num), substr($qry, $pqry, $num), substr($qlt, $pqry, $num));
        $aln_aln .= $it eq 'M' || $it eq '=' ? align_get_matchregion(uc $subref, uc $subqry, $pref) : '.' x $num;
        $aln_ref .= $subref;
        $aln_qry .= $subqry;
        $aln_qlt .= $subqlt;
        $pref += $num; $pqry += $num;
      }
      elsif ($it eq 'I') {
        $aln_ref .= '-' x $num;
        $aln_aln .= '~' x $num;
        $aln_qry .= substr($qry, $pqry, $num);
        $aln_qlt .= substr($qlt, $pqry, $num);
        $pqry += $num;
      }
      elsif ($it eq 'D' || $it eq 'N')  {
        $aln_qry .= '-' x $num;
        $aln_qlt .= ' ' x $num;
        $aln_aln .= ($it eq 'D' ? '-' : '=') x $num;
        $aln_ref .= substr($ref, $pref, $num);
        $pref += $num;
      }
      elsif ($it eq 'S') {
        $pqry += $num;
      }
      elsif ($it =~ /[P]/)            { print STDERR "[$.] Unexpected cigar state $it for pair $pair\n"; last; }
    }
    {  my $aln_rlr = ' ' x length($aln_ref);
       my $Oprint = -10;
       my $Nskip  = 0;
       for (my $i=0; $i<length($aln_ref); $i++) {
         my $N = $::Flink->[3] + $i - $Nskip;
         if (substr($aln_ref, $i, 1) eq '-') {
           $Nskip++;
         }
         elsif ($N % 10 == 0) {
           substr($aln_rlr, $i, length("$N")) = $N;
         }
       }
       substr($aln_rlr, length($aln_ref)) = "";

       $aln_aln =~ s/^(\~+)/'_' x length($1)/e;    # trail5p query sequence.
       $aln_aln =~ s/^(\-+)/'`' x length($1)/e;    # trail5p reference sequence.

       $aln_aln =~ s/(\~+)$/'_' x length($1)/e;    # trail3p query sequence.
       $aln_aln =~ s/(\-+)$/'`' x length($1)/e;    # trail3p reference sequence.

       if ($I_AM_SAM & $BIT_SAM_ALN_MRK) {
         $aln_ref .= '  ' . ($::LC{suv}{ref_trail5p_N} ? '<' : '[');
         $aln_ref .=         $::LC{suv}{ref_trail3p_N} ? '>' : ']';
         $aln_ref .= '  ' . join ', ', map { $::LC{suv}{$_} } qw(ref_trail5p_N ref_matched_N ref_trail3p_N);

         $aln_qry .= '  ' . ($::LC{suv}{qry_trail5p_N} ? '<' : '[');
         $aln_qry .=         $::LC{suv}{qry_trail3p_N} ? '>' : ']';
         $aln_qry .= '  ' . join ', ', map { $::LC{suv}{$_} } qw(qry_trail5p_N qry_matched_N qry_trail3p_N);
       }
       @{$::LC{suv}}{qw(aln_ref aln_aln aln_qry aln_rlr aln_qlt)} = ($aln_ref, $aln_aln, $aln_qry, $aln_rlr, $aln_qlt);
    }
    return 0;
  }


  sub get_qry  { return $sam_qry_cache[3]; } # this is in reference orientation.
  sub get_qual { return $sam_qry_cache[4]; } # this is in reference orientation.

  my %cigarchomp = (       # 1: consumes ref, 2: consumes query. 4: consumes alignment
   M => 7,
 '=' => 7,
   X => 7,
   I => 6,
   N => 5,
   D => 5,
   S => 2,
   P => 0,
   H => 0,
  );



 #    deletion           deletion         deletion          no sequence       no sequence   no sequence            trailing      |
 #     ,      ,         ,  ,                ,     ,          ,      ,         ,  ,             ,  ,                 ,      ,     |
 #  TACGTCGTACCGGTA   TACGTCGTACCGGTA   TTACCGGTACGTCGA   TACGTCGTACCGGTA   TACGTCGTACCGG    TACGTCGTACCGGTATA   TACGTCGTACCGGTA |
 #  |------||||||||   |------||||||||   ||||||||------|   ```````||||||||   -------||||||    ```````||||||||||   .......|||||||| |
 #  T------TACCGGTA   T------TACCGGTA   TTACCGGT------A   -------TACCGGTA   -------TACCGG    -------TACCGGTATA   GCTAACATACCGGTA |
 #     ^      ^         ^  ^                ^     ^          ^      ^         ^  ^             ^  ^                 ^      ^     |
 #         x  y      yx                     x  y                 x  y      yx-before del    x,y=1,0                     x  y     |
 #                                                                         ^note: x exists                        note: x forced |
 #                                                                          not a trail del                       by alignment (uu)
 #

 #                 Find offset of true alignment in stored alignment.
 #                 Refers to 'true' alignment. Stored alignment may contain trailing sequence.
 #                /
 #      ref_trail5p_N
 #    <----------------->       stored alignment (may include I D X cigar for trailing sequences)
 #                  ,----------------------------------------,
 #   ref_soft5p_N  /        ____ true alignment ____          \
 #    <---------->|       /                          \         |
 #    \___________|rrrrrr[x    r e f e r e n c e     y]rrrrrrrr|_________/          reference coordinates
 #                |                                            |
 #                |>>>>>>[x   [uu HHHHHHHHHH vv]      ]  . . . |                    alignment coordinates coord_aln_uu coord_aln_vv
 #                |       ^^^^^                                |
 #        ________|qqqqqq[       q  u  e  r  y        ]qqqqqqqq|______________      query coordinates
 #       /        |                                            |              \
 #       <------->|                                            |
 #  qry_soft_5p_N |                                            |
 #                |                                            |
 #        <-------------->
 #          qry_trail5p_N
 #

  sub ref_bounded_tally {

    my ($coord_ref_u,  $coord_ref_v)  =  map { $_ - 1; } @_;               # zero-based inclusive
    my ($coord_ref_uu, $coord_ref_vv) =  ($coord_ref_u, $coord_ref_v);     # will be updated/restricted to the alignment interval if necessary.
    my ($coord_ref_x,  $coord_ref_y)  =  ($::LC{suv}{ref_trail5p_N}, $::LC{suv}{ref_trail5p_N} + $::LC{suv}{ref_matched_N} -1);  # zero based inclusive.

    my ($coord_aln_uu, $coord_aln_vv) =  (-1, -1);
    my ($coord_qry_uu, $coord_qry_vv) =  (-1, -1);

    my $qlen = length($sam_qry_cache[3]);
    my $rlen = &sam_reflen;
    my $pair = "$::Flink->[0] $::Flink->[2]";

    $::LC{suv}{rbt_alnref} = '*';                               # The excision
    $::LC{suv}{rbt_alnaln} = '*';                               #   of the alignment
    $::LC{suv}{rbt_alnqry} = '*';                               #     corresponding
    $::LC{suv}{rbt_alnrlr} = '*';                               #       to uu and vv
    $::LC{suv}{rbt_alnqlt} = '*';                               #        .

    $::LC{suv}{rbt_refx}   =  1;
    $::LC{suv}{rbt_refy}   =  0;
    $::LC{suv}{rbt_dx}     =  0;       # adjustment needed if rbt x value less than alignment x (start) value.
    $::LC{suv}{rbt_dy}     =  0;       # adjustment needed if rbt y value greater than alignment y (end) value

    $::LC{suv}{rbt_qryx}   =  1;
    $::LC{suv}{rbt_qryy}   =  0;
    $::LC{suv}{rbt_qry}    =  '*';
    $::LC{suv}{rbt_qrylen} =  0;

    $::LC{suv}{rbt_nmatchx} =  0;
    $::LC{suv}{rbt_nmatch} =  0;
    $::LC{suv}{rbt_ndel}   =  0;
    $::LC{suv}{rbt_nins}   =  0;
    $::LC{suv}{rbt_nedit}  =  $coord_ref_v - $coord_ref_u + 1;

    if (!$qlen || !$rlen) {
      errm(-1, "sam_rbt", "sequence missing", "pair $pair", "SNH");
      return "";                                                # fixme. this return is meaningless / not picked up.
    }

    my ($aln_ref, $aln_aln, $aln_qry, $aln_rlr, $aln_qlt) = map { $::LC{suv}{$_} } qw(aln_ref aln_aln aln_qry aln_rlr aln_qlt);

    if ($coord_ref_x > $coord_ref_u || $coord_ref_y < $coord_ref_v) {
      ($coord_ref_uu, $coord_ref_vv) = (max($coord_ref_u, $coord_ref_x),  min($coord_ref_v, $coord_ref_y));
      alert(3, "sam_rbt request (0-based) adjusting [$coord_ref_u $coord_ref_v] to [$coord_ref_uu $coord_ref_vv]");
      if ($coord_ref_uu > $coord_ref_vv) {
        alert(3, "sam_rbt request (0-based) [$coord_ref_u $coord_ref_v] zero overlap with alignment bounds [$coord_ref_x $coord_ref_y], result is empty");
        $Nsam_rbtmiss++;
        return "";
      }
    }

    my $cigar = $::Flink->[5];

    my ($cur_ref_p, $cur_aln_p, $cur_qry_p) = ($::LC{suv}{ref_soft5p_N}, 0, 0);       # query soft5p N is represented in cigar string.

    while ($cigar =~ /(\d+)([MINDSHP=X])/ig) {
      my ($num, $it) = ($1, $2);

      $cur_ref_p += $num if $cigarchomp{$it} & 1;
      $cur_aln_p += $num if $cigarchomp{$it} & 4;
      $cur_qry_p += $num if $cigarchomp{$it} & 2;

      if ($coord_aln_uu < 0 && $cur_ref_p > $coord_ref_uu) {
         $coord_aln_uu  =  $cur_aln_p - ($cur_ref_p - $coord_ref_uu);
         $coord_qry_uu  =  (2 & $cigarchomp{$it}) ?  $cur_qry_p - ($cur_ref_p - $coord_ref_uu) : $cur_qry_p;
                           # if query consumed
      }

      if ($coord_aln_vv < 0 && $cur_ref_p > $coord_ref_vv) {
         $coord_aln_vv  =  $cur_aln_p - ($cur_ref_p - $coord_ref_vv);
         $coord_qry_vv  =  (2 & $cigarchomp{$it}) ?  $cur_qry_p - ($cur_ref_p - $coord_ref_vv) : $cur_qry_p - 1;
                           # if query consumed
         last;
      }
    }

    if ($coord_aln_uu >= 0 && $coord_aln_vv >= 0) {

      $::LC{suv}{rbt_alnref} = substr($aln_ref, $coord_aln_uu, $coord_aln_vv - $coord_aln_uu + 1);
      $::LC{suv}{rbt_alnaln} = substr($aln_aln, $coord_aln_uu, $coord_aln_vv - $coord_aln_uu + 1);
      $::LC{suv}{rbt_alnqry} = substr($aln_qry, $coord_aln_uu, $coord_aln_vv - $coord_aln_uu + 1);
      $::LC{suv}{rbt_alnrlr} = substr($aln_rlr, $coord_aln_uu, $coord_aln_vv - $coord_aln_uu + 1);
      $::LC{suv}{rbt_alnqlt} = substr($aln_qlt, $coord_aln_uu, $coord_aln_vv - $coord_aln_uu + 1);

      $::LC{suv}{rbt_refx}   = $coord_ref_uu + 1;
      $::LC{suv}{rbt_refy}   = $coord_ref_vv + 1;
      $::LC{suv}{rbt_dx}     = $coord_ref_uu - $coord_ref_u;
      $::LC{suv}{rbt_dy}     = $coord_ref_v - $coord_ref_vv;

      $::LC{suv}{rbt_qryx}   = $coord_qry_uu + 1;
      $::LC{suv}{rbt_qryy}   = $coord_qry_vv + 1;
      $::LC{suv}{rbt_qrylen} = $coord_qry_vv  - $coord_qry_uu + 1;
      $::LC{suv}{rbt_qry}    = substr($sam_qry_cache[3], $coord_qry_uu, $::LC{suv}{rbt_qrylen});

                        my $t = $::LC{suv}{rbt_alnaln};

      $::LC{suv}{rbt_nmatchx} = ($t =~ tr/x/x/);
      $::LC{suv}{rbt_ndel}   = ($t =~ tr/\-/\-/);
      $::LC{suv}{rbt_nins}   = ($t =~ tr/\~/\~/);

      $::LC{suv}{rbt_nmatch} = ($t =~ tr/\|/\|/) + $::LC{suv}{rbt_nmatchx};

      $::LC{suv}{rbt_nedit}  =  $::LC{suv}{rbt_ndel} + $::LC{suv}{rbt_nins} + $::LC{suv}{rbt_nmatchx};

      my $tmp = $::LC{suv}{rbt_alnqry}; $tmp =~ tr/ACGTN//cd;
      if ($tmp ne $::LC{suv}{rbt_qry}) {
         errm(-1, "sam_rbt", "result mismatch", "pair $pair", $tmp, $::LC{suv}{rbt_qry}, "SNH");
         $Nsam_rbterr++;
      }
    }
  }


  sub getalnposx {

    my $indel_report_limit = shift;
    my $qry = $sam_qry_cache[3];
    my $ref = $sam_ref_sequence;
    my $pair = "$::Flink->[0] $::Flink->[2]";

    if (!length($qry) || !length($ref)) {                               # spot6 qry_len_fixme
      errm(0, "aln_posx sequence missing", "pair $pair", "SNH");
      return "";
    }

    $qry =~ tr/acgtu/ACGTT/;
    $ref =~ tr/acgtu/ACGTT/;

    my ($pqry, $sqry) = (0, 0);             # position query, start query, end query

    my $pref = $::Flink->[3]-1;

    my ($rlen, $qlen) = (length($ref), length($qry));
    my @mismatch = ();

    while ($::Flink->[5] =~ m/(\d+)([MIDNSHP=X])/ig) {
      my ($num, $it) = ($1, $2);

      my $rright = $pref + $num;
      my $qright = $pqry + $num;

      my $pref1  = $pref + 1;

      if ($it eq 'M') {
        if ($rright > $rlen || $qright > $qlen) {
          print STDERR "[$.] getalnposx cigar bound exceeded (ref $rright/$rlen qry $qright/$qlen pair $pair)\n";
          last;
        }
        push @mismatch, align_get_mismatch(substr($ref, $pref, $num), substr($qry, $pqry, $num), $pref);
        $pref += $num; $pqry += $num;
      }
      elsif ($it eq 'I')                { push @mismatch, "i=$pref1,n=$num";
                                          $mismatch[-1] .= ',s=' . substr($qry, $pqry, $num) if !$indel_report_limit || $num <= $indel_report_limit;
                                          $pqry += $num;
                                        }
      elsif ($it eq 'D' || $it eq 'N')  { push @mismatch, ($it eq 'D' ? 'd' : 'e') . "=$pref1,n=$num";
                                          $mismatch[-1] .= ',s=' . substr($ref, $pref, $num) if !$indel_report_limit || $num <= $indel_report_limit;
                                          $pref += $num;
                                        }
      elsif ($it eq 'S')                { $pqry += $num; }
      elsif ($it =~ /[X=P]/)            { print STDERR "[$.] Unexpected cigar state $it for pair $pair\n"; last; }
    }
    return join ':', @mismatch;
  }
}

LINE:

while (<>) {

  %::LC = (  __LINE__ => $. );
  my $Nprotect_previous = $Nprotect;

  if ($F_ignore) {
    my $hit1 = ($F_ignore & 1) && /$PAT_PASS/  ? 1 : 0;
    my $hit2 = ($F_ignore & 2) && /$PAT_PURGE/ ? 1 : 0;
    if ($hit1 || $hit2) {
       if ($hit1) { print "$_"; $Npthr++; }
       $Nskip++;
       if (($F_ignore & 4) && /SN:(\S+)\s+LN:(\d+)/) {         # get sequence lengths from SAM header.
         $::dict{seqlen}{$1} = $2;
       }
       next LINE;
    }
  }

  chomp;
  my @F = length($_) ? split "\t", $_, $OFFSET_OMEGA : ("");
  $::Flink = \@F;

  if ($OFFSET_OMEGA > 0 && @F < $OFFSET_OMEGA) {
    if ($I_AM_SAM && $::Nrows < 5 && (@F < 11 || !looks_like_number($F[1]))) {
      print STDERR "Line $. does not look like SAM format [$_]\n";
      $Nskip++;
      next LINE;
    }
    push @F, ( ("") x ($OFFSET_OMEGA - @F)) ;
  }
  if (!$::Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    if (@::nameslist && !$B_posthoc_names) {
      local $" = ' ';
      die "New names [@::nameslist] and data names [@::HEADER] differ in cardinality" if scalar @::nameslist != scalar @::HEADER;
      @::HEADER = @::nameslist;
    }

    compile_command();

    $::Nrows++;                  # operators ,rowno and ,r0wno compensate if header is present.
    next LINE unless $B_headless;
  }
  else {
    my $F = @F;
    die "Header/$::N column/$F count difference at line $. (consider -R or -O<N>)" unless $F == $::N;
    $::Nrows++;
  }

  if (@::preselect) {
    my $nmatch = 0;
    for my $sel (@::preselect) {
      my ($op, $indirection, $val, $colid, $arg) = @$sel;
      $val = $F[$val] if $indirection;
      $nmatch++ if $op->($F[$colid], $val, $arg);       # $arg currently only used for /ep/, /om/, ~hasval~
    }
    if (($nmatch != @::preselect && $B_preselect_and) || ($nmatch == 0 && !$B_preselect_and)) {
      $Ndisc++; $Npredisc++;
      next LINE;
    }
  }

  if ($I_AM_SAM) {

    $::LC{suv}{input_cigar} = $F[5];

    sam_check_reflen    if     $I_AM_SAM &  $BIT_SAM_CHECKLEN;        # Done only once.
    sam_normalform      unless $I_AM_SAM &  $BIT_SAM_NONF;            # Change trailing insertions to soft clips
    sam_adjust_view_extend  if $I_AM_SAM &  $BIT_SAM_CONTEXT;         # Show trailing parts in alignment

    if ($I_AM_SAM & ($BIT_SAM_QSEQ | $BIT_SAM_RSEQ)) {                # Either query or ref sequence needed.
      if (sam_setup_sequences($I_AM_SAM & $BIT_SAM_QSEQ, $I_AM_SAM & $BIT_SAM_RSEQ)) { $Nsamdisc++; $Ndisc++; next; }
    }
    sam_compute_suv($I_AM_SAM & $BIT_SAM_QPARTS, $I_AM_SAM & $BIT_SAM_RPARTS);         # this runs always e.g. qry_trail5p_N et al
    sam_compute_aln()   if $I_AM_SAM & $BIT_SAM_ALN;
    ref_bounded_tally($::sam_rbt_x, $::sam_rbt_y) if $I_AM_SAM & $BIT_SAM_RBT_CLXY;    # --sam-rbt=x,y was used.
  }

  do_compute if @::compute;         # this pushes compute onto @F if present.

  if ($B_pstore) {
     next LINE if do_cache;
  }

  my $nmatch = 0;

  my $output = (join "\t", map { $F[$_] } @::output_os) . "\n";

  if ($B_weirdmode && $::Nrows == 1) {
    $Nkeep++;
  }
  else {
    my $k = 1;
    for my $sel (@::assert) {
      my ($op, $indirection, $val, $colid, $arg) = @$sel;
      $val = $F[$val] if $indirection;
      die "Assert $k failed for value $val at line $::Nrows\n" unless $op->($F[$colid], $val, $arg);
      $k++;
    }
    if ($B_protect_discard && $Nprotect_previous != $Nprotect) {
      $Ndisc++;
      $Nprotect_discard++;
      print $fh_other $output if $fh_other;
      demux_do_row($F[$index_demux], $output, 0) if $index_demux >= 0;
      next LINE;
    } 
    for my $sel (@::select) {
      my ($op, $indirection, $val, $colid, $arg) = @$sel;
      $val = $F[$val] if $indirection;
      $nmatch++ if $op->($F[$colid], $val, $arg);       # $arg currently only used for /ep/ and /om/
    }
    if (@::select && (($nmatch != @::select && $B_select_and) || ($nmatch == 0 && !$B_select_and))) {
      $Ndisc++;
      print $fh_other $output if $fh_other;
      demux_do_row($F[$index_demux], $output, 0) if $index_demux >= 0;
      next LINE;
    }
    else {
      $Nkeep++;
    }
  }

  next LINE if $B_count;      # $Nkeep is the only thing that interests us.

  if ($index_demux >= 0) { demux_do_row($F[$index_demux], $output, 1); }
  else                   { print $output; }

  if ($progress1 && $::Nrows % $progress1 == 0) {
    print STDERR '.';
    printf STDERR " %9d\n", $::Nrows if $progress2 && $::Nrows % ($progress1 * $progress2) == 0;
  }
}

print STDERR "\n" if $progress1;


if ($B_count) { print "$Nkeep\n"; }
my $Npostdisc = $Ndisc - $Npredisc;

if ($I_AM_SAM) { print STDERR "-- $Nskip header lines in input (passed through $Npthr)\n" if $F_ignore && $L_verbose >= 1; }
else           { print STDERR "-- $Nskip skipped lines in input (passed through $Npthr)\n" if $F_ignore && $L_verbose >= 1; }
print STDERR "-- $Npredisc/$Npostdisc rows have been pre/post-discarded\n" if @::preselect && $L_verbose >= 1;
print STDERR "-- $Nsamdisc sam rows have been discarded because of missing sequence(s)\n" if $Nsamdisc > 0 && $L_verbose >= 0;
print STDERR "-- $Nkeep/$Ndisc rows have been kept/discarded\n" if (@::preselect || @::select) && $L_verbose >= 1;
print STDERR "-- $::Ngroup groups of rows were processed\n" if defined($PSTORE_PIVOT_COLUMN) && $L_verbose >= 1;
print STDERR "-- $Nprotect items needed not-a-number protection ($Nprotect_discard rows discarded)\n" if $Nprotect;

print STDERR "-- $Nsam_refmiss times a reference sequence was not found\n" if $Nsam_refmiss;
print STDERR "-- $Nsam_qrymiss times a query sequence was not available\n" if $Nsam_qrymiss;
print STDERR "-- $Nsam_qryunmapped times a query sequence was unmapped\n" if $Nsam_qryunmapped;
print STDERR "-- $Nsam_lenmiss times a reference sequence length lookup failed\n" if $Nsam_lenmiss;
print STDERR "-- $Nsam_lenclash times a reference sequence difference between SAM header and fasta file $sam_refdictname\n" if $Nsam_lenclash;
print STDERR "-- $Nsam_cigarerr times a cigar string did not match the query sequence\n" if $Nsam_cigarerr;
print STDERR "-- $Nsam_rbtmiss times a region bound tally query (sam_rbt) had zero overlap\n" if $Nsam_rbtmiss;
if ($Nsam_rbterr) {
   print STDERR "-- $Nsam_rbterr times a query rbt bound did not match the alignment extraction\n";
   exit 1 unless $B_force;
}

my $B_header = 1 - $B_headless;
print STDERR "== Line tally check failed: ($::Nrows != $B_header+$Nkeep+$Ndisc+$::Ngroup)\n" if $::Nrows != $B_header+$Nkeep+$Ndisc+$::Ngroup;

if ($N_expect >= 0 && $N_expect != $Nkeep) {
   print STDERR "== Expected number $N_expect but pick found $Nkeep\n";
   exit 1;
}

if ($B_assert_other && $Npostdisc) {
   print STDERR "== $Npostdisc rows failed one or more assertions\n";
}

demux_tally() if $index_demux >= 0;

if (@::preselect && !$B_select_and && !@::select) {
   print STDERR "---> You've used -o with @@ preselection, did you want -s? <---\n";
}


