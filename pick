#!/usr/bin/perl

  #                     Copyright (c) 2022-2023  Stijn van Dongen
  #      
  #      Permission is hereby granted, free of charge, to any person obtaining a copy
  #      of this software and associated documentation files (the "Software"), to deal
  #      in the Software without restriction, including without limitation the rights
  #      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  #      copies of the Software, and to permit persons to whom the Software is
  #      furnished to do so, subject to the following conditions:
  #      
  #      The above copyright notice and this permission notice shall be included in all
  #      copies or substantial portions of the Software.
  #      
  #      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  #      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  #      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  #      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  #      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  #      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  #      SOFTWARE.

use strict;
use warnings;
use Digest::MD5 qw(md5_hex);
use POSIX;

       ##                                                                               ##
      ##      Pick columns and select rows from tabular input, add derived columns       ##
     ##                 Pick and select either by column name or index                    ##
    ##                 Add new columns, update existing columns in-place                   ##
    ##    Select with numerical and string comparison operators and regular expressions    ##
     ##               Select on either existing columns or derived columns                ##
      ##           Compute derived columns with string and arithmetic operations         ##
       ##                        Add or change column names                             ##
        ##             Select column names using regular expressions                   ##
        ##                                                                             ##
       ##                        Requires tab separated input                           ##
      ##                 See -H (EOH below) and -l (brief help)                          ##

@::spec = @ARGV; @ARGV = ();

sub helphelp {
   my $status = shift;
   print STDERR "Use -l (list) for concise help, -H for long help, -h suppresses header line output\n";
   print STDERR "Pick only works as a pipe, so invoke e.g. as: pick foo bar < data.txt\n";
   exit $status;
}

helphelp(0) unless @::spec;

@::output_nm  = ();         # names - (header|1..N) + compute handles
@::output_os  = ();         # names translated to offsets in @F (field array)
@::compute = ();            # derived column specifications
@::select  = ();            # row select specifications
%::handle_map = ();         # map column names to offsets
%::plain_handle = ();       # handles without any compute following.

my $PAT_PURGE      = '';    # ::/my style is somewhat intractable. :: tend to be thing accessed in subroutines.
my $PAT_PASS       = '';    # PURGE is removed before processing, PASS is passed through before processing.
my $INSERT_OFFSET  = undef; # with -A, where to put extra columns (by default at the end).
my $OFFSET_OMEGA   = -1;    # with -O<N>, accept overflow ragged columns from position <N> onwards.

my $B_print_header = 1;     # B_oolean. Also accessed in subroutines.
my $B_select_and   = 1;     # Require all selections to match (use -o for any)
my $B_print_tally  = 0;     # Print trailing T column with count of selections matched
my $B_printall     = 0;     # Select all columns
my $B_inplace      = 0;     # Allow derived column to redefine existing column name
my $B_excise       = 0;     # print all except the plain column handles listed, cannot combine with $B_printall
my $B_add_row_column = 0;   # See -H, EOH
my $B_headless     = 0;     # No header (-k option)
my $B_ko           = 0;     # With -k, make output columns unique and ordered as in output.
my $B_sprouthead   = 0;     # Create header e.g. from derived names
my $B_weirdmode    = 0;     # Header exists, but users wants to use numbers (turns of selections for header)
my $B_force        = 0;     # Force output if identical output names exist
my $M_ignore       = 0;     # M_ode (bits): 0 oblivious, 1 pass, 2 purge, 4 read sam sequence lengths SN:(\S+)\s+LN:(\d+)
my $B_debug        = 0;     # Mostly documents the stages of compute and selection definitions
my $B_verbose      = 0;     # Not terrifically interesting
my $B_add_names    = 0;     # If other names are given, whether to output them as column names
my $B_regex        = 1;     # Whether to interpret names as a regular expression if one of the characters in $REGEXP_CHARS is found
my $B_protect      = 0;     # Some protection against divide-by-zero; modifiable with PICK_*_INF environment variables.
my $B_count        = 0;     # Only output count of kept rows.
my $N_expect       = -1;    # If set, exit with error if number of non-header rows that is output is different.

$::EPSILON         = 0.0001;  # obvs the best default epsilon - 10,000 is a myriad.
$::OOM             = 2;     # order of magnitude. Maybe sqrt(2) makes more sense.

my $REGEXP_CHARS   = '[({\\\*?^$';
my $DUMMY_NAME     = 'AAAAA';

sub stacky { die "$_[0] stack error\n" unless @::STACK >= $_[1]; }

my %PNAN =                  # Protect against division by zero etc. Defaults exist and can be overridden.
(  PICK_LOG10_INF => 10000
,  PICK_LOG2_INF  => 10000
,  PICK_LOG_INF   => 10000
,  PICK_TAN_INF   => 'inf'
,  PICK_DIV_INF   => '-'
)  ;
for (keys %PNAN) { $PNAN{$_} = $ENV{$_} if defined($ENV{$_}); }

                            # Nearly all of the below push 1 item on the stack after consuming X.
                            # Only X is specified; X = 0 indicate exceptional cases.
                            # Potentially neatify this by adding Y (number of pushed items).
my %cp_opdefinitions =
   ( add       => [ 2, sub { $::STACK[-2] += $::STACK[-1] }, "x y\tx+y\tAdd x and y, sum, addition\tarithmetic" ],
     addall    => [ 0, sub { my $x = 0; $x += $_ for @::STACK; @::STACK = ($x) }, "*\tsum(Stack)\tSum of all entries in stack\tarithmetic/devour" ],
     mulall    => [ 0, sub { my $x = 1; $x *= $_ for @::STACK; @::STACK = ($x) }, "*\tproduct(Stack)\tProduct of all entries in stack, multiplication\tarithmetic/devour" ],
     maxall    => [ 0, sub { my $x = -POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ > $x }; @::STACK = ($x) }, "*\tmax(Stack)\tMax over all entries in stack\tarithmetic/devour" ],
     minall    => [ 0, sub { my $x =  POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ < $x }; @::STACK = ($x) }, "*\tmin(Stack)\tMin over all entries in stack\tarithmetic/devour" ],
     joinall   => [ 1, sub { my $j = pop(@::STACK); my $x = join $j, @::STACK; @::STACK = ($x) }, "* s\tStack-joined-by-s\tStringified stack with s as separator\tstring/devour" ],
     mul       => [ 2, sub { $::STACK[-2] *= $::STACK[-1] }, "x y\tx*y\tMultiply x and y, multiplication, product\tarithmetic"  ],
     div       => [ 2, sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? $x / $y : $PNAN{PICK_DIV_INF} }, "x y\tx/y\tDivision, fraction, (cf -P and PICK_DIV_INF)\tarithmetic" ],
     idiv      => [ 2, sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? ($x-($x % $y))/$y : $PNAN{PICK_DIV_INF} }, "x y\tx // y\tInteger division, divide (cf -P and PICK_DIV_INF)\tarithmetic" ],
     cat       => [ 2, sub { $::STACK[-2] .= $::STACK[-1] }, "x y\txy\tConcatenation of x and y\tstring" ],
     sub       => [ 2, sub { $::STACK[-2] -= $::STACK[-1] }, "x y\tx-y\tSubtract y from x, subtraction\tarithmetic" ],

     pop       => [ 0, sub { stacky('pop', 1); pop @::STACK }, "x\t-\tRemove top entry x from stack\tstack" ],
     dup       => [ 0, sub { stacky('dup', 1); push @::STACK, $::STACK[-1] }, "x\tx x\tDuplicate top entry x\tstack" ],
     xch       => [ 0, sub { stacky('xch', 2); ($::STACK[-2], $::STACK[-1]) = ($::STACK[-1], $::STACK[-2]) }, "x y\ty x\tExchange x and y\tstack" ],
     rowno     => [ 0, sub { push @::STACK, $::Nrows -1+$B_headless }, "-\tx\tPush current table row number x onto stack\tinput" ],
     lineno    => [ 0, sub { push @::STACK, $.      }, "-\tx\tPush file line number x onto stack\tinput" ],

     mod       => [ 2, sub { $::STACK[-2] %= $::STACK[-1] }, "x y\tx mod y\tx modulo y, remainder\tarithmetic" ],
     pow       => [ 2, sub { $::STACK[-2] **= $::STACK[-1] }, "x y\tx**y\tx raised to power y\tarithmetic" ],
     and       => [ 2, sub { $::STACK[-2] &= int($::STACK[-1]) }, "x y\tx and y\tBitwise and between x and y\tbitop" ],
     or        => [ 2, sub { $::STACK[-2] |= int($::STACK[-1]) }, "x y\tx or y\tBitwise or between x and y\tbitop"  ],
     xor       => [ 2, sub { $::STACK[-2] ^= int($::STACK[-1]) }, "x y\tx xor y\tBitwise exclusive or between x and y\tbitop"  ],
     max       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] > $::STACK[-2] }, "x y\tmax(x,y)\tMaximum of x and y\tarithmetic" ],
     min       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] < $::STACK[-2] }, "x y\tmin(x,y)\tMinimum of x and y\tarithmetic" ],
     dd        => [ 2, sub { $::STACK[-2] = sprintf("%.*f", $::STACK[-1], $::STACK[-2]) }, "x N\tx'\tFloating point x printed with N decimal digits\tmath/format/precision" ],
     sn        => [ 2, sub { $::STACK[-2] = sprintf("%.*e", $::STACK[-1], $::STACK[-2]) }, "x N\tx'\tFloating point x in scientific notation with N decimal digits\tmath/format/precision" ],
     zp        => [ 2, sub { my $l = $::STACK[-1] - length($::STACK[-2]); $l = 0 if $l < 0; $::STACK[-2] = '0' x $l . $::STACK[-2] }, "x N\tx'\tx left zero-padded to width of N\toutput" ],

     get       => [ 2, sub { my $item =  $::STACK[-2] =~ qr/$::STACK[-1]/
                                         ? (defined($1) ? $1 : $&) : ""; $::STACK[-2] = $item; }, "x r\tr-match-of-x\tIf x matches regex r take outer () group or entire match, empty string otherwise (cf uie)\tstring/regex" ],
     uie       => [ 2, sub { $::STACK[-2] = $::STACK[-1] unless length($::STACK[-2])}, "x y\tx-or-y\tUse x if not empty, otherwise use y\tstring" ],

     cgsum     => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'sum') }, "c s\tSum of s in c\tSum of lengths of s items in cigar string c\tstring/sam" ],
     cgmax     => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'max') }, "c s\tMax of s in c\tMax of lengths of s items in cigar string c\tstring/sam" ],
     cgcount   => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'count') }, "c s\tCount of s in c\tCount of s items in cigar string c\tstring/sam" ],
     cgrefcov  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MDN=X', 'sum') }, "c\trefcov\tCount of reference bases covered by cigar string c (MDN=X events)\tstring/sam" ],
     cgqrycov  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MI=X', 'sum') }, "c\tqrycov\tCount of query bases covered by cigar string c (MI=X events)\tstring/sam"  ],
     cgqrylen  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MISH=X', 'sum') }, "c\tqrylen\tLength of query (MIS=X events) in cigar string c\tstring/sam" ],
     cgqryend  => [ 1, sub { my $e = acigar($::STACK[-1], 'MISH=X', 'sum'); $e -= $1 if $::STACK[-1] =~ /(\d+)[SH]$/; $::STACK[-1] = $e }, "c\tqryend\tLast base considered aligned in query for cigar string c\tstring/sam" ],
     cgqrystart=> [ 1, sub { my $s = 1; $s += $1 if $::STACK[-1] =~ /^(\d+)[SH]/; $::STACK[-1] = $s }, "c\tqrystart\tFirst base considered aligned in query for cigar string c\tstring/sam" ],

     ed        => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/  }, "x p s\tx =~ s/p/s/\tSubstitute pattern p by s in x\tstring/regex" ],
     edg       => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/g }, "x p s\tx =~ s/p/s/g\tGlobally substitute pattern p by s in x\tstring/regex" ],
     del       => [ 2, sub { $::STACK[-2] =~ s/$::STACK[-1]// }, "x p\tx =~ s/p//\tDelete pattern p in x\tstring/regex" ],
     delg      => [ 2, sub { $::STACK[-2] =~ s/$::STACK[-1]//g }, "x p\tx =~ s/p//\tGlobally delete pattern p in x\tstring/regex" ],
     map       => [ 2, sub {  my ($x, $d) = @::STACK[-2,-1];
                              my $dict = $::dict{$d};
                              my $m = defined($dict) ? $dict->{$x} : undef;
                              if (defined($m)) { $::STACK[-2] = $m; }
                              elsif (defined($::dictnotfound{$d})) { $::STACK[-2] = $::dictnotfound{$d} }
                           },
                           "x dname\tmap-of-x\tUse map of x in dictionary dname (if found; cf --cdict-dname= --fdict-dname=)\tstring/dictionary"
                  ],
     substr    => [ 3, sub { $::STACK[-3] =  substr($::STACK[-3], $::STACK[-2], $::STACK[-1]) }, "x i k\tx[i:i+k-1]\tSubstring of x starting at i (zero-based) of length k\tstring" ],
     pct       => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y ? sprintf("%.*f", $n, $x * 100 / $y) : $PNAN{PICK_DIV_INF} }, "x y N\tpct(x/y)\tPercentage of x relative to y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],
     pml       => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y ? sprintf("%.*f", $n, $x * 1000 / $y) : $PNAN{PICK_DIV_INF} }, "x y N\tpct(x/y)\tPromille of x relative to y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],
     frac      => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y ? sprintf("%.*f", $n, $x / $y) :  $PNAN{PICK_DIV_INF}}, "x y N\tx/y\tDivision, fraction x/y with N decimal digits (cf -P and PICK_DIV_INF)\tprecision/format" ],

     tobin     => [ 1, sub { $::STACK[-1] = sprintf("%b", $::STACK[-1]) }, "x\tx'\tBinary representation of x\tformat" ],
     tohex     => [ 1, sub { $::STACK[-1] = sprintf("%x", $::STACK[-1]) }, "x\tx'\tHex representation of x\tformat"  ],
     tooct     => [ 1, sub { $::STACK[-1] = sprintf("%o", $::STACK[-1]) }, "x\tx'\tOctal representation of x\tformat"  ],
     binto     => [ 1, sub { $::STACK[-1] = oct("0b$::STACK[-1]") }, "x\tx'\tRead binary representation x\tinput/format" ],
     hexto     => [ 1, sub { $::STACK[-1] = hex($::STACK[-1]) }, "x\tx'\tRead hex representation x\tinput/format" ],
     octto     => [ 1, sub { $::STACK[-1] = oct($::STACK[-1]) }, "x\tx'\tRead octal representation x\tinput/format" ],
     urldc     => [ 1, sub { $::STACK[-1] = urldecode($::STACK[-1]) }, "x\turldc(x)\tUrl decoding of x\tstring/format/input/output" ],
     urlec     => [ 1, sub { $::STACK[-1] = urlencode($::STACK[-1]) }, "x\turlec(x)\tUrl encoding of x\tstring/format/input/output" ],
     incr      => [ 1, sub { $::STACK[-1]++ }, "x\tx++\tx incremented by one\tarithmetic" ],
     decr      => [ 1, sub { $::STACK[-1]-- }, "x\tx--\tx decremented by one\tarithmetic" ],
     uc        => [ 1, sub { $::STACK[-1] = uc($::STACK[-1]) }, "x\tuc(x)\tUpper case of x\tstring" ],
     lc        => [ 1, sub { $::STACK[-1] = lc($::STACK[-1]) }, "x\tuc(x)\tLower case of x\tstring" ],
     rev       => [ 1, sub { $::STACK[-1] = reverse($::STACK[-1]) }, "x\trev(x)\tString reverse of x\tstring" ],
     rot13     => [ 1, sub { $::STACK[-1] =~ tr/a-zA-Z/n-za-mN-ZA-M/ }, "x\trot13(x)\tRot13 encoding of x\tcrypto"  ],
     md5       => [ 1, sub { $::STACK[-1] = md5_hex($::STACK[-1]) }, "x\tmd5(x)\tMD5 sum of x\tstring/format/input/output"     ],
     len       => [ 1, sub { $::STACK[-1] = length($::STACK[-1]) }, "x\tlen(x)\tLength of string x\tstring" ],
     rc        => [ 1, sub { $::STACK[-1] =~ tr/acgtuACGTU/tgcaaTGCAA/; $::STACK[-1] = reverse($::STACK[-1]) }, "x\trc(x)\tReverse complement\tstring" ],
     abs       => [ 1, sub { $::STACK[-1] = abs($::STACK[-1]) }, "x\tabs(x)\tAbsolute value of x\tmath" ],
     sqrt      => [ 1, sub { $::STACK[-1] = sqrt($::STACK[-1]) }, "x\tsqrt(x)\tSquare root of x\tmath" ],
     sq        => [ 1, sub { $::STACK[-1] = $::STACK[-1]**2 }, "x\tx^2\tSquare of x\tmath" ],
     exp       => [ 1, sub { $::STACK[-1] = exp($::STACK[-1]) }, "x\te**x\tExponential function applied to x\tmath" ],
     cos       => [ 1, sub { $::STACK[-1] = cos($::STACK[-1]) }, "x\tcos(x)\tCosine of x\tmath" ],
     sin       => [ 1, sub { $::STACK[-1] = sin($::STACK[-1]) }, "x\tsin(x)\tSine of x\tmath" ],
     tan       => [ 1, sub { my $c = cos($::STACK[-1]); $::STACK[-1] = !$B_protect || $c ? sin($::STACK[-1])/$c : $PNAN{PICK_TAN_INF} }, "x\ttan(x)\tTangens of x\tmath" ],
     log       => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1]) : $PNAN{PICK_LOG_INF}}, "x\tlog(x)\tNatural logarithm of x\tmath" ],
     log10     => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1])/log(10) : $PNAN{PICK_LOG10_INF} }, "x\tlog10(x)\tLogarithm of x in base 10\tmath" ],
     log2      => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1])/log(2)  : $PNAN{PICK_LOG2_INF} },  "x\tlog2(x)\tLogarithm of x in base 2\tmath" ],
     exp10     => [ 1, sub { $::STACK[-1] = 10**$::STACK[-1] }, "x\t10^x\t10 to the power of x\tmath" ],
     sign      => [ 1, sub { $::STACK[-1] = $::STACK[-1] > 0 ? 1 : $::STACK[-1] < 0 ? -1 : 0 }, "x\tsign(x)\tThe sign of x (-1, 0 or 1)\tmath" ],
     ceil      => [ 1, sub { $::STACK[-1] = ceil($::STACK[-1]) }, "x\tceil(x)\tThe ceil of x\tmath" ],
     floor     => [ 1, sub { $::STACK[-1] = floor($::STACK[-1]) }, "x\tfloor(x)\tThe floor of x\tmath" ],
     int       => [ 1, sub { $::STACK[-1] = int($::STACK[-1]) }, "x\tint(x)\tx truncated towards zero (do not use for rounding)\tmath" ],
     F0        => [ 0, sub { push @::STACK, $::Flink->[0] }, "-\tF[0]\tFirst input column\tdemo" ],

   );

sub sam_reflen {
  my $x = $::dict{seqlen}{$::Flink->[2]};
  if (!defined($x)) {
    $x=$::dictnotfound{seqlen};
    print STDERR "No length for $::Flink->[2]\n";
  }
  return $x;
}

my %cp_samdefs = (
     refcov    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MDN=X', 'sum') }, "-\trefcov\tAmount of reference covered by alignment\tsam" ],
     refstart  => [ 0, sub { push @::STACK, $::Flink->[3] }, "-\trefstart\tField 4 from sam format\tsam" ],
     refend    => [ 0, sub { push @::STACK, $::Flink->[3] + acigar($::Flink->[5], 'MDN=X', 'sum') - 1 }, "-\trefend\tLast base in reference covered by alignment\tsam" ],
     reflen    => [ 0, sub { push @::STACK, &sam_reflen }, "-\treflen\tLength of reference sequence (requires samtools view -h)\tsam" ],

     qrycov    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MI=X', 'sum') }, "-\tqrycov\tAmount of query covered by alignment\tsam" ],
     qrystart  => [ 0, sub { my $s = 1; $s += $1 if $::Flink->[5] =~ /^(\d+)[SH]/; push @::STACK, $s }, "-\tqrystart\tStart of alignment in query\tsam" ],
     qryend    => [ 0, sub { my $e = acigar($::Flink->[5], 'MISH=X', 'sum'); $e -= $1 if $::Flink->[5] =~ /(\d+)[SH]$/; push @::STACK, $e }, "-\tqryend\tLast base in query covered by alignment\tsam" ],
     qrylen    => [ 0, sub { push @::STACK, acigar($::Flink->[5], 'MISH=X', 'sum') }, "-\tqrylen\tLength of query sequence\tsam" ],

     refclipl  => [ 0, sub { push @::STACK, $::Flink->[3] -1 }, "-\trefclipl\tNumber of 5p trailing reference bases\tsam" ],
     refclipr  => [ 0, sub { push @::STACK, &sam_reflen - $::Flink->[3] + 1 - acigar($::Flink->[5], 'MDN=X', 'sum')}, "-\trefclipr\tNumber of 3p trailing reference bases\tsam" ],

     qryclipl  => [ 0, sub { my $n = 0; $n = $1 if $::Flink->[5] =~ /^(\d+)[SH]/; push @::STACK, $n }, "-\tqryclipl\tNumber of 5p trailing query bases\tsam" ],
     qryclipr  => [ 0, sub { my $n = 0; $n = $1 if $::Flink->[5] =~ /(\d+)[SH]$/; push @::STACK, $n }, "-\tqryclipr\tNumber of 3p trailing query bases\tsam" ]

            # TODO: deduplicate qrystart/clipl and qryend/clipr code. e.g. use acigar/linecache, keys L R?
   );

            # sub { } :
            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
            # For /ep/ and /om/ third argument is $::EPSILON/$::OOM or specified suffix.
            # 40 41 etc just to keep sort order when outputting list of select ops,
            # as '/' is overloaded in a slightly confusing way (negation and num op delimiter),
            # as is '~' (matching and string op delimiter). This keeps them grouped together.
            #
my %sel_opdefinitions = (
  '~'          => [ 40, sub { $_[0] =~ /$_[1]/ } ],
  '/~'         => [ 41, sub { $_[0] !~ /$_[1]/ } ],
  '='          => [ 42, sub { $_[0]  eq $_[1]  } ],
  '/='         => [ 43, sub { $_[0]  ne $_[1]  } ],

  '/eq/'       => [ 44, sub { $_[0] == $_[1] } ],
  '/ne/'       => [ 45, sub { $_[0] != $_[1] } ],
  '/lt/'       => [ 46, sub { $_[0] <  $_[1] } ],
  '/le/'       => [ 47, sub { $_[0] <= $_[1] } ],
  '/ge/'       => [ 48, sub { $_[0] >= $_[1] } ],
  '/gt/'       => [ 49, sub { $_[0] >  $_[1] } ],

  '/ep/'       => [ 50, sub { interval_plus(@_)} ],      # epsilon
  '/om/'       => [ 51, sub { interval_mul(@_) } ],      # order of magnitude

  '~eq~'       => [ 52, sub { $_[0] eq $_[1] } ],
  '~ne~'       => [ 53, sub { $_[0] ne $_[1] } ],
  '~lt~'       => [ 54, sub { $_[0] lt $_[1] } ],
  '~le~'       => [ 55, sub { $_[0] le $_[1] } ],
  '~ge~'       => [ 56, sub { $_[0] ge $_[1] } ],
  '~gt~'       => [ 57, sub { $_[0] gt $_[1] } ],

     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/'      => [ 58, sub { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) } ],
  '/any/'      => [ 59, sub { abs(int($_[0])) & abs(int($_[1])) } ],
  '/none/'     => [ 60, sub { ! (abs(int($_[0])) & abs(int($_[1]))) } ]

);

my $envsettings = join "\n", map { sprintf("  %-20s %8s", $_, $PNAN{$_}) } keys %PNAN;
my $opsections  = 'arithmetic bitop devour dictionary format input math output precision regex sam stack string';

my $help_options=q{Options:
  -h do not print header
  -o OR multiple select criteria (default is AND)
  -x take complement of selected input column(s) (works with -i)
  -i in-place: <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -/<pat>  skip lines matching <pat>; use e.g. -/^# for commented lines, -/^@ for sam files
  -//<pat> pass through lines matching <pat>
     <pat> allows perl regular expressions, e.g. ^ $ . [] * ? (|) work.
  -v verbose

  -A print all input columns (selecting by colspec applies, -T accepted)
  -A<N> <N> integer; insert new columns at position <N>. Negative <N> is relative to rightmost column.
  -O<N> <N> integer; allow ragged input (e.g. SAM use -O12), merge all columns at/after position <N>
  -E<N> <N> integer; expect <N> rows returned, exit with error if this is not the case.
  -T do not select, print tally column of count of matched row select criteria (name T)
  -P protect against 'nan' and 'inf' results (see -H for environment variables PICK_*_INF)

  -k headerless input, use 1 2 .. for input column names
     x-y for range from x to y
     a+x-y*k for range from a + k*x to a+y*k with incrementes of k 
  -K headerless input, as above, use derived names to output column names
  -U with -k and -K keep output columns unique and in original order

  -R add _ column variable if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically
  -f force processing (allows both identical input and output column names)
  -F fixed names; do not interpret names as regular expressions.
     Default behaviour is to assume a regular expression if a name contains one of ^ $ [ \{ ( \ * ?
  -W (weird mode) header exists but use 1 2 .. for column names (selection not applied to header)
    1. consider using a=longcolumnname b=longercolumname; pick $a $b @$b/gt/0 @$a/lt/0 < data.txt
    2. consider using --inames=CSV (see below; this will change names in the output)

  -z  ARG+ print url-encoding of ARG+  (no argument prints a few especially useful cases)
  -zz ARG+ print url-decoding of ARG+
  -l or -l <string> list operators (matching section string if specified)
     sections: } . $opsections . q{

  -H Longer pick description

  --inames=CSV       comma-separated values to use as column names instead of actual column names.
  --add-inames=CSV   The list must cover all columns in the input. Names that are used
                     in selection, compute and filter expressions must be picked from this list.
                     Output names are from the list. If using -k --inames=CSV provides temporary
                     handles; use --add-inames=CSV to add them to the output.

  --fdict-NAME=fname fname should be two-column tab-separated file storing key and value per line.
                     This stores a dictionary called NAME that can be used to map values
                     with ...^NAME,map. Small dictionaries can be encoded on the command line with
  --cdict-NAME=<csv> where <csv> is a comma separated string of key:value pairs -- after splitting
                     on commas and colons all keys and values are url-decoded. Example usage:
       echo -e "a\t3\nb\t4" | pick -Aik --cdict-foo=a:Alpha,b:Beta 1::1^foo,map

  Short options combine, e.g. -ok/^@ for headerless input, comments indicated by ^@, OR selection.
  -AT is useful for inspecting/checking select criteria
  use -Ai <name>::<COMPUTE> to change column <name> to <COMPUTE>,
  use -Aik <num>::<COMPUTE> to change column <num> to <COMPUTE>.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (column name, index, or derived compute name)
  (2) @<HANDLE><op><VAL>       select criterion compare handle to constant value with <op>
  (3) @<HANDLE><op>:<HANDLE2>  select criterion compare handle to other handle with <op>
  (4) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output

  COMPUTE: <part>+ where <part> is one of ^<value> :<handle> ,<operator>
  Later computes have access to HANDLEs that were computed before.

  HANDLE, VAL and handles and values in COMPUTE are all URL-decoded.
  URL-encoding is generally necessary for characters in [%:^/,~]. Use pick -z <string>
  to find the url-encoding of <string> .};

my @opsf = sort { $sel_opdefinitions{$a}[0] <=> $sel_opdefinitions{$b}[0] } keys %sel_opdefinitions;
my $nameslist = "";

%::dict = ();
%::dictnotfound = ();

sub read_dict {
   my ($name, $fname) = @_;
   open(D, "<$fname") || die "cannot open $fname for dictionary reading";
   my $n_novalue = 0;
   while(<D>) {
      chomp; my @F = split "\t";
      my $value = 1;
      if (@F >= 2) { $value = $F[1]; } else { $n_novalue++; }
      $::dict{$name}{$F[0]} = $value;
   } close(D);
   my $n = keys %{$::dict{$name}};
print STDERR "-- dictionary $name has $n keys after reading $fname\n" if $B_verbose;
print STDERR "-- dictionary $name has $n_novalue keys set to value 1\n" if $B_verbose && $n_novalue;
}

sub parse_dict {
   my ($name, $string) = @_;
   for my $pair (split ",", $string) {
      my ($k, $v) = map { urldecode($_) } split ':', $pair;
      if (!defined($v)) {
         print STDERR "-- Setting value for $k to 1\n" if $B_verbose;
         $v = 1;
      }
      $::dict{$name}{$k} = $v;
   }
   my $n = keys %{$::dict{$name}};
print STDERR "-- dictionary $name has $n keys after parsing string\n" if $B_verbose;
}

while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;

  if ($options =~ /^\-(z+)$/) {
    local $, = ' ';
    print map { length($1) % 2 == 1 ? urlencode($_) : urldecode($_) } @::spec;
    if (@::spec) { print "\n"; }
    else { print STDERR <<EOH;
-- I url-encode (-z) or decode (-zz) any arguments. Useful cases:
  ^   %5E     ;   %3B     (  %28     <TAB>      %09
  :   %3A     !   %21     )  %29     <NEWLINE>  %0A
  ,   %2C     /   %2F     <  %3C     <CR>       %0D
  %   %25     \\   %5C     >  %3E     <SPACE>    %20     =   %3D
For shell meta-characters it is easiest to just quote the argument to pick.
EOH
    }
    exit 0;
  }
  elsif ($options eq '-l') {
    my $filter = @::spec ? $::spec[0] : '.';
    print "\nSelect comparison operators:\n  @opsf\n\n";
    printf "%-12s%-12s%-20s%s\n", 'Operator', 'Consumed', 'Produced', 'Description';
    print  '-' x 80 . "\n";
    for my $op (sort keys %cp_opdefinitions) {
      my $opdef = $cp_opdefinitions{$op};
      my @help = split "\t", $opdef->[2];
      next unless $help[3] =~ /$filter/;
      printf "%-12s%-12s%-20s%s [%s]\n", $op, @help;
    }
    if ($filter eq '.') { print "\nUse -l <query> to limit output to sections matching <query>, e.g pick -l string\nSections: $opsections\n" }
    else { print "\nAll operators in section(s) matching <$filter>\nSections: $opsections\n" }
    exit 0;
  }
  elsif ($options eq '-H') {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
  See further below for <op> list.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a select criterion comparing a handle to a constant value. 
Form (3) creates a select criterion comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op><VAL>
@<COLNAME><op>:<COLNAME>  select rows based on <VAL> or value in column <COLNAME>.

<op> is one of the following:
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/<what>
  /ep/<what>/epsilon  Column value lies in [ <what> - epsilon, <what> + epsilon ] (default $::EPSILON)
  /om/<what>
  /om/<what>/oom      |Column value| lies in [ |<what>| / oom, |<what>| * oom ] (default $::OOM)
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> and <handle> will be url-decoded. In particular, if you
  need one of [%^:,/~] in <string> it is best to url-encode it with 25, 5E, 3A,
  2C, 2F, 7E respectively; use pick -z <string> to find its URL-encoded form.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).

  If the very first part starts with anything other than [,:^] it is inferred
  to be a handle (leading : not needed).  <COMPUTE> is a stack, so
  zut::foo:bar,add^str,cat creates a new column called zut by adding columns
  foo and bar and then concatenating 'str'. The default operation is
  concatenation; if no operators are left the remainder of the stack is
  concatenated. Thus the above is equivalent to zut::foo:bar,add^str. To just
  prefix a column: zut::^foo:zut To concatenate two columns: zut::foo:bar .
  Use -l to see the description of operators.

Environment variables with default settings:
$envsettings

Useful perl regular expression features:
   Use \\K (keep) to anchor a pattern but retain it with ed, edg, del, delg
   :HANDLE^'patx\\Kpaty',delg will retain patx and only delete paty.
   Use patx(?=paty) to anchor patx to paty without including paty in the matched part.
   :HANDLE^'patx(?=paty)',get will just fetch patx.
   Use (?i)pat to make a pattern case insensitive.
EOH
  exit 0;
  }

  if ($options =~ /^--fdict-(\w+)(\/(.*?))?=(.+)$/) {
    read_dict($1, $4);
    $::dictnotfound{$1} = $3 if length($2);
    next;
  }
  elsif ($options =~ /^--cdict-(\w+)(\/(.*?))?=(.+)$/) {
    parse_dict($1, $4);
    $::dictnotfound{$1} = $3 if length($2);
    next;
  }
  elsif ($options =~ /^--(add-)?inames=(.+)$/) {
    $nameslist=$2;
    $B_add_names = $1 ? 1 : 0;
    next;
  }
  elsif ($options eq '--remind-me' || $options eq '--rmm')  {
    if (!@::spec) {
      print "Available reminders: sam\n"; exit 0;
    }
    if ($::spec[0] eq 'sam') {
    print <<EOH;
  1     2     3     4     5     6     7     8     9    10    11
QNAME FLAG  RNAME  POS  MAPQ  CIGAR  RNEXT PNEXT TLEN SEQ   QUAL
EOH
    exit 0;
    }
  }
  elsif ($options =~ /^--sam(-h)?$/) {
     if (defined($1)) { $M_ignore |= 5; $PAT_PASS  = '^@'; }
     else             { $M_ignore |= 6; $PAT_PURGE = '^@'; }
     $B_headless = 1;
     $OFFSET_OMEGA = 11;
     $::dictnotfound{seqlen} = 0;
     for (keys %cp_samdefs) { $cp_opdefinitions{$_} = $cp_samdefs{$_}; }
     next;
  }

  if ($options =~ s/\/\/(.*)$//)    { $M_ignore |= 1; $PAT_PASS  = $1; }   # urldecode $PAT_PASS?
  if ($options =~ s/\/([^\/].*)$//) { $M_ignore |= 2; $PAT_PURGE = $1; }   # urldecode $PAT_PURGE?

  if ($options =~ s/O(\d+)//) {
     $OFFSET_OMEGA = $1 + 0;
     die "-O<N> N must be positive\n" unless $OFFSET_OMEGA > 0;
  }

  if ($options =~ s/E(\d+)//) {
     $N_expect = $1 + 0;
     die "-E<N> N must be nonnegative\n" unless $N_expect >= 0;
  }

  if ($options =~ s/A(-?\d+)?//) {
     $B_printall     = 1;
     if (defined($1)) {
        $INSERT_OFFSET = $1 + 0;
     }
  }

  $B_print_header = 0 if $options =~ s/h//;
  $B_regex        = 0 if $options =~ s/F//;
  $B_protect      = 1 if $options =~ s/P//;
  $B_select_and   = 0 if $options =~ s/o//;
  $B_verbose      = 1 if $options =~ s/v//;
  $B_ko           = 1 if $options =~ s/U//;
  $B_print_tally  = 1 if $options =~ s/T//;
  $B_excise       = 1 if $options =~ s/x//;
  $B_add_row_column =1 if $options =~ s/R//;
  $B_headless     = 1 if $options =~ s/k//;
  ($B_headless, $B_sprouthead)= (1, 1) if $options =~ s/K//;
  ($B_headless, $B_weirdmode) = (1, 1) if $options =~ s/W//;
  $B_debug        = 1 if $options =~ s/d//;
  $B_force        = 1 if $options =~ s/f//;
  $B_inplace      = 1 if $options =~ s/i//;
  ($B_count, $B_print_header) = (1, 0) if $options =~ s/c//;

  if ($options ne '-') {
    print STDERR "Option string not fully parsed: $options remains\n";
    exit 1;
  }
}

die "-O<N> requires -k\n" if $OFFSET_OMEGA > 0 && !$B_headless;

$B_print_header = 0 if $B_headless;
$B_print_header = 1 if $B_add_names;

@::nameslist = $nameslist ? split ',', $nameslist : ();

helphelp(1) unless @::spec || $B_printall || $B_excise || $B_force || $B_count;

sub interval_plus {
  my ($x, $y, $val) = @_;
  my $epsilon = $val ? $val : $::EPSILON;
  return $x <= $y + $epsilon && $x >= $y - $epsilon;
}

sub interval_mul {
  my ($x, $y, $val) = @_;
  my $oom = $val ? $val : $::OOM;
  return abs($x) <= abs($y) * $oom && abs($x) >= abs($y) / $oom;
}


my $TYPE_SCALAR = 1;
my $TYPE_HANDLE = 2;
my $TYPE_OPATOR = 3;    # (1) rule of six obvs, (2) it makes sense in Dutch.

my %chartypetonum = ( '^', $TYPE_SCALAR, ':', $TYPE_HANDLE, ',', $TYPE_OPATOR );

sub parse_compute {
  my ($handle, $spec) = @_;
  my @oplist = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[,^:]/;
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]*)/g) {
    my ($type, $what) = ($chartypetonum{$1}, $2);
    $what = urldecode($what) if $type == $TYPE_SCALAR || $type == $TYPE_HANDLE;     #constant.
    push @oplist, [$type, $what];
    $p = pos($spec);
    if ($type == $TYPE_OPATOR) {
      my $opdef = $cp_opdefinitions{$what};
      die "Not supported [$what]\n" unless defined($opdef);
                           # N stack required, code.
      push @{$oplist[-1]}, ($opdef->[0], $opdef->[1]);
print STDERR "-- $handle >> type=$type op=$what N=$opdef->[0], code=$what:$opdef->[1]\n" if $B_debug;
    }
    else {
print STDERR "-- $type $what >>\n" if $B_debug;
    }
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oplist;
}

sub urlencode {
   my $val = shift;
   $val =~ s/([^A-Za-z0-9_])/ uc sprintf "%%%0x", ord $1 /eg;
   return $val;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


sub acigar {

   my ($cigar, $subset, $mode) = @_;
   my $key = "cigar::$cigar";
   my @subset = split "", $subset;

   if (!defined($::LINECACHE{$key})) {
      my $c = $::LINECACHE{$key} =
        { sum   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , max   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , count => { map { ($_, 0)  } split "", 'MINDSHP=X' } };
      my $p = 0; my $n = 0;
      while ($cigar =~ m/(\d+)([MIDNSHP=X])/ig) {
        my ($num, $it) = ($1, $2);
        $n += length($&);
        $c->{sum}{$it} += $num;
        $c->{count}{$it}++;
        $c->{max}{$it} = $num if $num > $c->{max}{$it};
        $p = pos($cigar);
      }
print STDERR "-- Unmatched part in cigar string $cigar at $p (line $.)\n" unless $p == length($cigar) && $n == length($cigar);
   }
   my $cache = $::LINECACHE{$key};
   if ($mode eq 'max')      { my $max = 0; for my $x (@subset) { $max = $cache->{max}{$x} if $cache->{max}{$x} > $max }; return $max }
   elsif ($mode eq 'sum')   { my $sum = 0; $sum += $cache->{sum}{$_} for @subset; return $sum }
   elsif ($mode eq 'count') { my $count = 0; $count += $cache->{count}{$_} for @subset; return $count }
   else                     { return 'NA' }
}

sub add_column {
  print "\t" if $::N_column_output++; print $_[0];
}

   ## Returns an arrary of matches; each match is an array [name1, name2].
   ## name1 is the existing name (found in header), name2 is the new name, normally the same.
   ## New names can be made by the prefix/suffix convention as well as using regex parentheses ().
   ##
sub expand_list_range_and_regex {
   my ($spec, $has_compute) = @_;
   my @matches = ();
   my ($suffix, $prefix, $duplicate) = ("", "", 0);
   if ($has_compute) {             # in this case accept p/spec/s syntax for column renaming and p/spec//s for duplicating
      $duplicate = $spec =~ /\/\// ? 1 : 0;
      my @parts = split /\/+/, $spec, -1;
      if (@parts > 3) { die "Handle has more than three /-separated parts"; }
      elsif (@parts == 3) { ($prefix, $spec, $suffix) = @parts; }
      elsif (@parts == 2) {   # to specify just prefix, one needs p/spec/
        ($spec, $suffix) = @parts;
        if ($suffix =~ /[:$REGEXP_CHARS]/) {       # ':' is there as we split on that.
print STDERR "Suffix [$suffix] contains regex/list characters, did you mean '$spec/$suffix/'?\n";
        }
      }
   }

   for my $item ($spec eq '' ? ("") : split ':', $spec, -1) {
print STDERR "-- (output) considering $item\n" if $B_verbose;
      if ($item =~ /[$REGEXP_CHARS]/ && $B_regex) {
         my $nfound = 0;
         for my $name (@::HEADER[0..($::N-1)]) {
            if ($name =~ qr/$item/) {
               push @matches, [$name, defined($1) ? $1 : $name];
               $nfound++;
            }
         }
print STDERR "-- (output) $item was considered as regex and yielded no matches\n" unless $nfound;
      }
      elsif ($item =~ /^(\d+)\-(\d+)?$/ && $B_headless) {
         my ($x, $y) = ($1, $2);
         $x = 1 if $x > $::N;
         $y = $::N if !defined($y) || $y > $::N;
         push @matches, map { [$_, $_] } @::HEADER[($x-1)..($y-1)];
      }
      else {
         push @matches, [$item, $item];
      }
   }
   my $n_matches = @matches; local $" = ' ';
   $_->[1] = "$prefix$_->[1]$suffix" for @matches; my @matchnames = map { $_->[0] } @matches;
print STDERR "-- (output) item $spec ($n_matches results: @matchnames)\n" if $B_verbose || (!$n_matches && $spec);
   # dangersign, below is ugly.
   unshift @matches, $duplicate if $has_compute;
   return (@matches);
}

sub wrangle_header {

  if ($::HEADER[0] eq '')   { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_'; }

  $::N = @::HEADER;
  my %inheader = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name}) && !defined($B_force);
    $::handle_map{$name} = $i;   
print STDERR "-- map header name $name to offset $i\n" if $B_debug;
  }

  for my $spec (@::spec) {
    if ($spec =~ /^(.*?)(:[:=])(.*)/) {
      my ($handle, $type, $compute) = (urldecode($1), $2, $3);
      die "Compute cannot be empty\n" unless length($compute);
      $handle = $DUMMY_NAME++ if $handle eq '';
      my ($duplicate, @matches) = expand_list_range_and_regex($handle, 1);
      $compute = ":$compute" unless $compute =~ /^[,:^]/;
      for my $m (@matches) {
        my $compute_m = $compute; $compute_m =~ s/:__\b/:$m->[0]/g;
        my $parsed_compute = parse_compute($handle, $compute_m);
        push @::compute, [$m->[1], $parsed_compute];
        push @::output_nm, $m->[0] if $duplicate;
        push @::output_nm, $m->[1] if $type eq '::';
      }
    }
                  #  H handle
                  #  a1a2a3, b, c, d different forms for op
                  #  V value or :handle
                  #    ( H )([ a1](      a2    )[ a3]|  b    | c | d )( V)(  arg )
    elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~]|[=~]{1}|\/=|\/~)(.*?)(\/.*?)?$/) {
      my ($handle, $op, $val, $arg) = (urldecode($1), $2, urldecode($3), $4);      #constant
      die "Unrecognised operator [$op]\n" unless defined($sel_opdefinitions{$op});
      if (defined($arg)) {
        die "Extra argument currently only allowed for /ep/ and /om/" unless $op =~ /^\/(ep|om)\/$/;
        $arg =~ s|^\/||;
        $arg=urldecode($arg);      #constant
      }
      else{
         $arg = 0;
      }
print STDERR "-- adding select criterion handle=[$handle] op=[$op] val=[$val] arg=[$arg]\n" if $B_debug;
      my $indirection = $val =~ s/^:// ? 1 : 0;
      push @::select, [$op, $indirection, $val, $handle, $arg];
               # NOTE. $arg for now only used by /ep/ and /om/ selection, ignored by the others.
    }
    elsif ($B_headless && $spec =~ /^((\d+)\+)?(\d+)-(\d+)(\*(\d+))?$/) {
      my ($offset, $start, $end, $multiply) = ($2, $3, $4, $6);
      $offset   = 0 unless defined($offset);
      $multiply = 1 unless defined($multiply);
      my @colindexes = map { $offset + $_ * $multiply } $start..$end;
      for (@colindexes) {
         push @::output_nm, $_;
      }
    }
    else {
      $spec = urldecode($spec);
      my @matches = expand_list_range_and_regex($spec, 0);
      for my $m (@matches) { push @::output_nm, $m->[0]; }
    }
  }

  @::output_nm = sort { $a <=> $b } keys %{{ map { ($_, 1) } @::output_nm }} if $B_ko;

  $::plain_handle{$_} = 1 for @::output_nm;

local $" = ',';
print STDERR "-- output column names as specified: [@::output_nm]\n" if $B_debug;
  if ($B_excise || $B_printall) {
    my @new_names = grep { !defined($inheader{$_}) } @::output_nm;
    if ($B_excise) {
       @::output_nm = grep { !defined($::plain_handle{$_}) } @::HEADER
    }
    else {
       @::output_nm = @::HEADER;
    }
    if (defined($INSERT_OFFSET)) {
      $INSERT_OFFSET = @::output_nm if $INSERT_OFFSET > @::output_nm;
      $INSERT_OFFSET = -1 * @::output_nm if $INSERT_OFFSET < -1 * @::output_nm;
      splice @::output_nm, $INSERT_OFFSET, 0, @new_names;
    }
    else {
       push @::output_nm, @new_names;
    }
  }
print STDERR "-- output column names after -i/-a treatment: @::output_nm\n" if $B_debug && ($B_excise || $B_printall);

  { my %names = (); my $i = 1;
    for (@::output_nm) { $names{$_} = $i++ unless defined($names{$_}) }
    if (keys %names < @::output_nm) {
       my $job = $B_force ? 'leaving as specified' : 'will make unique';
print STDERR "-- Identical output column names exist ($job)\n";
       @::output_nm = sort { $names{$a} <=> $names{$b} } keys %names unless $B_force;
    }
  }

  #
  ##  Add derived column names to @::HEADER
  ##  Expand regex specifications if found.
  ##  In derived column specs replace names by offsets into field array.
  #

  for (my $i=0; $i<@::compute; $i++) {
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name already defined (use -i for in-place change)\n" if defined($::handle_map{$name}) && !$B_inplace;
    my @expanded_compute = ();
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         my @matches = expand_list_range_and_regex($what, 0);
         for my $h (@matches) { push @expanded_compute, [$TYPE_HANDLE, $h->[0]]; }
      }
      else {
         push @expanded_compute, $comp;
      }
    }
    for my $comp (@expanded_compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         die "Handle [$what] in compute $name does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};     # fixme overwrite inelegant
                              # inplace NOTE. when using foo::foo^1,add, this maps the lookup for the second foo to the offset
                              # for the current foo, and the second foo no longer exists. The first foo does not have an
                              # associated offset yet;
      }
    }
    $::compute[$i] = [$name, \@expanded_compute];

    my $j = $::N + $i;
    $::HEADER[$j] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $j;
                              # inplace NOTE continued. Future lookups for foo will refer to this definition; This includes output.
                              # This process is consistently applied if multiple foo:: are specified.
print STDERR "-- map compute name [$name] to offset $j\n" if $B_debug;
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle [$name] in output does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "-- output columns @::output_os --\n" if $B_debug;

  #
  ##  In select list replace names by offsets into field array.
  #

  for my $sel (@::select) {

    my ($op, $indirection, $val, $name, $arg) = @$sel;

    die "Handle [$name] in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});

    my $opdef = $sel_opdefinitions{$op};
    die "The impossible happened ($op)\n" unless defined($opdef);
    $sel->[0] = $opdef->[1];             # fixme overwrite inelegant

    $sel->[3] = $::handle_map{$name};    # fixme overwrite inelegant
    if ($indirection) {
       die "Handle [$val] in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$val});
       $sel->[2] = $::handle_map{$val};  # fixme overwrite inelegant
    }
    { my ($code, $indirection, $val, $name, $arg) = @$sel;
print STDERR "-- select code=$code ind=$indirection val=$val name=$name arg=$arg --\n" if $B_debug; }

  }

  for (@::HEADER) {
    $_ = '' if $_ eq '_';
  }
}


sub do_compute {

  my $F = shift;

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    @::STACK = ();

    for my $comp (@$compute) {

      my ($type, $what, @other) = @$comp;

         if ($type == $TYPE_HANDLE) { push @::STACK, $F->[$what]; }
      elsif ($type == $TYPE_SCALAR) { push @::STACK, $what; }
      elsif ($type != $TYPE_OPATOR) { die "Really unfortunate!\n"; }

      else {
         my ($n_wanted, $code) = @other;
         die "Stack underflow ($spic->[0] item [$what])\n" unless @::STACK >= $n_wanted;
         &{$code};
         pop @::STACK while --$n_wanted > 0;    # subs put computed element in the right place.
      }
    }
    push @$F, (join "", @::STACK);
  }
  die "Cp error\n" unless @::HEADER == @$F;
}


 $::Nrows = 0;    # includes header.
my $Nignr = 0;
my $Ndisc = 0;
my $Nkeep = 0;

while (<>) {

  %::LINECACHE = ();

  if ($M_ignore) {
    my $hit1 = ($M_ignore & 1) && /$PAT_PASS/  ? 1 : 0;
    my $hit2 = ($M_ignore & 2) && /$PAT_PURGE/ ? 1 : 0;
    if ($hit1 || $hit2) {
       print "$_" if $hit1;
       $Nignr++;
       if (($M_ignore & 4) && /SN:(\S+)\s+LN:(\d+)/) {
         $::dict{seqlen}{$1} = $2;
       }
       next;
    }
  }

  chomp;
  my @F = length($_) ? split "\t", $_, $OFFSET_OMEGA : ("");
  $::Flink = \@F;

  if ($OFFSET_OMEGA > 0 && @F < $OFFSET_OMEGA) {
    push @F, ( ("") x ($OFFSET_OMEGA - @F)) ;
  }
  if (!$::Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    if (@::nameslist) {
      local $" = ' ';
      die "New names [@::nameslist] and data names [@::HEADER] differ in cardinality" if scalar @::nameslist != scalar @::HEADER;
      @::HEADER = @::nameslist;
    }
    wrangle_header();
    if ($B_print_header || $B_sprouthead) {
      local $, = "\t";
      print map { $::HEADER[$_] } @::output_os;
      $::N_column_output = @::output_os;
      add_column("T") if $B_print_tally;
      print "\n";
    }
    $::Nrows++;
    next unless $B_headless;
  }
  else {
    my $F = @F;
    die "Header/$::N column/$F count difference at line $. (consider -R or -O<N>)" unless $F == $::N;
    $::Nrows++;
  }

  do_compute(\@F) if @::compute;         # this pushes compute onto @F if present.

  my $nmatch = 0;

  if ($B_weirdmode && $::Nrows == 1) {
    $Nkeep++;
  }
  else {
     for my $sel (@::select) {
       my ($op, $indirection, $val, $colid, $arg) = @$sel;
       $val = $F[$val] if $indirection;
       $nmatch++ if $op->($F[$colid], $val, $arg);
         # $arg currently only used for /ep/ and /om/
     }
     if (@::select && (($nmatch != @::select && $B_select_and) || ($nmatch == 0 && !$B_select_and))) {
       $Ndisc++;
       next unless $B_print_tally;
     }
     else {
       $Nkeep++;
     }
  }

  next if $B_count;        # $Nkeep is the only thing that interests us.

  local $, = "\t";
  print map { $F[$_] } @::output_os;
  $::N_column_output = @::output_os;

  add_column($nmatch) if $B_print_tally;
  print "\n";
}

print "$Nkeep\n" if $B_count;

print STDERR "-- $Nignr ignored lines in input\n" if $M_ignore && $B_verbose;
my $would = $B_print_tally ? ' would' : '';
print STDERR "-- $Nkeep/$Ndisc rows$would have been kept/discarded\n" if @::select && $B_verbose;

my $B_header = 1 - $B_headless;
print STDERR "== Line tally check failed: ($::Nrows != $B_header+$Nkeep+$Ndisc)\n" if $::Nrows != $B_header+$Nkeep+$Ndisc;

if ($N_expect >= 0 && $N_expect != $Nkeep) {
   print STDERR "== Expected number $N_expect but pick found $Nkeep\n";
   exit 1;
}

